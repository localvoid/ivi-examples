{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/operations.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/factories.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/dom/shortcuts.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/token.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/box.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/error.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/noop.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/array.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/repeatable_task_list.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/dom/namespaces.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/state.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/context.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/reconciler.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/root.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/scheduler/index.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/dispatch.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/dom/feature_detection.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/utils.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/native_events.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/shortcuts.ts","webpack:////home/void/w/ts/ivi/packages/ivi-html/src/index.ts","webpack:///./src/main.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","createOpType","f","EVENTS","TRACK_BY_KEY","createValueOp","v","createContainerOp","createDOMElementOp","Events","operations_key","k","TrackByKey","items","elementFactory","tag","flags","htmlElementFactory","statelessComponent","e","type","props","getDescriptor","getOwnPropertyDescriptor","nodeProto","Node","shortcuts_elementProto","Element","doc","document","objectHasOwnProperty","nodeInsertBefore","insertBefore","nodeRemoveChild","removeChild","nodeCloneNode","replaceChild","cloneNode","elementSetAttribute","setAttribute","elementRemoveAttribute","setAttributeNS","removeAttribute","nodeSetTextContent","set","elementSetClassName","htmlElementGetStyle","HTMLElement","svgElementGetStyle","SVGElement","TASK_TOKEN","SELECT_TOKEN","UNMOUNT_TOKEN","box","ERROR_HANDLERS","error","catchError","fn","apply","arguments","forEach","h","NOOP","unorderedArrayDeleteByIndex","array","index","length","last","pop","runRepeatableTasks","tasks","SVG_NAMESPACE","createStateNode","_nextNode","_deepStateFlags","context_n","setContext","_pushDeepState","_popDeepState","prev","current","getDOMNode","opState","_dirtyCheck","parentElement","moveNode","singleChild","state","deepState","_update","_moveNodes","children","_unmountWalk","u","_unmountRemove","_unmount","_mountText","op","node","createTextNode","_createElement","svg","tagName","createElementNS","createElement","_updateClassName","_updateAttrs","_mountObject","opType","deepStateFlags","prevState","_mount","Array","_mountFragment","childrenOps","newChildren","nextOp","nodeValue","opStateChildren","prevData","nextData","nextValue","_updateChildrenTrackByKeys","a","b","j","result","aEnd","bEnd","start","outer","pos","updated","aLength","bLength","sources","keyIndex","Map","seq","lis","slice","element","className","_updateStyle","style","bValue","setProperty","removeProperty","matchCount","keys","_updateAttr","next","ROOTS","findRoot","predicate","find","dirtyCheck","root","container","run","_flags","_frameStartTime","_resolvedPromise","Promise","resolve","_microtasks","_mutationEffects","_layoutEffects","_beforeMutations","_afterMutations","withSchedulerTick","inner","runMicrotasks","withNextFrame","time","_handleNextFrame","_handleNextFrameSync","requestNextFrame","task","push","then","requestAnimationFrame","requestDirtyCheck","render","collectDispatchTargets","target","match","targets","contains","visitUp","stateNode","parentNode","visitDown","collectDispatchTargetsFromEventsOpState","source","dispatchEvent","src","event","currentTarget","descriptor","window","dispatchNativeEvent","createNativeEventSource","options","addEventListener","nativeEventHandlerFactory","bubbleDescriptor","captureDescriptor","capture","onClick","_","div","li","pre","table","tbody","td","tr","ul","TableCell","console","log","TableRow","id","active","data-id","map","item","Table","AnimBox","background","border-radius","Anim","TreeLeaf","TreeNode","Tree","route","location","anim","tree","Main","uibench","init","querySelector","samples","JSON","stringify","undefined"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","import { EventHandler } from \"../events/event_handler\";\nimport { NodeFlags } from \"./node_flags\";\nimport { ElementProtoDescriptor } from \"./element_proto\";\nimport { ComponentDescriptor, StatelessComponentDescriptor } from \"./component\";\nimport { ContextDescriptor, ContextState } from \"./context\";\n\n/**\n * Key is an object that is used by TrackByKey operations to track operations.\n *\n * @typeparam K Key type.\n * @typeparam V Value type.\n */\nexport interface Key<K, V> {\n  /**\n   * Key.\n   */\n  readonly k: K;\n  /**\n   * Value.\n   */\n  readonly v: V;\n}\n\n/**\n * Operation type.\n */\nexport interface OpType {\n  /**\n   * See {@link NodeFlags} for details.\n   */\n  readonly f: NodeFlags;\n  /**\n   * Operation type descriptor.\n   */\n  readonly d:\n  | StatelessComponentDescriptor\n  | ComponentDescriptor\n  | ElementProtoDescriptor\n  | ContextDescriptor\n  | string\n  | null;\n}\n\n/**\n * createOpType creates {@link OpType} instances.\n *\n * @param f See {@link NodeFlags} for details.\n * @param d Operation type descriptor.\n * @returns {@link OpType} instance.\n */\nexport const createOpType = (\n  f: NodeFlags,\n  d: StatelessComponentDescriptor | ComponentDescriptor | ElementProtoDescriptor | ContextDescriptor | string | null,\n): OpType => ({ f, d });\n\n/**\n * OpType for Events nodes.\n */\nexport const EVENTS = createOpType(NodeFlags.Events, null);\n\n/**\n * OpType for Context state nodes.\n */\nexport const SET_CONTEXT_STATE = createOpType(NodeFlags.Context | NodeFlags.SetContextState, null);\n\n/**\n * OpType for TrackByKey nodes.\n */\nexport const TRACK_BY_KEY = createOpType(NodeFlags.TrackByKey, null);\n\n/**\n * Operation with a value.\n *\n * @typeparam T Operation data type.\n */\nexport interface ValueOp<T = any> {\n  /**\n   * Operation type.\n   */\n  readonly t: OpType;\n  /**\n   * Value.\n   */\n  readonly v: T;\n}\n\n/**\n * Container operation.\n *\n * @typeparam T Operation data type.\n */\nexport interface ContainerOp<T = any> extends ValueOp<T> {\n  /**\n   * Children.\n   */\n  readonly c: Op;\n}\n\n/**\n * DOM Element operation.\n *\n * @typeparam T Operation data type.\n */\nexport interface DOMElementOp<T = any> extends ContainerOp<T | undefined> {\n  /**\n   * Class name.\n   */\n  readonly n: string | undefined;\n}\n\n/**\n * Events operation.\n */\nexport type EventsOp = ContainerOp<EventHandler>;\n\n/**\n * Context operation.\n */\nexport type ContextOp<T = any> = ContainerOp<T>;\n\n/**\n * Set context state operation.\n */\nexport type SetContextStateOp = ContainerOp<ContextState>;\n\n/**\n * TrackByKey operation.\n */\nexport type TrackByKeyOp<K = any, V = any> = ValueOp<Key<K, V>[]>;\n\n/**\n * Component operation.\n */\nexport type ComponentOp<T = any> = ValueOp<T>;\n\n/**\n * Operation node.\n */\nexport type OpNode =\n  | ValueOp\n  | ContainerOp\n  | DOMElementOp\n  | EventsOp\n  | ContextOp\n  | SetContextStateOp\n  | TrackByKeyOp\n  | ComponentOp;\n\n/**\n * Operation.\n */\nexport type Op = string | number | OpNode | OpArray | null;\n\n/**\n * Recursive operation array.\n */\nexport interface OpArray extends Array<Op> { }\n\n/**\n * createValueOp creates a {@link ValueOp} instance.\n *\n * @typeparam T Operation data type.\n * @param t Operation type.\n * @param v Operation value.\n * @returns {@link ValueOp} instance.\n */\nexport const createValueOp = <T>(t: OpType, v: T): ValueOp<T> => ({ t, v });\n\n/**\n * createContainerOp creates a {@link ContainerOp} instance.\n *\n * @typeparam T Operation data type.\n * @param t Operation type.\n * @param v Operation value.\n * @param c Operation children.\n * @returns {@link ContainerOp} instance.\n */\nexport const createContainerOp = <T>(t: OpType, v: T, c: Op): ContainerOp<T> => ({ t, v, c });\n\n/**\n * createDOMElementOp creates a {@link DOMElementOp} instance.\n *\n * @typeparam T Operation data type.\n * @param t Operation type.\n * @param v Operation value.\n * @param c Operation children.\n * @param n Class name.\n * @returns {@link DOMElementOp} instance.\n */\nexport const createDOMElementOp = <T>(\n  t: OpType,\n  v: T,\n  c: Op,\n  n: string | undefined,\n): DOMElementOp<T> => ({ t, v, c, n });\n\n/**\n * Operation factory for event handlers.\n *\n * @example\n *\n *     render(\n *       Events(onClick(() => { console.log(\"clicked\"); }),\n *         ChildComponent(),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param v Event handlers.\n * @param c Children operation nodes.\n * @returns Events handler operation.\n */\nexport const Events = (\n  v: EventHandler,\n  c: Op,\n): EventsOp => createContainerOp(EVENTS, v, c);\n\n/**\n * Operation factory for set context state operation.\n *\n * @param v Context state.\n * @param c Children operation nodes.\n * @returns Set context state operation.\n */\nexport const SetContextState = (\n  v: ContextState,\n  c: Op,\n): SetContextStateOp => createContainerOp(SET_CONTEXT_STATE, v, c);\n\n/**\n * key creates a {@link Key} instance.\n *\n * @typeparam K Key type.\n * @typeparam V Value type.\n * @param k Key.\n * @param v Value.\n * @returns {@link Key} instance.\n */\nexport const key = <K, V>(k: K, v: V): Key<K, V> => ({ k, v });\n\n/**\n * Operation factory for track by key nodes.\n *\n * @example\n *\n *     const items = [1, 2, 3];\n *     render(\n *       TrackByKey(items.map((item) => key(item, div(_, _, item))),\n *       DOMContainer,\n *     );\n *\n * @typeparam K Key type.\n * @param items Keyed operations.\n * @returns Track by key operation.\n */\nexport const TrackByKey = process.env.NODE_ENV !== \"production\" ?\n  <T>(items: Key<T, Op>[]) => {\n    const keys = new Set<T>();\n    for (let i = 0; i < items.length; i++) {\n      const { k } = items[i];\n      if (keys.has(k)) {\n        throw new Error(`Invalid key, found duplicated key: ${k}`);\n      }\n      keys.add(k);\n    }\n    return createValueOp(TRACK_BY_KEY, items);\n  } :\n  /* istanbul ignore next */ <T>(items: Key<T, Op>[]) => createValueOp(TRACK_BY_KEY, items);\n","import { checkElement } from \"../debug/element\";\nimport { NodeFlags } from \"./node_flags\";\nimport { Op, ValueOp, DOMElementOp, createOpType, createDOMElementOp, createValueOp } from \"./operations\";\nimport { Component } from \"./component\";\n\n/**\n * elementFactory creates a factory for DOM elements.\n *\n * @param tag HTML element tag name.\n * @param flags Node flags.\n * @returns HTML element operation factory.\n */\nexport function elementFactory<T, U>(tag: string, flags: NodeFlags) {\n  const t = createOpType(flags, tag);\n  return process.env.NODE_ENV !== \"production\" ?\n    (n?: string, v?: T, c: Op = null) => {\n      checkElement(tag, v, (flags & NodeFlags.Svg) !== 0);\n      return createDOMElementOp(t, v, c, n);\n    } :\n    /* istanbul ignore next */(n?: string, v?: T, c: Op = null) => createDOMElementOp(t, v, c, n);\n}\n\n/**\n * htmlElementFactory creates a factory for HTML elements.\n *\n * @param tag HTML element tag name.\n * @returns HTML element operation factory.\n */\nexport const htmlElementFactory: <T, U>(tag: string) => (\n  className?: string,\n  attrs?: T,\n  children?: Op,\n) => DOMElementOp<T | undefined> = (tag: string) => elementFactory(tag, NodeFlags.Element);\n\n/**\n * svgElementFactory creates a factory for SVG elements.\n *\n * @param tag SVG element tag name.\n * @returns SVG element operation factory.\n */\nexport const svgElementFactory: <T, U>(tag: string) => (\n  className?: string,\n  attrs?: T,\n  children?: Op,\n) => DOMElementOp<T | undefined> = (tag: string) => elementFactory(tag, NodeFlags.Element | NodeFlags.Svg);\n\n/**\n * `elementProto()` creates a factory that produces elements with predefined attributes.\n *\n * @example\n *\n *     const DivWithIdAttribute = elementProto(div(_, { id: \"predefined-id\" }));\n *\n *     render(\n *       DivWithIdAttribute(\"class-name\", { title: \"Title\" }, \"Hello World\"),\n *       document.getElementById(\"app\")!,\n *     );\n *\n * @param p Element prototype.\n * @returns Factory that produces elements with predefined attributes.\n */\nexport function elementProto<T>(p: DOMElementOp<T>) {\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    if (p.c !== null) {\n      throw new Error(`Invalid OpNode, element prototypes can't have any children`);\n    }\n    checkElement(p.t.d as string, p.v, (p.t.f & NodeFlags.Svg) !== 0);\n  }\n  const t = createOpType(p.t.f | NodeFlags.ElementProto, { n: null, p });\n  return (n?: string, v?: T, c: Op = null) => createDOMElementOp(t, v, c, n);\n}\n\n/**\n * component creates a factory that produces component nodes.\n *\n * @example\n *\n *     const A = component<string>(() => {\n *       let _text;\n *       const click = onClick(() => { console.log(_text); });\n *\n *       return (text) => (\n *         _text = text,\n *         Events(click,\n *           button(_, _, \"Click Me\"),\n *         )\n *       );\n *     });\n *\n * @param c Component function.\n * @returns Factory that produces component nodes.\n */\nexport function component(\n  c: (c: Component) => () => Op,\n): () => ValueOp<undefined>;\n\n/**\n * component creates a factory that produces component nodes.\n *\n * @example\n *\n *     const A = component<string>(() => {\n *       let _text;\n *       const click = onClick(() => { console.log(_text); });\n *\n *       return (text) => (\n *         _text = text,\n *         Events(click,\n *           button(_, _, \"Click Me\"),\n *         )\n *       );\n *     });\n *\n * @param c Component function.\n * @param areEqual `areEqual` function.\n * @returns Factory that produces component nodes.\n */\nexport function component<P>(\n  c: (c: Component) => (props: P) => Op,\n  areEqual?: undefined extends P ? undefined : (prev: P, next: P) => boolean,\n): undefined extends P ? (props?: P) => ValueOp<P> : (props: P) => ValueOp<P>;\n\n/**\n * component creates a factory that produces component nodes.\n *\n * @example\n *\n *     const A = component<string>(() => {\n *       let _text;\n *       const click = onClick(() => { console.log(_text); });\n *\n *       return (text) => (\n *         _text = text,\n *         Events(click,\n *           button(_, _, \"Click Me\"),\n *         )\n *       );\n *     });\n *\n * @param c Component function.\n * @param e `areEqual` function.\n * @returns Factory that produces component nodes.\n */\nexport function component<P>(\n  c: (c: Component) => (props: P) => Op,\n  e?: (prev: P, next: P) => boolean,\n): (props: P) => ValueOp<P> {\n  const type = createOpType(NodeFlags.Component | NodeFlags.Stateful | NodeFlags.DirtyCheck, { c, e });\n  return (props: P) => createValueOp(type, props);\n}\n\n/**\n * statelessComponent creates an factory that produces stateless components nodes.\n *\n * @example\n *\n *     const A = statelessComponent<string>((text) => div(_, _, text));\n *\n * @param update Update function.\n * @returns Factory that produces stateless component nodes.\n */\nexport function statelessComponent(\n  update: () => Op,\n): () => ValueOp<undefined>;\n\n/**\n * statelessComponent creates an factory that produces stateless components nodes.\n *\n * @example\n *\n *     const A = statelessComponent<string>((text) => div(_, _, text));\n *\n * @param update Update function.\n * @param areEqual `areEqual` function.\n * @returns Factory that produces stateless component nodes.\n */\nexport function statelessComponent<P>(\n  update: (props: P) => Op,\n  areEqual?: undefined extends P ? undefined : (prev: P, next: P) => boolean,\n): undefined extends P ? (props?: P) => ValueOp<P> : (props: P) => ValueOp<P>;\n\n/**\n * statelessComponent creates an factory that produces stateless components nodes.\n *\n * @example\n *\n *     const A = statelessComponent<string>((text) => div(_, _, text));\n *\n * @param c Update function.\n * @param e `areEqual` function.\n * @returns Factory that produces stateless component nodes.\n */\nexport function statelessComponent<P>(\n  c: (props: P) => Op,\n  e?: undefined extends P ? undefined : (prev: P, next: P) => boolean,\n): (props: P) => ValueOp<P> {\n  const type = createOpType(NodeFlags.Component, { c, e });\n  return (props: P) => createValueOp(type, props);\n}\n","/**\n * Shortcuts for DOM methods and properties are used to reduce megamorphic callsites in the codebase.\n *\n * In many synthetic microbenchmarks it is most likely will be slower, unless synthetic benchmark is implemented with\n * many different html/svg elements. But it is definitely should make it faster in complex real applications.\n *\n * Since Chrome 74, issue with native accessors is finally fixed: https://bugs.chromium.org/p/v8/issues/detail?id=8820\n */\n\n/**\n * `Object.getOwnPropertyDescriptor(o, p)`\n *\n * @param o Object.\n * @param p Property name.\n * @returns Property Descriptor.\n */\nconst getDescriptor = (o: any, p: string | number | symbol) => Object.getOwnPropertyDescriptor(o, p);\n\nconst nodeProto = process.env.IVI_TARGET === \"ssr\" ? void 0 : Node.prototype;\nconst elementProto = process.env.IVI_TARGET === \"ssr\" ? void 0 : Element.prototype;\n\n/**\n * Shortcut for a `Document`.\n */\nexport const doc = (process.env.IVI_TARGET === \"ssr\" ? void 0 : document) as Document;\n\n/**\n * Shortcut for an `Object.prototype.hasOwnProperty`.\n */\nexport const objectHasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Shortcut for a `Node.prototype.insertBefore`.\n */\nexport const nodeInsertBefore = process.env.IVI_TARGET === \"ssr\" ? void 0 : nodeProto!.insertBefore;\n\n/**\n * Shortcut for a `Node.prototype.removeChild`.\n */\nexport const nodeRemoveChild = process.env.IVI_TARGET === \"ssr\" ? void 0 : nodeProto!.removeChild;\n\n/**\n * Shortcut for a `Node.prototype.replaceChild`.\n */\nexport const nodeReplaceChild = process.env.IVI_TARGET === \"ssr\" ? void 0 : nodeProto!.replaceChild;\n\n/**\n * Shortcut for a `Node.prototype.cloneNode`.\n */\nexport const nodeCloneNode = process.env.IVI_TARGET === \"ssr\" ? void 0 : nodeProto!.cloneNode;\n\n/**\n * Shortcut for an `Element.prototype.setAttribute`.\n */\nexport const elementSetAttribute = process.env.IVI_TARGET === \"ssr\" ? void 0 : elementProto!.setAttribute;\n\n/**\n * Shortcut for an `Element.prototype.setAttributeNS`.\n */\nexport const elementSetAttributeNS = process.env.IVI_TARGET === \"ssr\" ? void 0 : elementProto!.setAttributeNS;\n\n/**\n * Shortcut for an `Element.prototype.removeAttribute`.\n */\nexport const elementRemoveAttribute = process.env.IVI_TARGET === \"ssr\" ? void 0 : elementProto!.removeAttribute;\n\n/**\n * Shortcut for a `Node.textContent = value`.\n */\nexport const nodeSetTextContent = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 :\n    getDescriptor(nodeProto, \"textContent\")!.set\n);\n\n/**\n * Shortcut for an `Element.className = value`.\n */\nexport const elementSetClassName = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 :\n    getDescriptor(elementProto, \"className\")!.set\n);\n\n/**\n * Shortcut for a `HTMLElement.style`.\n */\nexport const htmlElementGetStyle = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 :\n    getDescriptor(HTMLElement.prototype, \"style\")!.get\n);\n\n/**\n * Shortcut for a `SVGElement.style`.\n */\nexport const svgElementGetStyle = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 :\n    getDescriptor(SVGElement.prototype, \"style\")!.get\n);\n","export interface TaskToken {\n  readonly $$label?: \"ivi-task-token\";\n}\n\nexport interface SelectToken {\n  readonly $$label?: \"ivi-select-token\";\n}\n\nexport interface UnmountToken {\n  readonly $$label?: \"ivi-unmount-token\";\n}\n\n/**\n * Task token.\n */\nexport const TASK_TOKEN: TaskToken = (\n  process.env.NODE_ENV !== \"production\" ? Object.freeze({}) : /* istanbul ignore next */{}\n);\n\n/**\n * Select token.\n */\nexport const SELECT_TOKEN: SelectToken = (\n  process.env.NODE_ENV !== \"production\" ? Object.freeze({}) : /* istanbul ignore next */{}\n);\n\n/**\n * Unmount token.\n */\nexport const UNMOUNT_TOKEN: UnmountToken = (\n  process.env.NODE_ENV !== \"production\" ? Object.freeze({}) : /* istanbul ignore next */{}\n);\n\n/**\n * Empty object.\n */\nexport const EMPTY_OBJECT = process.env.NODE_ENV !== \"production\" ? Object.freeze({}) : /* istanbul ignore next */{};\n\n/**\n * Empty array.\n */\nexport const EMPTY_ARRAY = process.env.NODE_ENV !== \"production\" ? Object.freeze([]) : /* istanbul ignore next */[];\n","/**\n * Boxed value.\n *\n * @typeparam T Value type.\n */\nexport interface Box<T> {\n  v: T;\n}\n\n/**\n * box creates a boxed value.\n *\n * @typeparam T Value type.\n * @param v Value.\n * @returns Boxed value.\n */\nexport const box = <T>(v: T) => ({ v });\n","const ERROR_HANDLERS: Array<(e: any) => void> = [];\nlet error = false;\n\n/**\n * addErrorHandler adds an error handler for errors catched by functions decorated with `catchError()`.\n *\n * @param handler error handler.\n */\nexport function addErrorHandler(handler: (e: any) => void): void {\n  ERROR_HANDLERS.push(handler);\n}\n\n/**\n * catchError is a decorator that catches exceptions and invokes error handlers registered with `addErrorHandler()`.\n *\n * @noinline\n * @throws\n * @param fn - Function to decorate\n * @returns function decorated with a catchError\n */\nexport function catchError<T>(fn: (...args: any[]) => T): (...args: any[]) => T;\nexport function catchError<T>(fn: Function): (...args: any[]) => T {\n  return function () {\n    if (!error) {\n      try {\n        return fn.apply(void 0, arguments);\n      } catch (e) {\n        error = true;\n        ERROR_HANDLERS.forEach((h) => { h(e); });\n        throw e;\n      }\n    }\n  };\n}\n","/**\n * NOOP function.\n */\nexport const NOOP = () => { /**/ };\n\n/**\n * NOOP_FALSE function always returns `false` value.\n *\n * @returns `false` value.\n */\nexport const NOOP_FALSE = () => false;\n\n/**\n * NOOP_TRUE function always returns `true` value.\n *\n * @returns `true` value.\n */\nexport const NOOP_TRUE = () => true;\n","/**\n * append pushes item to an array and automatically creates a new array when it doesn't exist.\n *\n * @typeparam T Item type.\n * @param array Array.\n * @param item Item to append.\n * @returns Array.\n */\nexport const append = <T>(array: T[] | null, item: T) => array === null ? [item] : (array.push(item), array);\n\n/**\n * unorderedArrayDeleteByIndex deletes item from an array with O(1) complexity.\n *\n * It swaps item at `index` position with the last item and removes the last one.\n *\n * @typeparam T Item type.\n * @param array Array.\n * @param index Index of an item to delete.\n */\nexport function unorderedArrayDeleteByIndex<T>(array: T[], index: number): void {\n  const length = array.length - 1;\n  const last = array.pop();\n  if (index !== length) {\n    array[index] = last!;\n  }\n}\n\n/**\n * unorderedArrayDelete deletes item from an array with O(1) complexity.\n *\n * It swaps item at `index` position with the last item and deletes the last one.\n *\n * @typeparam T Item type.\n * @param array Array.\n * @param item Item to delete.\n */\nexport function unorderedArrayDelete<T>(array: T[], item: T): void {\n  const index = array.indexOf(item);\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    if (index === -1) {\n      throw new Error(`Failed to delete an item from an array, item doesn't exist in the array`);\n    }\n  }\n  unorderedArrayDeleteByIndex(array, index);\n}\n","import { unorderedArrayDeleteByIndex } from \"./array\";\n\n/**\n * RepeatableTaskList is a data structure for tasks that will be repeated until they return `true` value.\n */\nexport type RepeatableTaskList = Array<() => boolean | void>;\n\n/**\n * runRepeatableTasks runs repeatable tasks.\n *\n * @param tasks Repeatable tasks.\n */\nexport function runRepeatableTasks(tasks: RepeatableTaskList): void {\n  for (let i = 0; i < tasks.length; ++i) {\n    if (tasks[i]() === true) {\n      unorderedArrayDeleteByIndex(tasks, i--);\n    }\n  }\n}\n","export const SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nexport const XLINK_NAMESPACE = \"http://www.w3.org/1999/xlink\";\nexport const XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n","import { NodeFlags } from \"./node_flags\";\nimport { Op } from \"./operations\";\n\n/**\n * Operation state.\n *\n * @typeparam T Internal state type.\n */\nexport interface OpState<T = any> {\n  /**\n   * Operation.\n   */\n  o: Op;\n  /**\n   * See {@link NodeFlags} for details.\n   */\n  f: NodeFlags;\n  /**\n   * State for children operations.\n   */\n  c: OpState | Array<OpState | null> | null;\n  /**\n   * Current state.\n   */\n  s: T;\n}\n\n/**\n * createStateNode creates a {@link StateNode} instance.\n *\n * @param op Operation.\n * @returns {@link StateNode} instance.\n */\nexport const createStateNode = (o: Op): OpState => (\n  { o, f: 0, c: null, s: null }\n);\n","import { createOpType, createContainerOp, OpType, ContextOp, Op } from \"./operations\";\nimport { NodeFlags } from \"./node_flags\";\n\n/**\n * Context descriptor.\n */\nexport interface ContextDescriptor<T = any> {\n  /**\n   * Retrieves context value.\n   */\n  get(): T;\n  /**\n   * Creates a context operation.\n   */\n  set(value: T, children: Op): ContextOp<T>;\n}\n\n/**\n * Context state.\n */\nexport interface ContextState<T = any> {\n  /**\n   * Next state.\n   */\n  readonly n: ContextState | null;\n  /**\n   * Descriptor.\n   */\n  readonly d: ContextDescriptor<T>;\n  /**\n   * Context value.\n   */\n  v: T;\n}\n\n/**\n * Current context.\n */\nlet n: ContextState | null = null;\n\n/**\n * Used for detecting invalid `ContextDescriptor()` invocations in DEBUG mode.\n */\nlet contextEnabled = false;\n\n/**\n * Enable checking for invalid `context()` invocations in DEBUG mode.\n */\nexport function enableContext() {\n  contextEnabled = true;\n}\n\n/**\n * Disable checking for invalid `context()` invocations in DEBUG mode.\n */\nexport function disableContext() {\n  contextEnabled = false;\n}\n\n/**\n * Reset current context.\n */\nexport function resetContext() {\n  n = null;\n}\n\n/**\n * pushContext creates a new context state and pushes it to the context stack.\n *\n * @param d Context descriptor.\n * @param v Context value.\n * @returns New {@link ContextState}.\n */\nexport function pushContext<T = any>(d: ContextDescriptor<T>, v: T): ContextState<T> {\n  return n = { n, d, v };\n}\n\n/**\n * getContext retrieves current context.\n *\n * @returns current context.\n */\nexport function getContext(): ContextState | null {\n  return n;\n}\n\n/**\n * setContext assigns current context.\n *\n * Should be executed before going deeper into context node.\n *\n * @param c Current context.\n */\nexport function setContext(c: ContextState | null): ContextState | null {\n  return n = c;\n}\n\n/**\n * contextValue creates a context descriptor.\n *\n * @example\n *\n *     const { set: StoreContext, get: getStore } = contextValue<Store>();\n *     const Component = component((c) => {\n *       const getValue = useSelect(c, () => getStore().value);\n *       return () => getValue();\n *     });\n *     render(\n *       StoreContext(store,\n *         Component(),\n *       ),\n *       container,\n *     );\n *\n * @returns {@link ContextDescriptor}\n */\nexport function contextValue<T = any>(): ContextDescriptor<T> {\n  let type: OpType;\n  const d = {\n    get: (): T | void => {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== \"production\") {\n        if (!contextEnabled) {\n          throw Error(\"Invalid context invocation\");\n        }\n      }\n\n      let next = n;\n      while (next !== null) {\n        if (next.d === d) {\n          return next.v;\n        }\n        next = next.n;\n      }\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== \"production\") {\n        throw Error(\"Unable to find context value\");\n      }\n    },\n    set: (v: T, c: Op) => createContainerOp(type, v, c),\n  };\n  type = createOpType(NodeFlags.Context, d as ContextDescriptor<T>);\n  return d as ContextDescriptor<T>;\n}\n","import { SELECT_TOKEN, UNMOUNT_TOKEN } from \"../core\";\nimport {\n  doc, objectHasOwnProperty,\n  nodeInsertBefore, nodeRemoveChild, elementSetAttribute, nodeCloneNode, nodeSetTextContent, elementRemoveAttribute,\n  elementSetClassName, htmlElementGetStyle, svgElementGetStyle,\n} from \"../dom/shortcuts\";\nimport { SVG_NAMESPACE } from \"../dom/namespaces\";\nimport { CSSStyleProps } from \"../dom/style\";\nimport { NodeFlags } from \"./node_flags\";\nimport { AttributeDirective } from \"./attribute_directive\";\nimport { OpNode, DOMElementOp, EventsOp, ContextOp, TrackByKeyOp, ComponentOp, OpArray, Key, Op } from \"./operations\";\nimport { OpState, createStateNode } from \"./state\";\nimport { ElementProtoDescriptor } from \"./element_proto\";\nimport { ComponentDescriptor, ComponentHooks, StatelessComponentDescriptor } from \"./component\";\nimport { setContext, pushContext, ContextDescriptor, ContextState } from \"./context\";\n\nlet _nextNode!: Node | null;\nlet _deepStateFlags!: NodeFlags;\n\nexport function _resetState(): void {\n  _nextNode = null;\n  _deepStateFlags = 0;\n}\n\nfunction _pushDeepState(): NodeFlags {\n  const s = _deepStateFlags;\n  _deepStateFlags = 0;\n  return s;\n}\n\nconst _popDeepState = (prev: NodeFlags, current: NodeFlags): NodeFlags => (\n  current |= _deepStateFlags,\n  _deepStateFlags |= prev,\n  current\n);\n\n/**\n * VisitNodesDirective controls the traversal algorithm.\n */\nexport const enum VisitNodesDirective {\n  /**\n   * Continue traversing the tree.\n   */\n  Continue = 0,\n  /**\n   * Stops immediately.\n   */\n  StopImmediate = 1,\n  /**\n   * Stops traversing through children nodes.\n   */\n  Stop = 1 << 1,\n}\n\n/**\n * visitNodes traverses the operation state tree and invokes `visitor` function for each state node.\n *\n * @param opState State node.\n * @param visitor Visitor function.\n * @returns {@link VisitNodesFlags}\n */\nexport function visitNodes(opState: OpState, visitor: (opState: OpState) => VisitNodesDirective): VisitNodesDirective;\nexport function visitNodes(\n  opState: OpState | null,\n  visitor: (opState: OpState) => VisitNodesDirective,\n): VisitNodesDirective {\n  let i = visitor(opState!);\n  if (i !== VisitNodesDirective.Continue) {\n    return (i & VisitNodesDirective.StopImmediate);\n  }\n\n  const { f, c } = opState!;\n  if ((f & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n    for (i = 0; i < (c as Array<OpState | null>).length; i++) {\n      if (\n        (opState = (c as Array<OpState | null>)[i]) !== null &&\n        (visitNodes(opState, visitor) & VisitNodesDirective.StopImmediate) !== 0\n      ) {\n        return VisitNodesDirective.StopImmediate;\n      }\n    }\n  } else if (c !== null) {\n    return visitNodes(c as OpState, visitor);\n  }\n  return VisitNodesDirective.Continue;\n}\n\n/**\n * getDOMNode retrieves closest DOM node from the {@link OpState} instance.\n *\n * @param opState State node.\n * @returns DOM node.\n */\nexport function getDOMNode(opState: OpState): Node | null;\nexport function getDOMNode(opState: OpState | Array<OpState | null> | null): Node | null {\n  let i = (opState as OpState).f;\n  let c: OpState | null;\n  if ((i & (NodeFlags.Element | NodeFlags.Text)) === 0) {\n    opState = (opState as OpState).c;\n    if ((i & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n      for (i = 0; i < (opState as Array<OpState | null>).length; i++) {\n        if ((c = (opState as Array<OpState | null>)[i]) !== null) {\n          return getDOMNode(c);\n        }\n      }\n      return null;\n    }\n    if (opState === null) {\n      return null;\n    }\n    return getDOMNode(opState as OpState);\n  }\n  return (opState as OpState).s as Node;\n}\n\nexport function _dirtyCheck(\n  parentElement: Element,\n  opState: OpState,\n  moveNode: boolean,\n  singleChild: boolean,\n): void {\n  const f = opState.f;\n  let state;\n  let deepState;\n  let c;\n  let i;\n\n  if ((f & NodeFlags.Component) !== 0) {\n    state = opState.s as ComponentHooks;\n    c = opState.c as OpState | null;\n    deepState = _pushDeepState();\n    if (\n      ((f & NodeFlags.Stateful) !== 0) && (\n        ((f & NodeFlags.Dirty) !== 0) ||\n        (state.s !== null && state.s(SELECT_TOKEN) === true)\n      )\n    ) {\n      opState.c = _update(\n        parentElement,\n        c,\n        state.r!((opState.o as ComponentOp).v),\n        moveNode,\n        singleChild,\n      );\n    } else if ((f & NodeFlags.DeepStateDirtyCheck) !== 0) {\n      _dirtyCheck(parentElement, c as OpState, moveNode, singleChild);\n    } else {\n      if (moveNode === true) {\n        _moveNodes(parentElement, opState);\n      } else {\n        _nextNode = getDOMNode(opState);\n      }\n    }\n    opState.f = (opState.f & NodeFlags.SelfFlags) | _deepStateFlags;\n    _deepStateFlags |= deepState | ((opState.f & NodeFlags.DeepStateFlags) << NodeFlags.DeepStateShift);\n  } else if ((f & NodeFlags.DeepStateDirtyCheck) !== 0) {\n    // Checking for `children === null` is unnecessary, `DeepStateDirtyCheck` flag guarantees that element should\n    // have children nodes.\n    deepState = _pushDeepState();\n    c = opState.c as OpState | Array<OpState | null>;\n    if ((f & NodeFlags.Element) !== 0) {\n      state = opState.s as Node;\n      if (moveNode === true) {\n        nodeInsertBefore!.call(parentElement, state, _nextNode);\n      }\n      _nextNode = null;\n      _dirtyCheck(state as Element, c as OpState, false, true);\n      _nextNode = state;\n    } else if ((f & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n      i = (c as Array<OpState | null>).length;\n      while (i > 0) {\n        if ((state = (c as Array<OpState | null>)[--i]) !== null) {\n          _dirtyCheck(parentElement, state, moveNode, false);\n        }\n      }\n    } else if ((f & NodeFlags.Events) !== 0) {\n      _dirtyCheck(parentElement, c as OpState, moveNode, singleChild);\n    } else {  // ((f & NodeFlags.Context) !== 0)\n      state = setContext(opState.s);\n      _dirtyCheck(parentElement, c as OpState, moveNode, singleChild);\n      setContext(state);\n    }\n    opState.f = _popDeepState(deepState, opState.f);\n  } else {\n    if (moveNode === true) {\n      _moveNodes(parentElement, opState);\n    } else {\n      _nextNode = getDOMNode(opState);\n    }\n  }\n}\n\nfunction _moveNodes(parentElement: Element, opState: OpState) {\n  const flags = opState.f;\n  let children;\n  let c;\n  let i;\n  if ((flags & (NodeFlags.Element | NodeFlags.Text)) !== 0) {\n    c = opState.s as Node;\n    nodeInsertBefore!.call(parentElement, c, _nextNode);\n    _nextNode = c;\n  } else {\n    children = opState.c;\n    if ((flags & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n      i = (children as Array<OpState | null>).length;\n      while (i > 0) {\n        if ((c = (children as Array<OpState | null>)[--i]) !== null) {\n          _moveNodes(parentElement, c);\n        }\n      }\n    } else if (children !== null) {\n      _moveNodes(parentElement, children as OpState);\n    }\n  }\n}\n\nfunction _unmountWalk(opState: OpState): void {\n  const flags = opState.f;\n  let children;\n  let i;\n  let v;\n\n  if ((flags & NodeFlags.DeepStateUnmount) !== 0) {\n    if ((children = opState.c) !== null) {\n      if ((flags & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n        for (i = 0; i < (children as Array<OpState | null>).length; i++) {\n          if ((v = (children as Array<OpState | null>)[i]) !== null) {\n            _unmountWalk(v);\n          }\n        }\n      } else {\n        _unmountWalk(children as OpState);\n      }\n    }\n  }\n\n  if ((flags & NodeFlags.Unmount) !== 0) {\n    if ((v = (opState.s as ComponentHooks).u) !== null) {\n      if (typeof v === \"function\") {\n        v(UNMOUNT_TOKEN);\n      } else {\n        for (i = 0; i < v.length; i++) {\n          v[i](UNMOUNT_TOKEN);\n        }\n      }\n    }\n  }\n}\n\nfunction _unmountRemove(parentElement: Element, opState: OpState, singleChild: boolean): void;\nfunction _unmountRemove(\n  parentElement: Element,\n  opState: OpState | Array<OpState | null> | null,\n  singleChild: boolean,\n): void {\n  let i = (opState as OpState).f;\n  let c;\n\n  if ((i & (NodeFlags.Element | NodeFlags.Text)) !== 0) {\n    nodeRemoveChild!.call(parentElement, (opState as OpState).s as Node);\n  } else {\n    opState = (opState as OpState).c;\n    if ((i & (NodeFlags.TrackByKey | NodeFlags.Fragment)) !== 0) {\n      if (singleChild === true) {\n        nodeSetTextContent!.call(parentElement, \"\");\n      } else {\n        for (i = 0; i < (opState as Array<OpState | null>).length; ++i) {\n          if ((c = (opState as Array<OpState | null>)[i]) !== null) {\n            _unmountRemove(parentElement, c, false);\n          }\n        }\n      }\n    } else if (opState !== null) {\n      _unmountRemove(parentElement, opState as OpState, singleChild);\n    }\n  }\n}\n\nexport function _unmount(parentElement: Element, opState: OpState, singleChild: boolean): void {\n  _unmountRemove(parentElement, opState, singleChild);\n  _unmountWalk(opState);\n}\n\nfunction _mountText(\n  parentElement: Element,\n  opState: OpState,\n  op: string | number,\n) {\n  const node = doc.createTextNode(op as string);\n  nodeInsertBefore!.call(parentElement, node, _nextNode);\n  _nextNode = node;\n  opState.s = node;\n  opState.f = NodeFlags.Text;\n}\n\nfunction _createElement(node: Element | undefined, op: DOMElementOp): Element {\n  const { t, v, n } = op;\n  const svg = (t.f & NodeFlags.Svg) !== 0;\n  if (node === void 0) {\n    const tagName = t.d as string;\n    node = svg ?\n      doc.createElementNS(SVG_NAMESPACE, tagName) :\n      doc.createElement(tagName);\n  }\n\n  if (n) {\n    _updateClassName(node, n, svg);\n  }\n\n  if (v !== void 0) {\n    _updateAttrs(node, void 0, v, svg);\n  }\n\n  return node;\n}\n\nfunction _mountObject(\n  parentElement: Element,\n  opState: OpState,\n  op: OpNode,\n): void {\n  const opType = op.t;\n  const flags = opType.f;\n  let deepStateFlags;\n  let prevState;\n  let value;\n  let node;\n  let i;\n\n  if ((flags & NodeFlags.Component) !== 0) {\n    deepStateFlags = _pushDeepState();\n    if ((flags & NodeFlags.Stateful) !== 0) {\n      opState.s = prevState = { r: null, s: null, u: null } as ComponentHooks;\n      // Reusing value variable.\n      (prevState as ComponentHooks).r = value = (opType.d as ComponentDescriptor).c(opState);\n    } else {\n      value = (opType.d as StatelessComponentDescriptor).c;\n    }\n    opState.c = _mount(parentElement, value((op as ComponentOp).v));\n    opState.f = (opState.f & NodeFlags.SelfFlags) | flags | _deepStateFlags;\n    _deepStateFlags |= deepStateFlags | ((opState.f & NodeFlags.DeepStateFlags) << NodeFlags.DeepStateShift);\n  } else {\n    deepStateFlags = _pushDeepState();\n    if ((flags & NodeFlags.Element) !== 0) {\n      value = opType.d;\n      if ((flags & NodeFlags.ElementProto) !== 0) {\n        node = (value as ElementProtoDescriptor).n as Element;\n        if (node === null) {\n          (value as ElementProtoDescriptor).n = node = _createElement(\n            void 0,\n            (value as ElementProtoDescriptor).p,\n          );\n        }\n        node = nodeCloneNode!.call(node, false) as Element;\n      }\n      opState.s = node = _createElement(node, op as DOMElementOp);\n\n      prevState = _nextNode;\n      if ((value = (op as DOMElementOp).c) !== null) {\n        _nextNode = null;\n        opState.c = _mount(node, value);\n      }\n      _nextNode = node;\n      nodeInsertBefore!.call(parentElement, node, prevState);\n    } else if ((flags & (NodeFlags.Events | NodeFlags.Context)) !== 0) {\n      if ((flags & NodeFlags.Context) !== 0) {\n        opState.s = prevState = ((flags & NodeFlags.SetContextState) !== 0) ?\n          setContext((op as ContextOp).v) :\n          pushContext(opType.d as ContextDescriptor, (op as ContextOp).v);\n        opState.c = _mount(parentElement, (op as ContextOp).c);\n        setContext(prevState);\n      } else {\n        opState.c = _mount(parentElement, (op as EventsOp).c);\n      }\n    } else { // ((opFlags & NodeFlags.TrackByKey) !== 0)\n      node = (op as TrackByKeyOp).v;\n      i = node.length;\n      opState.c = value = Array(i);\n      while (i > 0) {\n        value[--i] = _mount(parentElement, node[i].v);\n      }\n    }\n    opState.f = _popDeepState(deepStateFlags, flags);\n  }\n}\n\nfunction _mountFragment(\n  parentElement: Element,\n  opState: OpState,\n  childrenOps: OpArray,\n): void {\n  let i = childrenOps.length;\n  const newChildren = Array(i);\n  const deepStateFlags = _pushDeepState();\n  while (i > 0) {\n    newChildren[--i] = _mount(parentElement, childrenOps[i]);\n  }\n  opState.c = newChildren;\n  opState.f = _popDeepState(deepStateFlags, NodeFlags.Fragment);\n}\n\nexport function _mount(\n  parentElement: Element,\n  op: Op,\n): OpState | null {\n  if (op !== null) {\n    const opState = createStateNode(op);\n    if (typeof op === \"object\") {\n      if (op instanceof Array) {\n        _mountFragment(parentElement, opState, op);\n      } else {\n        _mountObject(parentElement, opState, op);\n      }\n    } else {\n      _mountText(parentElement, opState, op);\n    }\n    return opState;\n  }\n  return null;\n}\n\n/**\n * _update updates a stateNode with a next operation.\n *\n * @param parentElement Parent DOM Element.\n * @param opState Operation state.\n * @param nextOp Next operation.\n * @param moveNode DOM Element should be moved.\n * @param singleChild Parent DOM Element contains a single child.\n * @returns OpNode state.\n */\nexport function _update(\n  parentElement: Element,\n  opState: OpState | null,\n  nextOp: Op,\n  moveNode: boolean,\n  singleChild: boolean,\n): OpState | null {\n  if (nextOp === null) {\n    if (opState !== null) {\n      _unmount(parentElement, opState, singleChild);\n    }\n    return null;\n  }\n  if (opState === null) {\n    return _mount(parentElement, nextOp);\n  }\n  const { f, o, s } = opState;\n\n  if ((f & NodeFlags.Text) !== 0) {\n    if (typeof nextOp !== \"object\") {\n      // Reassign to reduce memory consumption even if nextOp is strictly equal to the prev op.\n      opState.o = nextOp;\n      if (o !== nextOp) {\n        (s as Node).nodeValue = nextOp as string;\n      }\n      if (moveNode === true) {\n        nodeInsertBefore!.call(parentElement, s as Node, _nextNode);\n      }\n      _nextNode = s as Node;\n    } else {\n      nodeRemoveChild!.call(parentElement, s as Node);\n      return _mount(parentElement, nextOp);\n    }\n  } else {\n    // Here we don't need to reassign nextOp because op should always be an object, and strict equality will guarantee\n    // that this object is occupying the same memory region.\n    if (o === nextOp) {\n      _dirtyCheck(parentElement, opState, moveNode, singleChild);\n      return opState;\n    }\n    if (\n      ((f & NodeFlags.Fragment) !== 0 ?\n        !(nextOp instanceof Array) :\n        (nextOp instanceof Array || (o as OpNode).t !== (nextOp as OpNode).t)\n      )\n    ) {\n      _unmount(parentElement, opState, singleChild);\n      return _mount(parentElement, nextOp);\n    }\n    opState.o = nextOp;\n    const opStateChildren = opState.c;\n    let deepStateFlags;\n    let prevData;\n    let nextData;\n    let nextValue;\n    let i;\n\n    if ((f & NodeFlags.Component) !== 0) {\n      prevData = (o as ComponentOp).v;\n      nextData = (nextOp as ComponentOp).v;\n      nextValue = (nextOp as ComponentOp).t.d as StatelessComponentDescriptor | ComponentDescriptor;\n      if (\n        ((f & NodeFlags.Dirty) !== 0) ||\n        (\n          (prevData !== nextData) &&\n          (nextValue.e === void 0 || nextValue.e(prevData, nextData) === true)\n        )\n      ) {\n        deepStateFlags = _pushDeepState();\n        opState.c = _update(\n          parentElement,\n          opStateChildren as OpState,\n          ((f & NodeFlags.Stateful) !== 0) ?\n            (s as ComponentHooks).r!(nextData) :\n            (nextValue as StatelessComponentDescriptor).c(nextData),\n          moveNode,\n          singleChild,\n        );\n        // opState.f can be changed after `_update()`.\n        i = opState.f;\n        opState.f = (i & NodeFlags.SelfFlags) | _deepStateFlags;\n        _deepStateFlags |= deepStateFlags | ((i & NodeFlags.DeepStateFlags) << NodeFlags.DeepStateShift);\n      } else {\n        _dirtyCheck(parentElement, opState, moveNode, singleChild);\n      }\n    } else {\n      deepStateFlags = _pushDeepState();\n      if ((f & NodeFlags.Element) !== 0) {\n        i = (f & NodeFlags.Svg) !== 0;\n        if (moveNode === true) {\n          nodeInsertBefore!.call(parentElement, s, _nextNode);\n        }\n\n        nextValue = (nextOp as DOMElementOp).n;\n        if ((o as DOMElementOp).n !== nextValue) {\n          if (nextValue === void 0) {\n            nextValue = \"\";\n          }\n          _updateClassName(s, nextValue, i);\n        }\n\n        nextValue = (nextOp as DOMElementOp).v;\n        if ((o as DOMElementOp).v !== nextValue) {\n          _updateAttrs(s as Element, (o as DOMElementOp).v, nextValue, i);\n        }\n\n        _nextNode = null;\n        opState.c = _update(s as Element, opStateChildren as OpState, (nextOp as DOMElementOp).c, false, true);\n        _nextNode = s as Node;\n      } else if ((f & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n        if ((f & NodeFlags.Fragment) !== 0) {\n          i = (nextOp as OpArray).length;\n          if (i === 0) {\n            _unmount(parentElement, opState, singleChild);\n          } else {\n            prevData = (opStateChildren as Array<OpState | null>).length;\n            if (i !== prevData) {\n              opState.c = nextValue = Array(i);\n              while (prevData > i) {\n                nextData = (opStateChildren as Array<OpState | null>)[--prevData];\n                if (nextData !== null) {\n                  _unmount(parentElement, nextData, false);\n                }\n              }\n              while (i > prevData) {\n                nextValue[--i] = _mount(parentElement, (nextOp as OpArray)[i]);\n              }\n            } else {\n              nextValue = (opStateChildren as Array<OpState | null>);\n            }\n            while (i > 0) {\n              nextValue[--i] = _update(\n                parentElement,\n                (opStateChildren as Array<OpState | null>)[i],\n                (nextOp as OpArray)[i],\n                moveNode,\n                false,\n              );\n            }\n          }\n        } else {\n          _updateChildrenTrackByKeys(\n            parentElement,\n            opState,\n            (o as TrackByKeyOp).v,\n            (nextOp as TrackByKeyOp).v,\n            moveNode,\n            singleChild,\n          );\n        }\n      } else if ((f & NodeFlags.Events) !== 0) {\n        opState.c = _update(\n          parentElement,\n          opStateChildren as OpState,\n          (nextOp as EventsOp).c,\n          moveNode,\n          singleChild,\n        );\n      } else { // if ((flags & NodeFlags.Context) !== 0) {\n        nextData = (nextOp as ContextOp).v;\n        if ((f & NodeFlags.SetContextState) !== 0) {\n          opState.s = nextData;\n        } else {\n          (s as ContextState).v = nextData;\n        }\n        nextValue = setContext(opState.s);\n        opState.c = _update(\n          parentElement,\n          opStateChildren as OpState,\n          (nextOp as ContextOp).c,\n          moveNode,\n          singleChild,\n        );\n        setContext(nextValue);\n      }\n      opState.f = _popDeepState(deepStateFlags, f);\n    }\n  }\n\n  return opState;\n}\n\n/**\n * Update children list with track by key algorithm.\n *\n * High-level overview of the algorithm that is implemented in this function (slightly outdated, but the key ideas are\n * the same).\n *\n * This algorithm finds a minimum[1] number of DOM operations. It works in several steps:\n *\n * 1. Find common suffix and prefix.\n *\n * This optimization technique is searching for nodes with identical keys by simultaneously iterating over nodes in the\n * old children list `A` and new children list `B` from both sides:\n *\n *  A: -> [a b c d] <-\n *  B: -> [a b d] <-\n *\n * Here we can skip nodes \"a\" and \"b\" at the begininng, and node \"d\" at the end.\n *\n *  A: -> [c] <-\n *  B: -> [] <-\n *\n * Here it will check if the size of one of the list is equal to zero. When length of the old children list is zero,\n * it will insert all remaining nodes from the new list, and when length of the new children list is zero, it will\n * remove all remaining nodes from the old list.\n *\n * When algorithm can't find a solution with this simple optimization technique, it will go to the next step of the\n * algorithm. For example:\n *\n *  A: -> [a b c d e f g] <-\n *  B: -> [a c b h f e g] <-\n *\n * Nodes \"a\" and \"g\" at the edges are the same, skipping them.\n *\n *  A: -> [b c d e f] <-\n *  B: -> [c b h f e] <-\n *\n * Here we are stuck, so we need to switch to the next step.\n *\n * 2. Look for removed and inserted nodes, and simultaneously check if one of the nodes is moved.\n *\n * First we create an array `P` with the length of the new children list and assign to each position value `-1`, it has\n * a meaning of a new node that should be inserted. Later we will assign node positions in the old children list to this\n * array.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [. . . . .] // . == -1\n *\n * Then we need to build an index `I` that maps keys with node positions of the remaining nodes from the new children\n * list.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [. . . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 0\n *\n * With this index, we start to iterate over the remaining nodes from the old children list and check if we can find a\n * node with the same key in the index. If we can't find any node, it means that it should be removed, otherwise we\n * assign position of the node in the old children list to the positions array.\n *\n *  A: [b c d e f]\n *      ^\n *  B: [c b h f e]\n *  P: [. 0 . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1, <-\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 1\n *\n * When we assigning positions to the positions array, we also keep a position of the last seen node in the new children\n * list, if the last seen position is larger than current position of the node at the new list, then we are switching\n * `moved` flag to `true`.\n *\n *  A: [b c d e f]\n *        ^\n *  B: [c b h f e]\n *  P: [1 0 . . .] // . == -1\n *  I: {\n *    c: 0, <-\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 1 // last > 0; moved = true\n *\n * The last position `1` is larger than current position of the node at the new list `0`, switching `moved` flag to\n * `true`.\n *\n *  A: [b c d e f]\n *          ^\n *  B: [c b h f e]\n *  P: [1 0 . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  moved = true\n *\n * Node with key \"d\" doesn't exist in the index, removing node.\n *\n *  A: [b c d e f]\n *            ^\n *  B: [c b h f e]\n *  P: [1 0 . . 3] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4, <-\n *  }\n *  moved = true\n *\n * Assign position for `e`.\n *\n *  A: [b c d e f]\n *              ^\n *  B: [c b h f e]\n *  P: [1 0 . 4 3] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3, <-\n *    e: 4,\n *  }\n *  moved = true\n *\n * Assign position for 'f'.\n *\n * At this point we are checking if `moved` flag is on, or if the length of the old children list minus the number of\n * removed nodes isn't equal to the length of the new children list. If any of this conditions is true, then we are\n * going to the next step.\n *\n * 3. Find minimum number of moves if `moved` flag is on, or insert new nodes if the length is changed.\n *\n * When `moved` flag is on, we need to find the\n * [longest increasing subsequence](http://en.wikipedia.org/wiki/Longest_increasing_subsequence) in the positions array,\n * and move all nodes that doesn't belong to this subsequence.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *  moved = true\n *\n * Now we just need to simultaneously iterate over the new children list and LIS from the end and check if the current\n * position is equal to a value from LIS.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *              ^  // new_pos == 4\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *              ^  // new_pos == 4\n *  moved = true\n *\n * Node \"e\" stays at the same place.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *            ^    // new_pos == 3\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *            ^    // new_pos != 1\n *  moved = true\n *\n * Node \"f\" is moved, move it before the next node \"e\".\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *          ^      // new_pos == 2\n *  P: [1 0 . 4 3] // . == -1\n *          ^      // old_pos == -1\n *  LIS:     [1 4]\n *            ^\n *  moved = true\n *\n * Node \"h\" has a `-1` value in the positions array, insert new node \"h\".\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *        ^        // new_pos == 1\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *            ^    // new_pos == 1\n *  moved = true\n *\n * Node \"b\" stays at the same place.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *      ^          // new_pos == 0\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *          ^      // new_pos != undefined\n *  moved = true\n *\n * Node \"c\" is moved, move it before the next node \"b\".\n *\n * When moved flag is off, we don't need to find LIS, and we just iterate over the new children list and check its\n * current position in the positions array, if it is `-1`, then we insert new node.\n *\n * [1] Actually it is almost minimum number of dom ops, when node is removed and another one is inserted at the same\n * place, instead of insert and remove dom ops, we can use one replace op. It will make everything even more\n * complicated, and other use cases will be slower, so I don't think that it is worth to use replace here.\n *\n * @param parentElement Parent DOM element.\n * @param opState OpNode state for a TrackByKey operation.\n * @param a Previous operations.\n * @param b Next operations.\n * @param moveNode Children DOM nodes should be moved.\n * @param singleChild Parent DOM element contains a single node.\n * @noinline\n */\nfunction _updateChildrenTrackByKeys(\n  parentElement: Element,\n  opState: OpState,\n  a: Key<any, OpNode>[],\n  b: Key<any, OpNode>[],\n  moveNode: boolean,\n  singleChild: boolean,\n): void {\n  let i = b.length;\n  let j: number | undefined = a.length;\n  const result = Array(i);\n\n  if (i === 0) { // New children list is empty.\n    if (j > 0) { // Unmount nodes from the old children list.\n      _unmount(parentElement, opState, singleChild);\n    }\n  } else if (j === 0) { // Old children list is empty.\n    while (i > 0) { // Mount nodes from the new children list.\n      result[--i] = _mount(parentElement, b[i].v);\n    }\n  } else {\n    const opStateChildren = opState.c as Array<OpState | null>;\n    let aEnd = j - 1; // a.length - 1\n    let bEnd = i - 1; // b.length - 1\n    let start = 0;\n    let node: OpNode | Key<any, OpNode> | OpState | null = b[bEnd];\n\n    // Step 1\n    outer: while (true) {\n      // Update nodes with the same key at the end.\n      while (a[aEnd].k === node.k) {\n        result[bEnd] = _update(parentElement, opStateChildren[aEnd--], node.v, moveNode, false);\n        if (start > --bEnd || start > aEnd) {\n          break outer;\n        }\n        node = b[bEnd];\n      }\n\n      // Update nodes with the same key at the beginning.\n      while (a[start].k === b[start].k && ++start <= aEnd && start <= bEnd) {\n        // delayed update (all updates should be performed from right-to-left).\n      }\n\n      break;\n    }\n\n    if (start > aEnd) {\n      // All nodes from `a` are updated, insert the rest from `b`.\n      while (bEnd >= start) {\n        result[bEnd] = _mount(parentElement, b[bEnd--].v);\n      }\n    } else if (start > bEnd) {\n      // All nodes from `b` are updated, remove the rest from `a`.\n      i = start;\n      do {\n        if ((node = opStateChildren[i++]) !== null) {\n          _unmount(parentElement, node, false);\n        }\n      } while (i <= aEnd);\n    } else { // Step 2\n      // When `pos === 99999999`, it means that one of the nodes is in the wrong position and we should rearrange nodes\n      // with lis-based algorithm.\n      let pos = 0;\n      // Number of updated nodes after prefix/suffix phase. It is used for an optimization that removes all child nodes\n      // with `textContent=\"\"` when there are no updated nodes.\n      let updated = 0;\n\n      const aLength = aEnd - start + 1;\n      const bLength = bEnd - start + 1;\n      const sources = Array(bLength); // Maps positions in the new children list to positions in the old children list.\n      const keyIndex = new Map<any, number>(); // Maps keys to their positions in the new children list.\n      for (i = 0; i < bLength; ++i) {\n        j = i + start;\n        sources[i] = -1; // Special value `-1` indicates that node doesn't exist in the old children list.\n        keyIndex.set(b[j].k, j);\n      }\n\n      for (i = start; i <= aEnd && updated < bLength; ++i) {\n        j = keyIndex.get(a[i].k);\n        if (j !== void 0) {\n          pos = (pos < j) ? j : 99999999;\n          ++updated;\n          sources[j - start] = i;\n          result[j] = opStateChildren[i];\n          // remove updated nodes from previous array, so that we could remove the rest from the document.\n          opStateChildren[i] = null;\n        }\n      }\n\n      if (aLength === a.length && updated === 0) {\n        // Zero updated nodes in step 1 and 2, remove all nodes and insert new ones.\n        _unmount(parentElement, opState, singleChild);\n        while (bEnd >= 0) {\n          result[bEnd] = _mount(parentElement, b[bEnd--].v);\n        }\n      } else {\n        // Step 3\n        // Remove nodes that weren't updated in the old children list.\n        for (i = start; i <= aEnd; i++) {\n          if ((node = opStateChildren[i]) !== null) {\n            _unmount(parentElement, node, false);\n          }\n        }\n\n        i = bLength;\n        if (moveNode === true || pos !== 99999999) {\n          while (i > 0) {\n            pos = --i + start;\n            node = b[pos].v;\n            result[pos] = (sources[i] === -1) ?\n              _mount(parentElement, node) :\n              _update(parentElement, result[pos], node, moveNode, false);\n          }\n        } else {\n          const seq = lis(sources);\n          j = seq.length - 1;\n          while (i > 0) {\n            pos = --i + start;\n            node = b[pos].v;\n            if (sources[i] === -1) {\n              result[pos] = _mount(parentElement, node);\n            } else {\n              if (j < 0 || i !== seq[j]) {\n                moveNode = true;\n              } else {\n                --j;\n              }\n              result[pos] = _update(parentElement, result[pos], node, moveNode, false);\n              moveNode = false;\n            }\n          }\n        }\n      }\n    }\n\n    // update nodes from Step 1 (prefix only)\n    while (start > 0) {\n      result[--start] = _update(parentElement, opStateChildren[start], b[start].v, moveNode, false);\n    }\n  }\n  opState.c = result;\n}\n\n/**\n * Slightly modified Longest Increased Subsequence algorithm, it ignores items that have -1 value, they're representing\n * new items.\n *\n * {@link http://en.wikipedia.org/wiki/Longest_increasing_subsequence}\n *\n * It is possible to use typed arrays in this function, and it will make it faster in most javascript engines, but for\n * some reason instantiating small typed arrays is slower in synthetic microbenchmarks on V8\n * {@link https://gist.github.com/localvoid/88da772d987794605f7fa4a078bce4d6} (maybe there is something wrong in this\n * benchmarks, if someone want to spend more time on optimizations, I'd recommend to double check everything).\n *\n * To solve problem with instantiation, we could just reuse arrays, but in my opinion it isn't worth to overcomplicate\n * this algorithm since it is already extremely fast and it is highly unlikely that it will be even noticeable in the\n * profiler. Usually when there is an update in the real applications, it triggers reordering of one dynamic children\n * list, that is why I prefer to keep it simple.\n *\n * @param a - Array of numbers\n * @returns Longest increasing subsequence\n * @noinline\n */\nfunction lis(a: number[]): number[] {\n  const p = a.slice();\n  // result is instantiated as an empty array to prevent instantiation with CoW backing store.\n  const result: number[] = [];\n  let n = 0;\n  let i = 0;\n  let u: number;\n  let v: number;\n  let j: number;\n\n  result[0] = 0;\n  for (; i < a.length; ++i) {\n    const k = a[i];\n    if (k > -1) {\n      j = result[n];\n      if (a[j] < k) {\n        p[i] = j;\n        result[++n] = i;\n      } else {\n        u = 0;\n        v = n;\n\n        while (u < v) {\n          j = (u + v) >> 1;\n          if (a[result[j]] < k) {\n            u = j + 1;\n          } else {\n            v = j;\n          }\n        }\n\n        if (k < a[result[u]]) {\n          if (u > 0) {\n            p[i] = result[u - 1];\n          }\n          result[u] = i;\n        }\n      }\n    }\n  }\n\n  v = result[n];\n\n  while (n >= 0) {\n    result[n--] = v;\n    v = p[v];\n  }\n\n  return result;\n}\n\n/**\n * Update DOM classname.\n *\n * @param element DOM Element.\n * @param className Class name.\n * @param svg SVG Element.\n */\nfunction _updateClassName(element: Element, className: string, svg: boolean): void {\n  /**\n   * SVGElement.className returns `SVGAnimatedString`.\n   *\n   * #quirks\n   */\n  if (svg === true) {\n    elementSetAttribute!.call(element, \"class\", className);\n  } else {\n    elementSetClassName!.call((element as HTMLElement), className);\n  }\n}\n\n/**\n * Update DOM styles.\n *\n * @param element HTML or SVG Element.\n * @param a Prev styles.\n * @param b Next styles.\n */\nfunction _updateStyle(\n  element: HTMLElement | SVGElement,\n  a: CSSStyleProps | undefined,\n  b: CSSStyleProps | undefined,\n  svg: boolean,\n): void {\n  const style = svg === true ? svgElementGetStyle!.call(element) : htmlElementGetStyle!.call(element);\n  let key: string;\n  let bValue;\n\n  if (a === void 0) {\n    // a is empty, insert all styles from b.\n    for (key in b!) {\n      bValue = (b as { [key: string]: string })[key];\n      if (bValue !== void 0) {\n        style.setProperty(key, bValue);\n      }\n    }\n  } else if (b === void 0) {\n    // b is empty, remove all styles from a\n    for (key in a) {\n      if ((a as { [key: string]: string })[key] !== void 0) {\n        style.removeProperty(key);\n      }\n    }\n  } else {\n    let matchCount = 0;\n    let i = 0;\n    for (key in a) {\n      const aValue = a[key];\n      bValue = (objectHasOwnProperty.call(b, key) === true) ? (matchCount++ , b[key]) : void 0;\n      if (aValue !== bValue) {\n        if (bValue !== void 0) {\n          style.setProperty(key, bValue);\n        } else {\n          style.removeProperty(key);\n        }\n      }\n    }\n\n    const keys = Object.keys(b);\n    for (; matchCount < keys.length && i < keys.length; ++i) {\n      key = keys[i];\n      if (objectHasOwnProperty.call(a, key) === false) {\n        bValue = b[key];\n        ++matchCount;\n        if (bValue !== void 0) {\n          style.setProperty(key, b[key]);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Update DOM attributes.\n *\n * @param element DOM element.\n * @param a Prev DOM attributes.\n * @param b Next DOM attributes.\n */\nfunction _updateAttrs(\n  element: Element,\n  a: { [key: string]: string | number | boolean | AttributeDirective<any> | CSSStyleProps | undefined } | undefined,\n  b: { [key: string]: string | number | boolean | AttributeDirective<any> | CSSStyleProps | undefined } | undefined,\n  svg: boolean,\n): void {\n  let key: string;\n\n  if (a === void 0) {\n    // a is empty, insert all attributes from b.\n    for (key in b!) {\n      _updateAttr(element, key, void 0, b![key], svg);\n    }\n  } else if (b === void 0) {\n    // b is empty, remove all attributes from a.\n    for (key in a) {\n      _updateAttr(element, key, a[key], void 0, svg);\n    }\n  } else {\n    let matchCount = 0;\n    let i = 0;\n    for (key in a) {\n      _updateAttr(\n        element,\n        key,\n        a[key],\n        (objectHasOwnProperty.call(b, key) === true) ? (matchCount++ , b[key]) : void 0,\n        svg,\n      );\n    }\n\n    const keys = Object.keys(b);\n    for (; matchCount < keys.length && i < keys.length; ++i) {\n      key = keys[i];\n      if (objectHasOwnProperty.call(a, key) === false) {\n        _updateAttr(element, key, void 0, b[key], svg);\n        ++matchCount;\n      }\n    }\n  }\n}\n\n/**\n * Update DOM attribute.\n *\n * @param element DOM Element.\n * @param key Attribute name.\n * @param prev Previous value.\n * @param next Next value.\n */\nfunction _updateAttr(\n  element: Element,\n  key: string,\n  prev: string | number | boolean | AttributeDirective<any> | CSSStyleProps | undefined,\n  next: string | number | boolean | AttributeDirective<any> | CSSStyleProps | undefined,\n  svg: boolean,\n): void {\n  if (key !== \"style\") {\n    if (typeof next === \"object\") {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== \"production\") {\n        if (typeof prev !== \"object\" && prev !== void 0) {\n          throw new Error(\n            `Invalid DOM attribute, transitioning from basic values to attribute directives isn't allowed`,\n          );\n        }\n      }\n      (next as AttributeDirective<any>).u!(\n        element,\n        key,\n        prev === void 0 ? void 0 : (prev as AttributeDirective<any>).v,\n        next.v,\n      );\n    } else if (typeof prev === \"object\") {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== \"production\") {\n        if (typeof next !== \"object\" && next !== void 0) {\n          throw new Error(\n            `Invalid DOM attribute, transitioning from attribute directives to basic values isn't allowed`,\n          );\n        }\n      }\n      (prev as AttributeDirective<any>).u!(\n        element,\n        key,\n        (prev as AttributeDirective<any>).v,\n        void 0,\n      );\n    } else if (prev !== next) {\n      if (typeof next === \"boolean\") {\n        next = next ? \"\" : void 0;\n      }\n      if (next === void 0) {\n        if (prev !== void 0 && prev !== false) {\n          elementRemoveAttribute!.call(element, key);\n        }\n      } else {\n        elementSetAttribute!.call(element, key, next as string);\n      }\n    }\n  } else if (prev !== next) {\n    _updateStyle(element as HTMLElement, prev as CSSStyleProps, next as CSSStyleProps, svg);\n  }\n}\n","import { Op } from \"./operations\";\nimport { OpState } from \"./state\";\nimport { _mount, _update, _unmount, _dirtyCheck, _resetState } from \"./reconciler\";\nimport { enableContext, disableContext } from \"./context\";\n\n/**\n * Root.\n */\nexport interface Root {\n  /**\n   * Container element.\n   */\n  container: Element | null;\n  /**\n   * Current state.\n   */\n  state: OpState | null;\n  /**\n   * Next operation.\n   */\n  next: Op | undefined;\n}\n\n/**\n * Root nodes.\n */\nexport const ROOTS = [] as Root[];\n\n/**\n * Find root node of a container.\n *\n * @param predicate - Find predicate.\n * @returns root node or undefined when root node doesn't exist.\n */\nexport const findRoot = (predicate: (root: Root) => boolean) => ROOTS.find(predicate);\n\n/**\n * Performs a dirty checking.\n */\nexport function dirtyCheck() {\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    enableContext();\n  }\n  for (let i = 0; i < ROOTS.length; ++i) {\n    const root = ROOTS[i];\n    const { container, state, next } = root;\n    _resetState();\n    if (next !== void 0) {\n      root.next = void 0;\n      root.state = _update(container!, state, next, false, true);\n    } else if (state !== null) {\n      _dirtyCheck(container!, state, false, true);\n    }\n  }\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    disableContext();\n  }\n}\n","import { NOOP, catchError, runRepeatableTasks, RepeatableTaskList, box, Box, TaskToken, TASK_TOKEN } from \"../core\";\nimport { printWarn } from \"../debug/print\";\nimport { doc } from \"../dom/shortcuts\";\nimport { NodeFlags } from \"../vdom/node_flags\";\nimport { Op } from \"../vdom/operations\";\nimport { Component } from \"../vdom/component\";\nimport { ROOTS, findRoot, dirtyCheck } from \"../vdom/root\";\n\n/**\n * Update flags.\n */\nexport const enum UpdateFlags {\n  /**\n   * Forces synchronous update.\n   */\n  RequestSyncUpdate = 1,\n}\n\n/**\n * Scheduler flags.\n */\nconst enum SchedulerFlags {\n  /**\n   * Running inside of a scheduler context.\n   */\n  Running = 1,\n  /**\n   * Scheduler tick is pending for an execution.\n   */\n  TickPending = 1 << 1,\n  /**\n   * Frame update is pending for an execution.\n   */\n  NextFramePending = 1 << 2,\n  /**\n   * Sync Frame update is pending for an execution.\n   */\n  NextSyncFramePending = 1 << 3,\n  /**\n   * Running inside of a frame update context.\n   */\n  UpdatingFrame = 1 << 4,\n  /**\n   * Dirty checking is pending for an execution.\n   */\n  DirtyCheckPending = 1 << 5,\n}\n\nconst enum SchedulerDebugFlags {\n  DirtyCheckingFinished = 1,\n  MutationsFinished = 1 << 1,\n  LayoutFinished = 1 << 2,\n}\n\n/**\n * Task list.\n */\ntype TaskList = Box<Array<(token: TaskToken) => void>>;\n\n/**\n * Execute tasks from the `TaskList`.\n *\n * @param t - Task list\n */\nfunction run(t: TaskList) {\n  while (t.v.length > 0) {\n    const tasks = t.v;\n    t.v = [];\n    for (let i = 0; i < tasks.length; ++i) {\n      tasks[i](TASK_TOKEN);\n    }\n  }\n}\n\nlet _flags: SchedulerFlags = 0;\nlet _debugFlags: SchedulerDebugFlags = 0;\n\nlet _frameStartTime = 0;\nlet _clock = 1;\nconst _resolvedPromise = Promise.resolve();\nconst _microtasks = box<Array<(token: TaskToken) => void>>([]);\nconst _mutationEffects = box<Array<(token: TaskToken) => void>>([]);\nconst _layoutEffects = box<Array<(token: TaskToken) => void>>([]);\nconst _beforeMutations = [] as RepeatableTaskList;\nconst _afterMutations = [] as RepeatableTaskList;\n\n/**\n * withSchedulerTick wraps `inner` function into a scheduler context execution.\n *\n * @typeparam T Arguments.\n * @param inner Inner function.\n * @returns function that will be executed in a scheduler context.\n */\nexport const withSchedulerTick = <T extends any[]>(inner: (...args: T) => void) => (\n  catchError(function () {\n    _flags |= SchedulerFlags.Running;\n    inner.apply(void 0, arguments as unknown as T);\n    run(_microtasks);\n    _flags &= ~(SchedulerFlags.Running | SchedulerFlags.TickPending);\n    ++_clock;\n  })\n) as (...args: T) => void;\n\nconst runMicrotasks = withSchedulerTick(NOOP);\n\n/**\n * clock returns monotonically increasing clock value.\n *\n * @returns current clock value.\n */\nexport const clock = () => _clock;\n\n/**\n * scheduleMicrotask adds task to the microtask queue.\n *\n * @param task Microtask.\n */\nexport function scheduleMicrotask(task: (token: TaskToken) => void): void {\n  _microtasks.v.push(task);\n  if ((_flags & (SchedulerFlags.Running | SchedulerFlags.TickPending)) === 0) {\n    _flags |= SchedulerFlags.TickPending;\n    _resolvedPromise.then(runMicrotasks);\n  }\n}\n\n/**\n * beforeMutations adds a hook that will be executed before DOM mutations.\n *\n * @param fn Hook function.\n */\nexport function beforeMutations(fn: () => boolean | void): void {\n  _beforeMutations.push(fn);\n}\n\n/**\n * afterMutations adds a hook that will be executed after DOM mutations.\n *\n * @param fn Hook function.\n */\nexport function afterMutations(fn: () => boolean | void): void {\n  _afterMutations.push(fn);\n}\n\n/**\n * frameStartTime returns current frame start time.\n *\n * @returns current frame start time.\n */\nexport const frameStartTime = () => _frameStartTime;\n\n/**\n * withNextFrame wraps `inner` function into a scheduler frame update context.\n *\n * @param inner Inner function.\n * @returns function that will be executed in a frame update context.\n */\nexport const withNextFrame = (inner: (time?: number) => void) => (\n  withSchedulerTick((time?: number) => {\n    _flags |= SchedulerFlags.UpdatingFrame;\n    inner(time);\n\n    if ((_flags & SchedulerFlags.NextFramePending) !== 0) {\n      if (time !== void 0) {\n        _frameStartTime = time;\n      }\n\n      runRepeatableTasks(_beforeMutations);\n      if ((_flags & SchedulerFlags.DirtyCheckPending) !== 0) {\n        dirtyCheck();\n      }\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== \"production\") {\n        _debugFlags |= SchedulerDebugFlags.DirtyCheckingFinished;\n      }\n      run(_mutationEffects);\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== \"production\") {\n        _debugFlags |= SchedulerDebugFlags.MutationsFinished;\n      }\n      runRepeatableTasks(_afterMutations);\n      run(_layoutEffects);\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== \"production\") {\n        _debugFlags |= SchedulerDebugFlags.LayoutFinished;\n      }\n    }\n    _flags &= ~(\n      SchedulerFlags.UpdatingFrame |\n      SchedulerFlags.NextFramePending |\n      SchedulerFlags.NextSyncFramePending |\n      SchedulerFlags.DirtyCheckPending\n    );\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== \"production\") {\n      _debugFlags &= ~(\n        SchedulerDebugFlags.DirtyCheckingFinished |\n        SchedulerDebugFlags.MutationsFinished |\n        SchedulerDebugFlags.LayoutFinished\n      );\n    }\n  })\n);\n\n/**\n * Frame tasks scheduler event handler.\n *\n * @param t Current time.\n */\nconst _handleNextFrame = withNextFrame(NOOP);\nconst _handleNextFrameSync = () => { _handleNextFrame(); };\n\n/**\n * requestNextFrame requests an update for next frame.\n *\n * @param flags See {@link UpdateFlags} for details.\n */\nexport function requestNextFrame(flags?: UpdateFlags): void {\n  if (\n    (flags !== void 0) &&\n    ((flags & UpdateFlags.RequestSyncUpdate) !== 0) &&\n    ((_flags & SchedulerFlags.NextSyncFramePending) === 0)\n  ) {\n    _flags |= SchedulerFlags.NextFramePending | SchedulerFlags.NextSyncFramePending;\n    if ((_flags & SchedulerFlags.UpdatingFrame) === 0) {\n      scheduleMicrotask(_handleNextFrameSync);\n    }\n  } else if ((_flags & SchedulerFlags.NextFramePending) === 0) {\n    _flags |= SchedulerFlags.NextFramePending;\n    if ((_flags & SchedulerFlags.UpdatingFrame) === 0) {\n      requestAnimationFrame(_handleNextFrame);\n    }\n  }\n}\n\n/**\n * Adds a write DOM task to the queue.\n *\n * @param fn Write DOM task.\n * @param flags See {@link UpdateFlags} for details.\n */\nexport function scheduleMutationEffect(fn: (token: TaskToken) => void, flags?: UpdateFlags): void {\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    if (_flags & SchedulerFlags.UpdatingFrame) {\n      if (_debugFlags & SchedulerDebugFlags.MutationsFinished) {\n        printWarn(\"Mutation effect is scheduled after mutations were finished\");\n      }\n    }\n  }\n  _mutationEffects.v.push(fn);\n  requestNextFrame(flags);\n}\n\n/**\n * Adds a DOM layout task to the queue.\n *\n * @param fn Read DOM task\n * @param flags See {@link UpdateFlags} for details.\n */\nexport function scheduleLayoutEffect(fn: (token: TaskToken) => void, flags?: UpdateFlags): void {\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    if (_flags & SchedulerFlags.UpdatingFrame) {\n      if (_debugFlags & SchedulerDebugFlags.MutationsFinished) {\n        printWarn(\"Layout effect is scheduled after layout were finished\");\n      }\n    }\n  }\n  _layoutEffects.v.push(fn);\n  requestNextFrame(flags);\n}\n\n/**\n * Request dirty checking.\n *\n * @param flags See {@link UpdateFlags} for details.\n */\nexport function requestDirtyCheck(flags?: UpdateFlags): void {\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    if (_flags & SchedulerFlags.UpdatingFrame) {\n      if (_debugFlags & SchedulerDebugFlags.MutationsFinished) {\n        printWarn(\"Dirty checking is scheduled after dirty checking were finished\");\n      }\n    }\n  }\n  _flags |= SchedulerFlags.DirtyCheckPending;\n  requestNextFrame(flags);\n}\n\n/**\n * Invalidate component.\n *\n * @param c Component instance.\n * @param flags See {@link UpdateFlags} for details.\n */\nexport function invalidate(c: Component, flags?: UpdateFlags): void {\n  c.f |= NodeFlags.Dirty;\n  requestDirtyCheck(flags);\n}\n\n/**\n * dirty requests a dirty checking and returns current monotonic clock value.\n *\n * @param flags See {@link UpdateFlags} for details.\n * @returns current monotonic clock value.\n */\nexport const dirty = (flags?: UpdateFlags) => (requestDirtyCheck(flags), _clock);\n\n/**\n * Render operation into the container.\n *\n * @param next Operation to render.\n * @param container DOM Node that will contain rendered operation.\n * @param flags See {@link UpdateFlags} for details.\n */\nexport function render(next: Op, container: Element, flags?: UpdateFlags): void {\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    /**\n     * Rendering into the <body> element is disabled to make it possible to fix iOS quirk with click events.\n     */\n    if (container === doc.body) {\n      throw new Error(\"Rendering into the <body> element aren't allowed\");\n    }\n    if (!doc.body.contains(container)) {\n      throw new Error(\"Container element should be attached to the document\");\n    }\n  }\n\n  const root = findRoot((v) => v.container === container);\n  if (root) {\n    root.next = next;\n  } else {\n    ROOTS.push({ container, state: null, next });\n  }\n\n  requestDirtyCheck(flags);\n}\n","import { NodeFlags } from \"../vdom/node_flags\";\nimport { OpState } from \"../vdom/state\";\nimport { findRoot } from \"../vdom/root\";\nimport { EventsOp } from \"../vdom/operations\";\nimport { EventHandlerFlags, EventHandler, EventHandlerNode } from \"./event_handler\";\n\n/**\n * DispatchTarget.\n */\nexport interface DispatchTarget<H = any> {\n  /**\n   * Target.\n   */\n  readonly t: any;\n  /**\n   * Matched Event Handlers.\n   */\n  readonly h: EventHandlerNode<H>;\n}\n\n/**\n * collectDispatchTargets traverses the DOM tree from the `target` Element to the root element, then goes down\n * through Virtual DOM tree and collects matching Event Handlers.\n *\n * @param result Accumulated Dispatch Targets.\n * @param target Target DOM Element.\n * @param match Matching event source.\n * @returns Dispatch targets.\n */\nfunction collectDispatchTargets(target: Element, match: {}): DispatchTarget[] {\n  const targets = [] as DispatchTarget[];\n  const root = findRoot((r) => r.container!.contains(target));\n  if (root) {\n    const container = root.container;\n    if (container !== target) {\n      visitUp(targets, match, target, container!, root.state);\n    }\n  }\n\n  return targets;\n}\n\nfunction visitUp(\n  result: DispatchTarget[],\n  match: {},\n  element: Element,\n  root: Element,\n  stateNode: OpState | null,\n): OpState | null {\n  const parentElement = element.parentNode! as Element;\n  return (parentElement === root || (stateNode = visitUp(result, match, parentElement, root, stateNode)) !== null) ?\n    visitDown(result, match, element, stateNode!) :\n    null;\n}\n\nfunction visitDown(result: DispatchTarget[], match: {}, element: Element, stateNode: OpState | null): OpState | null {\n  if (stateNode !== null) {\n    const { f, c } = stateNode;\n    let r;\n    if ((f & NodeFlags.Element) !== 0) {\n      if (stateNode.s === element) {\n        return stateNode;\n      }\n      if (c !== null) {\n        return visitDown(result, match, element, c as OpState);\n      }\n    } else if ((f & (NodeFlags.Events | NodeFlags.Component | NodeFlags.Context)) !== 0) {\n      if ((r = visitDown(result, match, element, stateNode.c as OpState)) !== null) {\n        if ((f & NodeFlags.Events) !== 0) {\n          collectDispatchTargetsFromEventsOpState(result, stateNode, (stateNode.o as EventsOp).v, match);\n        }\n        return r;\n      }\n    } else if ((f & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n      for (let i = 0; i < (c as OpState[]).length; i++) {\n        if ((r = visitDown(result, match, element, (c as OpState[])[i])) !== null) {\n          return r;\n        }\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * collectDispatchTargetsFromEventsOpState accumulates matching Event Handlers in `result` array from the `target`\n * operation state.\n *\n * @param result Accumulated Dispatch Targets.\n * @param t Target operation state.\n * @param h Event handler.\n * @param match Matching function.\n */\nfunction collectDispatchTargetsFromEventsOpState(\n  result: DispatchTarget[],\n  t: OpState,\n  h: EventHandler,\n  match: {},\n): void {\n  if (h !== null) {\n    if (h instanceof Array) {\n      let i = h.length;\n      while (--i >= 0) {\n        collectDispatchTargetsFromEventsOpState(result, t, h[i], match);\n      }\n    } else {\n      const source = h.d.s;\n      if (\n        (typeof source === \"function\" && source(match) === true) ||\n        (source === match)\n      ) {\n        result.push({ t, h });\n      }\n    }\n  }\n}\n\n/**\n * dispatchEvent dispatches event to the list of dispatch targets.\n *\n * Simplified version of w3 Events flow algorithm. This algorithm doesn't include target phase, only capture and\n * bubbling phases. We don't care too much about w3 events compatibility, and there aren't any use cases that require\n * target phase.\n *\n * https://www.w3.org/TR/DOM-Level-3-Events/#event-flow\n *\n * @param src Event source.\n * @param targets Dispatch targets.\n * @param event Event to dispatch.\n * @param bubble Use bubbling phase.\n * @param dispatch Dispatch handler.\n */\nexport function dispatchEvent<E>(\n  src: {},\n  target: Element,\n  event: E,\n): void {\n  const targets = collectDispatchTargets(target, src);\n  let i = targets.length;\n  let currentTarget;\n  let descriptor;\n\n  if (i > 0) {\n    // capture phase\n    while (--i >= 0) {\n      currentTarget = targets[i];\n      descriptor = currentTarget.h.d;\n      if ((descriptor.f & EventHandlerFlags.Capture) !== 0) {\n        if (descriptor.h(event, currentTarget, src) === true) {\n          return;\n        }\n      }\n    }\n\n    // bubble phase\n    while (++i < targets.length) {\n      currentTarget = targets[i];\n      descriptor = currentTarget.h.d;\n      if ((descriptor.f & EventHandlerFlags.Capture) === 0) {\n        if (descriptor.h(event, currentTarget, src) === true) {\n          return;\n        }\n      }\n    }\n  }\n}\n","/**\n * Feature Detection is used to implement polyfills or just disable some features when browser doesn't support them.\n * For example, when browser doesn't support passive events, we can just ignore it and always use active events.\n */\n\n/* istanbul ignore next */\n/**\n * Passive event listeners are a new feature in the DOM spec that enable developers to opt-in to better scroll\n * performance by eliminating the need for scrolling to block on touch and wheel event listeners. Developers can\n * annotate touch and wheel listeners with {passive: true} to indicate that they will never invoke preventDefault.\n *\n * https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nexport const PASSIVE_EVENTS = (\n  (process.env.IVI_TARGET === \"ssr\") ? false :\n    (process.env.IVI_TARGET === \"electron\") ? true :\n  /*#__PURE__*/(() => {\n        let v = false;\n        try {\n          // Test via a getter in the options object to see if the passive property is accessed\n          window.addEventListener(\"_\", null as any, {\n            get passive(): boolean {\n              return v = true;\n            }\n          });\n        } catch (e) {\n          // ignore\n        }\n        return v;\n      })()\n);\n\n/* istanbul ignore next */\n/**\n * `key` property is available on KeyboardEvent instances.\n */\nexport const KEYBOARD_EVENT_KEY = (\n  (process.env.IVI_TARGET !== \"ssr\") && (\n    (process.env.IVI_TARGET === \"electron\") ||\n    (process.env.IVI_TARGET === \"evergreen\") ||\n    /*#__PURE__*/KeyboardEvent.prototype.hasOwnProperty(\"key\")\n  )\n);\n\n/* istanbul ignore next */\n/**\n * `buttons` property is available on MouseEvent instances.\n */\nexport const MOUSE_EVENT_BUTTONS = (\n  (process.env.IVI_TARGET !== \"ssr\") && (\n    (process.env.IVI_TARGET === \"electron\") ||\n    (process.env.IVI_TARGET === \"evergreen\") ||\n    /*#__PURE__*/MouseEvent.prototype.hasOwnProperty(\"buttons\")\n  )\n);\n\n/* istanbul ignore next */\n/**\n * Touch Events support.\n */\nexport const TOUCH_EVENTS = (\n  (process.env.IVI_TARGET !== \"ssr\") &&\n  (\"ontouchstart\" in window)\n);\n\n/* istanbul ignore next */\n/**\n * Pointer Events support.\n */\nexport const POINTER_EVENTS = (\n  (process.env.IVI_TARGET !== \"ssr\") && (\n    (process.env.IVI_TARGET === \"electron\") ||\n    (\"PointerEvent\" in window)\n  )\n);\n\n/* istanbul ignore next */\n/**\n * iOS proprietary GestureEvent.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/GestureEvent}\n */\nexport const IOS_GESTURE_EVENT = (\n  (process.env.IVI_TARGET === \"browser\") &&\n  (\"GestureEvent\" in window)\n);\n\n/* istanbul ignore next */\n/**\n * InputDeviceCapabilities support.\n *\n * http://wicg.github.io/InputDeviceCapabilities/\n */\nexport const INPUT_DEVICE_CAPABILITIES = (\n  (process.env.IVI_TARGET !== \"ssr\") && (\n    (process.env.IVI_TARGET === \"electron\") ||\n    (\"InputDeviceCapabilities\" in window)\n  )\n);\n","import { PASSIVE_EVENTS } from \"../dom/feature_detection\";\n\n/* istanbul ignore next */\n/**\n * getEventTarget retrieves target element from an event.\n *\n * There are still some differences in modern browsers, so we need to use this function to retrieve event targets.\n *\n * #quirks\n *\n * @param ev Event.\n * @returns Target Element.\n */\nexport function getEventTarget(ev: Event): EventTarget {\n  let target = ev.target || window;\n\n  /**\n   * Some browsers are implementing it according to SVG 1.1 specs:\n   *\n   * https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7998724/\n   *\n   * \"If event attributes are assigned to referenced elements, then the actual target for the event will be the\n   * SVGElementInstance object within the 'instance tree' corresponding to the given referenced element.\"\n   *\n   * https://www.w3.org/TR/SVG/struct.html#UseElement\n   *\n   * SVG 2 redefined the use event handling model:\n   *\n   * - Removed the SVGElementInstance and SVGElementInstanceList interfaces, and the corresponding attributes on the\n   *   SVGUseElement interface.\n   * - Changed the use element event flow to follow the Shadow DOM spec.\n   *\n   * https://www.w3.org/TR/SVG2/changes.html#structure\n   */\n  if ((target as any).correspondingUseElement !== void 0) {\n    target = (target as any).correspondingUseElement;\n  }\n\n  return target;\n}\n\n/* istanbul ignore next */\n/**\n * `{ capture: true, passive: true }` object that should be used as a 3rd parameter for `addEventListener` method.\n */\nexport const EVENT_CAPTURE_PASSIVE_OPTIONS = PASSIVE_EVENTS ? { \"capture\": true, \"passive\": true } : true;\n\n/* istanbul ignore next */\n/**\n * `{ capture: true, passive: false }` object that should be used as a 3rd parameter for `addEventListener` method.\n */\nexport const EVENT_CAPTURE_ACTIVE_OPTIONS = PASSIVE_EVENTS ? { \"capture\": true, \"passive\": false } : true;\n\n/* istanbul ignore next */\n/**\n * `{ passive: true }` object that should be used as a 3rd parameter for `addEventListener` method.\n */\nexport const EVENT_PASSIVE_OPTIONS = PASSIVE_EVENTS ? { \"passive\": true } : false;\n\n/* istanbul ignore next */\n/**\n * `{ passive: false }` object that should be used as a 3rd parameter for `addEventListener` method.\n */\nexport const EVENT_ACTIVE_OPTIONS = PASSIVE_EVENTS ? { \"passive\": false } : false;\n","/**\n * Event Handlers.\n *\n * Optimizing compilers should inline all this functions and completely remove unused code.\n */\n\nimport { doc } from \"../dom/shortcuts\";\nimport { OpState } from \"../vdom/state\";\nimport { withSchedulerTick } from \"../scheduler\";\nimport { EventHandlerNode, EventHandlerFlags } from \"./event_handler\";\nimport { DispatchTarget, dispatchEvent } from \"./dispatch\";\nimport { EVENT_CAPTURE_ACTIVE_OPTIONS } from \"./utils\";\n\nexport interface NativeEventSource<E extends Event> {\n  next: (event: E) => void;\n}\n\nexport type NativeEventHandler<E extends Event> = (event: E, currentTarget: OpState, src: {}) => boolean | void;\n\nconst dispatchNativeEvent = (event: Event, currentTarget: DispatchTarget<NativeEventHandler<Event>>, src: {}) => (\n  currentTarget.h.h(event, currentTarget.t, src)\n);\n\n/**\n * Creates a native event source.\n *\n * @typeparam E Native event type.\n * @param flags See {@link NativeEventSourceFlags} for details.\n * @param name Event name\n * @param options Event handler options\n * @returns {@link NativeEventSource} instance\n */\nexport function createNativeEventSource<E extends Event>(\n  name: string,\n  options: { capture?: boolean, passive?: boolean } | boolean = true,\n): NativeEventSource<E> {\n  const source = {\n    next: (event: Event): void => {\n      dispatchEvent(source, event.target as Element, event);\n    }\n  };\n  doc.addEventListener(name, withSchedulerTick((event) => { source.next(event); }), options);\n  return source;\n}\n\nexport function addNativeEventMiddleware<E extends Event>(\n  source: NativeEventSource<E>,\n  fn: (event: E, next: (event: E) => void) => void,\n): void {\n  const next = source.next;\n  source.next = (event: E) => { fn(event, next); };\n}\n\n/* tslint:disable:max-line-length */\nexport const ABORT_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<UIEvent> :\n  /*#__PURE__*/createNativeEventSource<UIEvent>(\"abort\")\n);\nexport const ACTIVATE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<UIEvent> :\n  /*#__PURE__*/createNativeEventSource<UIEvent>(\"activate\")\n);\nexport const ARIA_REQUEST_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<UIEvent> :\n  /*#__PURE__*/createNativeEventSource<UIEvent>(\"ariarequest\")\n);\nexport const BEFORE_ACTIVATE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<UIEvent> :\n  /*#__PURE__*/createNativeEventSource<UIEvent>(\"beforeactivate\")\n);\nexport const BEFORE_COPY_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<ClipboardEvent> :\n  /*#__PURE__*/createNativeEventSource<ClipboardEvent>(\"beforecopy\")\n);\nexport const BEFORE_CUT_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<ClipboardEvent> :\n  /*#__PURE__*/createNativeEventSource<ClipboardEvent>(\"beforecut\")\n);\nexport const BEFORE_DEACTIVATE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<UIEvent> :\n  /*#__PURE__*/createNativeEventSource<UIEvent>(\"beforedeactivate\")\n);\nexport const BEFORE_PASTE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<ClipboardEvent> :\n  /*#__PURE__*/createNativeEventSource<ClipboardEvent>(\"beforepaste\")\n);\nexport const BLUR_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<FocusEvent> :\n  /*#__PURE__*/createNativeEventSource<FocusEvent>(\"blur\")\n);\nexport const CAN_PLAY_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"canplay\")\n);\nexport const CAN_PLAYTHROUGH_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"canplaythrough\")\n);\nexport const CHANGE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"change\")\n);\nexport const CLICK_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<MouseEvent> :\n  /*#__PURE__*/createNativeEventSource<MouseEvent>(\"click\")\n);\nexport const CONTEXT_MENU_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<PointerEvent> :\n  /*#__PURE__*/createNativeEventSource<PointerEvent>(\"contextmenu\")\n);\nexport const COPY_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<ClipboardEvent> :\n  /*#__PURE__*/createNativeEventSource<ClipboardEvent>(\"copy\")\n);\nexport const CUE_CHANGE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"cuechange\")\n);\nexport const CUT_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<ClipboardEvent> :\n  /*#__PURE__*/createNativeEventSource<ClipboardEvent>(\"cut\")\n);\nexport const DOUBLE_CLICK_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<MouseEvent> :\n  /*#__PURE__*/createNativeEventSource<MouseEvent>(\"dblclick\")\n);\nexport const DEACTIVATE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<UIEvent> :\n  /*#__PURE__*/createNativeEventSource<UIEvent>(\"deactivate\")\n);\nexport const DRAG_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<DragEvent> :\n  /*#__PURE__*/createNativeEventSource<DragEvent>(\"drag\")\n);\nexport const DRAG_END_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<DragEvent> :\n  /*#__PURE__*/createNativeEventSource<DragEvent>(\"dragend\")\n);\nexport const DRAG_ENTER_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<DragEvent> :\n  /*#__PURE__*/createNativeEventSource<DragEvent>(\"dragenter\")\n);\nexport const DRAG_LEAVE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<DragEvent> :\n  /*#__PURE__*/createNativeEventSource<DragEvent>(\"dragleave\")\n);\nexport const DRAG_OVER_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<DragEvent> :\n  /*#__PURE__*/createNativeEventSource<DragEvent>(\"dragover\")\n);\nexport const DRAG_START_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<DragEvent> :\n  /*#__PURE__*/createNativeEventSource<DragEvent>(\"dragstart\")\n);\nexport const DROP_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<DragEvent> :\n  /*#__PURE__*/createNativeEventSource<DragEvent>(\"drop\")\n);\nexport const DURATION_CHANGE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"durationchange\")\n);\nexport const EMPTIED_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"emptied\")\n);\nexport const ENCRYPTED_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<MediaEncryptedEvent> :\n  /*#__PURE__*/createNativeEventSource<MediaEncryptedEvent>(\"encrypted\")\n);\nexport const ENDED_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<MediaStreamErrorEvent> :\n  /*#__PURE__*/createNativeEventSource<MediaStreamErrorEvent>(\"ended\")\n);\nexport const ERROR_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<ErrorEvent> :\n  /*#__PURE__*/createNativeEventSource<ErrorEvent>(\"error\")\n);\nexport const FOCUS_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<FocusEvent> :\n  /*#__PURE__*/createNativeEventSource<FocusEvent>(\"focus\")\n);\nexport const GOT_POINTER_CAPTURE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<PointerEvent> :\n  /*#__PURE__*/createNativeEventSource<PointerEvent>(\"gotpointercapture\")\n);\nexport const BEFORE_INPUT_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"beforeinput\")\n);\nexport const INPUT_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"input\")\n);\nexport const INVALID_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"invalid\")\n);\nexport const KEY_DOWN_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<KeyboardEvent> :\n  /*#__PURE__*/createNativeEventSource<KeyboardEvent>(\"keydown\")\n);\nexport const KEY_PRESS_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<KeyboardEvent> :\n  /*#__PURE__*/createNativeEventSource<KeyboardEvent>(\"keypress\")\n);\nexport const KEY_UP_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<KeyboardEvent> :\n  /*#__PURE__*/createNativeEventSource<KeyboardEvent>(\"keyup\")\n);\nexport const LOAD_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"load\")\n);\nexport const LOADED_DATA_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"loadeddata\")\n);\nexport const LOADED_METADATA_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"loadedmetadata\")\n);\nexport const LOAD_START_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"loadstart\")\n);\nexport const LOST_POINTER_CAPTURE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<PointerEvent> :\n  /*#__PURE__*/createNativeEventSource<PointerEvent>(\"lostpointercapture\")\n);\nexport const MOUSE_DOWN_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<MouseEvent> :\n  /*#__PURE__*/createNativeEventSource<MouseEvent>(\"mousedown\")\n);\nexport const MOUSE_MOVE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<MouseEvent> :\n  /*#__PURE__*/createNativeEventSource<MouseEvent>(\"mousemove\")\n);\nexport const MOUSE_OUT_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<MouseEvent> :\n  /*#__PURE__*/createNativeEventSource<MouseEvent>(\"mouseout\")\n);\nexport const MOUSE_OVER_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<MouseEvent> :\n  /*#__PURE__*/createNativeEventSource<MouseEvent>(\"mouseover\")\n);\nexport const MOUSE_UP_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<MouseEvent> :\n  /*#__PURE__*/createNativeEventSource<MouseEvent>(\"mouseup\")\n);\nexport const PASTE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<ClipboardEvent> :\n  /*#__PURE__*/createNativeEventSource<ClipboardEvent>(\"paste\")\n);\nexport const PAUSE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"pause\")\n);\nexport const PLAY_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"play\")\n);\nexport const PLAYING_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"playing\")\n);\nexport const POINTER_CANCEL_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<PointerEvent> :\n  /*#__PURE__*/createNativeEventSource<PointerEvent>(\"pointercancel\")\n);\nexport const POINTER_DOWN_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<PointerEvent> :\n  /*#__PURE__*/createNativeEventSource<PointerEvent>(\"pointerdown\")\n);\nexport const POINTER_MOVE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<PointerEvent> :\n  /*#__PURE__*/createNativeEventSource<PointerEvent>(\"pointermove\")\n);\nexport const POINTER_OUT_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<PointerEvent> :\n  /*#__PURE__*/createNativeEventSource<PointerEvent>(\"pointerout\")\n);\nexport const POINTER_OVER_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<PointerEvent> :\n  /*#__PURE__*/createNativeEventSource<PointerEvent>(\"pointerover\")\n);\nexport const POINTER_UP_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<PointerEvent> :\n  /*#__PURE__*/createNativeEventSource<PointerEvent>(\"pointerup\")\n);\nexport const PROGRESS_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<ProgressEvent> :\n  /*#__PURE__*/createNativeEventSource<ProgressEvent>(\"progress\")\n);\nexport const RATE_CHANGE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"ratechange\")\n);\nexport const RESET_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"reset\")\n);\nexport const SCROLL_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<UIEvent> :\n  /*#__PURE__*/createNativeEventSource<UIEvent>(\"scroll\")\n);\nexport const SEEKED_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"seeked\")\n);\nexport const SEEKING_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"seeking\")\n);\nexport const SELECT_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<UIEvent> :\n  /*#__PURE__*/createNativeEventSource<UIEvent>(\"select\")\n);\nexport const SELECT_START_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"selectstart\")\n);\nexport const STALLED_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"stalled\")\n);\nexport const SUBMIT_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"submit\")\n);\nexport const SUSPEND_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"suspend\")\n);\nexport const TIME_UPDATE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"timeupdate\")\n);\nexport const TOUCH_CANCEL_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<TouchEvent> :\n  /*#__PURE__*/createNativeEventSource<TouchEvent>(\"touchcancel\")\n);\nexport const TOUCH_END_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<TouchEvent> :\n  /*#__PURE__*/createNativeEventSource<TouchEvent>(\"touchend\")\n);\nexport const TOUCH_MOVE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<TouchEvent> :\n  /*#__PURE__*/createNativeEventSource<TouchEvent>(\"touchmove\")\n);\nexport const TOUCH_START_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<TouchEvent> :\n  /*#__PURE__*/createNativeEventSource<TouchEvent>(\"touchstart\")\n);\nexport const TRANSITION_CANCEL_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<TransitionEvent> :\n  /*#__PURE__*/createNativeEventSource<TransitionEvent>(\"transitioncancel\")\n);\nexport const TRANSITION_END_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<TransitionEvent> :\n  /*#__PURE__*/createNativeEventSource<TransitionEvent>(\"transitionend\")\n);\nexport const TRANSITION_RUN_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<TransitionEvent> :\n  /*#__PURE__*/createNativeEventSource<TransitionEvent>(\"transitionrun\")\n);\nexport const TRANSITION_START_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<TransitionEvent> :\n  /*#__PURE__*/createNativeEventSource<TransitionEvent>(\"transitionstart\")\n);\nexport const UNLOAD_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"unload\")\n);\nexport const VOLUME_CHANGE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"volumechange\")\n);\nexport const WAITING_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<Event> :\n  /*#__PURE__*/createNativeEventSource<Event>(\"waiting\")\n);\nexport const WHEEL_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<WheelEvent> :\n  /*#__PURE__*/createNativeEventSource<WheelEvent>(\"wheel\")\n);\n\nexport const ACTIVE_TOUCH_END_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<TouchEvent> :\n  /*#__PURE__*/createNativeEventSource<TouchEvent>(\"touchend\", EVENT_CAPTURE_ACTIVE_OPTIONS)\n);\nexport const ACTIVE_TOUCH_MOVE_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<TouchEvent> :\n  /*#__PURE__*/createNativeEventSource<TouchEvent>(\"touchmove\", EVENT_CAPTURE_ACTIVE_OPTIONS)\n);\nexport const ACTIVE_TOUCH_START_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<TouchEvent> :\n  /*#__PURE__*/createNativeEventSource<TouchEvent>(\"touchstart\", EVENT_CAPTURE_ACTIVE_OPTIONS)\n);\nexport const ACTIVE_WHEEL_EVENT = (\n  process.env.IVI_TARGET === \"ssr\" ? void 0 as any as NativeEventSource<WheelEvent> :\n  /*#__PURE__*/createNativeEventSource<WheelEvent>(\"wheel\", EVENT_CAPTURE_ACTIVE_OPTIONS)\n);\n\n/**\n * Helper function that creates native event handler factories.\n *\n * @param s Native event source.\n * @returns Native event handler factory.\n */\nexport function nativeEventHandlerFactory(s: {}):\n  (h: NativeEventHandler<any>, capture?: boolean) => EventHandlerNode<any> {\n  const bubbleDescriptor = { s, h: dispatchNativeEvent, f: 0 };\n  const captureDescriptor = { s, h: dispatchNativeEvent, f: EventHandlerFlags.Capture };\n  return (h, capture) => ({\n    d: capture === true ? captureDescriptor : bubbleDescriptor,\n    h,\n  });\n}\n\nexport const onAbort: <P>(\n  handler: NativeEventHandler<UIEvent>,\n  capture?: boolean,\n) => EventHandlerNode<UIEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(ABORT_EVENT)\n  );\nexport const onActivate: <P>(\n  handler: NativeEventHandler<UIEvent>,\n  capture?: boolean,\n) => EventHandlerNode<UIEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(ACTIVATE_EVENT)\n  );\nexport const onAriaRequest: <P>(\n  handler: NativeEventHandler<UIEvent>,\n  capture?: boolean,\n) => EventHandlerNode<UIEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(ARIA_REQUEST_EVENT)\n  );\nexport const onBeforeActivate: <P>(\n  handler: NativeEventHandler<UIEvent>,\n  capture?: boolean,\n) => EventHandlerNode<UIEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(BEFORE_ACTIVATE_EVENT)\n  );\nexport const onBeforeCopy: <P>(\n  handler: NativeEventHandler<ClipboardEvent>,\n  capture?: boolean,\n) => EventHandlerNode<ClipboardEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(BEFORE_COPY_EVENT)\n  );\nexport const onBeforeCut: <P>(\n  handler: NativeEventHandler<ClipboardEvent>,\n  capture?: boolean,\n) => EventHandlerNode<ClipboardEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(BEFORE_CUT_EVENT)\n  );\nexport const onBeforeDeactivate: <P>(\n  handler: NativeEventHandler<UIEvent>,\n  capture?: boolean,\n) => EventHandlerNode<UIEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(BEFORE_DEACTIVATE_EVENT)\n  );\nexport const onBeforePaste: <P>(\n  handler: NativeEventHandler<ClipboardEvent>,\n  capture?: boolean,\n) => EventHandlerNode<ClipboardEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(BEFORE_PASTE_EVENT)\n  );\nexport const onBlur: <P>(\n  handler: NativeEventHandler<FocusEvent>,\n  capture?: boolean,\n) => EventHandlerNode<FocusEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(BLUR_EVENT)\n  );\nexport const onCanPlay: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(CAN_PLAY_EVENT)\n  );\nexport const onCanPlaythrough: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(CAN_PLAYTHROUGH_EVENT)\n  );\nexport const onChange: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(CHANGE_EVENT)\n  );\nexport const onClick: <P>(\n  handler: NativeEventHandler<MouseEvent>,\n  capture?: boolean,\n) => EventHandlerNode<MouseEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(CLICK_EVENT)\n  );\nexport const onContextMenu: <P>(\n  handler: NativeEventHandler<PointerEvent>,\n  capture?: boolean,\n) => EventHandlerNode<PointerEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(CONTEXT_MENU_EVENT)\n  );\nexport const onCopy: <P>(\n  handler: NativeEventHandler<ClipboardEvent>,\n  capture?: boolean,\n) => EventHandlerNode<ClipboardEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(COPY_EVENT)\n  );\nexport const onCueChange: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(CUE_CHANGE_EVENT)\n  );\nexport const onCut: <P>(\n  handler: NativeEventHandler<ClipboardEvent>,\n  capture?: boolean,\n) => EventHandlerNode<ClipboardEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(CUT_EVENT)\n  );\nexport const onDoubleClick: <P>(\n  handler: NativeEventHandler<MouseEvent>,\n  capture?: boolean,\n) => EventHandlerNode<MouseEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(DOUBLE_CLICK_EVENT)\n  );\nexport const onDeactivate: <P>(\n  handler: NativeEventHandler<UIEvent>,\n  capture?: boolean,\n) => EventHandlerNode<UIEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(DEACTIVATE_EVENT)\n  );\nexport const onDrag: <P>(\n  handler: NativeEventHandler<DragEvent>,\n  capture?: boolean,\n) => EventHandlerNode<DragEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(DRAG_EVENT)\n  );\nexport const onDragEnd: <P>(\n  handler: NativeEventHandler<DragEvent>,\n  capture?: boolean,\n) => EventHandlerNode<DragEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(DRAG_END_EVENT)\n  );\nexport const onDragEnter: <P>(\n  handler: NativeEventHandler<DragEvent>,\n  capture?: boolean,\n) => EventHandlerNode<DragEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(DRAG_ENTER_EVENT)\n  );\nexport const onDragLeave: <P>(\n  handler: NativeEventHandler<DragEvent>,\n  capture?: boolean,\n) => EventHandlerNode<DragEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(DRAG_LEAVE_EVENT)\n  );\nexport const onDragOver: <P>(\n  handler: NativeEventHandler<DragEvent>,\n  capture?: boolean,\n) => EventHandlerNode<DragEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(DRAG_OVER_EVENT)\n  );\nexport const onDragStart: <P>(\n  handler: NativeEventHandler<DragEvent>,\n  capture?: boolean,\n) => EventHandlerNode<DragEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(DRAG_START_EVENT)\n  );\nexport const onDrop: <P>(\n  handler: NativeEventHandler<DragEvent>,\n  capture?: boolean,\n) => EventHandlerNode<DragEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(DROP_EVENT)\n  );\nexport const onDurationChange: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(DURATION_CHANGE_EVENT)\n  );\nexport const onEmptied: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(EMPTIED_EVENT)\n  );\nexport const onEncrypted: <P>(\n  handler: NativeEventHandler<MediaEncryptedEvent>,\n  capture?: boolean,\n) => EventHandlerNode<MediaEncryptedEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(ENCRYPTED_EVENT)\n  );\nexport const onEnded: <P>(\n  handler: NativeEventHandler<MediaStreamErrorEvent>,\n  capture?: boolean,\n) => EventHandlerNode<MediaStreamErrorEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(ENDED_EVENT)\n  );\nexport const onError: <P>(\n  handler: NativeEventHandler<ErrorEvent>,\n  capture?: boolean,\n) => EventHandlerNode<ErrorEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(ERROR_EVENT)\n  );\nexport const onFocus: <P>(\n  handler: NativeEventHandler<FocusEvent>,\n  capture?: boolean,\n) => EventHandlerNode<FocusEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(FOCUS_EVENT)\n  );\nexport const onGotPointerCapture: <P>(\n  handler: NativeEventHandler<PointerEvent>,\n  capture?: boolean,\n) => EventHandlerNode<PointerEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(GOT_POINTER_CAPTURE_EVENT)\n  );\nexport const onBeforeInput: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(BEFORE_INPUT_EVENT)\n  );\nexport const onInput: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(INPUT_EVENT)\n  );\nexport const onInvalid: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(INVALID_EVENT)\n  );\nexport const onKeyDown: <P>(\n  handler: NativeEventHandler<KeyboardEvent>,\n  capture?: boolean,\n) => EventHandlerNode<KeyboardEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(KEY_DOWN_EVENT)\n  );\nexport const onKeyPress: <P>(\n  handler: NativeEventHandler<KeyboardEvent>,\n  capture?: boolean,\n) => EventHandlerNode<KeyboardEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(KEY_PRESS_EVENT)\n  );\nexport const onKeyUp: <P>(\n  handler: NativeEventHandler<KeyboardEvent>,\n  capture?: boolean,\n) => EventHandlerNode<KeyboardEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(KEY_UP_EVENT)\n  );\nexport const onLoad: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(LOAD_EVENT)\n  );\nexport const onLoadedData: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(LOADED_DATA_EVENT)\n  );\nexport const onLoadedMetadata: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(LOADED_METADATA_EVENT)\n  );\nexport const onLoadStart: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(LOAD_START_EVENT)\n  );\nexport const onLostPointerCapture: <P>(\n  handler: NativeEventHandler<PointerEvent>,\n  capture?: boolean,\n) => EventHandlerNode<PointerEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(LOST_POINTER_CAPTURE_EVENT)\n  );\nexport const onMouseDown: <P>(\n  handler: NativeEventHandler<MouseEvent>,\n  capture?: boolean,\n) => EventHandlerNode<MouseEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(MOUSE_DOWN_EVENT)\n  );\nexport const onMouseMove: <P>(\n  handler: NativeEventHandler<MouseEvent>,\n  capture?: boolean,\n) => EventHandlerNode<MouseEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(MOUSE_MOVE_EVENT)\n  );\nexport const onMouseOut: <P>(\n  handler: NativeEventHandler<MouseEvent>,\n  capture?: boolean,\n) => EventHandlerNode<MouseEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(MOUSE_OUT_EVENT)\n  );\nexport const onMouseOver: <P>(\n  handler: NativeEventHandler<MouseEvent>,\n  capture?: boolean,\n) => EventHandlerNode<MouseEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(MOUSE_OVER_EVENT)\n  );\nexport const onMouseUp: <P>(\n  handler: NativeEventHandler<MouseEvent>,\n  capture?: boolean,\n) => EventHandlerNode<MouseEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(MOUSE_UP_EVENT)\n  );\nexport const onPaste: <P>(\n  handler: NativeEventHandler<ClipboardEvent>,\n  capture?: boolean,\n) => EventHandlerNode<ClipboardEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(PASTE_EVENT)\n  );\nexport const onPause: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(PAUSE_EVENT)\n  );\nexport const onPlay: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(PLAY_EVENT)\n  );\nexport const onPlaying: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(PLAYING_EVENT)\n  );\nexport const onPointerCancel: <P>(\n  handler: NativeEventHandler<PointerEvent>,\n  capture?: boolean,\n) => EventHandlerNode<PointerEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(POINTER_CANCEL_EVENT)\n  );\nexport const onPointerDown: <P>(\n  handler: NativeEventHandler<PointerEvent>,\n  capture?: boolean,\n) => EventHandlerNode<PointerEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(POINTER_DOWN_EVENT)\n  );\nexport const onPointerMove: <P>(\n  handler: NativeEventHandler<PointerEvent>,\n  capture?: boolean,\n) => EventHandlerNode<PointerEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(POINTER_MOVE_EVENT)\n  );\nexport const onPointerOut: <P>(\n  handler: NativeEventHandler<PointerEvent>,\n  capture?: boolean,\n) => EventHandlerNode<PointerEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(POINTER_OUT_EVENT)\n  );\nexport const onPointerOver: <P>(\n  handler: NativeEventHandler<PointerEvent>,\n  capture?: boolean,\n) => EventHandlerNode<PointerEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(POINTER_OVER_EVENT)\n  );\nexport const onPointerUp: <P>(\n  handler: NativeEventHandler<PointerEvent>,\n  capture?: boolean,\n) => EventHandlerNode<PointerEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(POINTER_UP_EVENT)\n  );\nexport const onProgress: <P>(\n  handler: NativeEventHandler<ProgressEvent>,\n  capture?: boolean,\n) => EventHandlerNode<ProgressEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(PROGRESS_EVENT)\n  );\nexport const onRateChange: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(RATE_CHANGE_EVENT)\n  );\nexport const onReset: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(RESET_EVENT)\n  );\nexport const onScroll: <P>(\n  handler: NativeEventHandler<UIEvent>,\n  capture?: boolean,\n) => EventHandlerNode<UIEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(SCROLL_EVENT)\n  );\nexport const onSeeked: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(SEEKED_EVENT)\n  );\nexport const onSeeking: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(SEEKING_EVENT)\n  );\nexport const onSelect: <P>(\n  handler: NativeEventHandler<UIEvent>,\n  capture?: boolean,\n) => EventHandlerNode<UIEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(SELECT_EVENT)\n  );\nexport const onSelectStart: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(SELECT_START_EVENT)\n  );\nexport const onStalled: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(STALLED_EVENT)\n  );\nexport const onSubmit: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(SUBMIT_EVENT)\n  );\nexport const onSuspend: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(SUSPEND_EVENT)\n  );\nexport const onTimeUpdate: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(TIME_UPDATE_EVENT)\n  );\nexport const onTouchCancel: <P>(\n  handler: NativeEventHandler<TouchEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TouchEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(TOUCH_CANCEL_EVENT)\n  );\nexport const onTouchEnd: <P>(\n  handler: NativeEventHandler<TouchEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TouchEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(TOUCH_END_EVENT)\n  );\nexport const onTouchMove: <P>(\n  handler: NativeEventHandler<TouchEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TouchEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(TOUCH_MOVE_EVENT)\n  );\nexport const onTouchStart: <P>(\n  handler: NativeEventHandler<TouchEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TouchEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(TOUCH_START_EVENT)\n  );\nexport const onTransitionCancel: <P>(\n  handler: NativeEventHandler<TransitionEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TransitionEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(TRANSITION_CANCEL_EVENT)\n  );\nexport const onTransitionEnd: <P>(\n  handler: NativeEventHandler<TransitionEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TransitionEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(TRANSITION_END_EVENT)\n  );\nexport const onTransitionRun: <P>(\n  handler: NativeEventHandler<TransitionEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TransitionEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(TRANSITION_RUN_EVENT)\n  );\nexport const onTransitionStart: <P>(\n  handler: NativeEventHandler<TransitionEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TransitionEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(TRANSITION_START_EVENT)\n  );\nexport const onUnload: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(UNLOAD_EVENT)\n  );\nexport const onVolumeChange: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(VOLUME_CHANGE_EVENT)\n  );\nexport const onWaiting: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(WAITING_EVENT)\n  );\nexport const onWheel: <P>(\n  handler: NativeEventHandler<WheelEvent>,\n  capture?: boolean,\n) => EventHandlerNode<WheelEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(WHEEL_EVENT)\n  );\n\nexport const onActiveTouchEnd: <P>(\n  handler: NativeEventHandler<TouchEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TouchEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(ACTIVE_TOUCH_END_EVENT)\n  );\nexport const onActiveTouchMove: <P>(\n  handler: NativeEventHandler<TouchEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TouchEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(ACTIVE_TOUCH_MOVE_EVENT)\n  );\nexport const onActiveTouchStart: <P>(\n  handler: NativeEventHandler<TouchEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TouchEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(ACTIVE_TOUCH_START_EVENT)\n  );\nexport const onActiveWheel: <P>(\n  handler: NativeEventHandler<WheelEvent>,\n  capture?: boolean,\n) => EventHandlerNode<WheelEvent> = (\n    process.env.IVI_TARGET === \"ssr\" ? /* istanbul ignore next */ () => (null as any) :\n    /*#__PURE__*/nativeEventHandlerFactory(ACTIVE_WHEEL_EVENT)\n  );\n\n/* tslint:enable:max-line-length */\n","/**\n * Shortcut for an `undefined` value.\n */\nexport const _ = void 0;\n","import {\n  HTMLAnchorElementAttrs, HTMLElementAttrs, HTMLAreaElementAttrs, HTMLAudioElementAttrs,\n  HTMLBaseElementAttrs, HTMLBodyElementAttrs, HTMLBRElementAttrs, HTMLButtonElementAttrs,\n  HTMLCanvasElementAttrs, HTMLQuoteElementAttrs, HTMLTableCaptionElementAttrs, HTMLTableColElementAttrs,\n  HTMLModElementAttrs, HTMLDivElementAttrs, HTMLDListElementAttrs, HTMLFieldSetElementAttrs, HTMLFormElementAttrs,\n  HTMLHeadElementAttrs, HTMLHeadingElementAttrs, HTMLHRElementAttrs, HTMLHtmlElementAttrs, HTMLIFrameElementAttrs,\n  HTMLImageElementAttrs, HTMLInputElementAttrs, HTMLLabelElementAttrs, HTMLLegendElementAttrs, HTMLLIElementAttrs,\n  HTMLLinkElementAttrs, HTMLMapElementAttrs, HTMLMenuElementAttrs, HTMLMetaElementAttrs, HTMLMeterElementAttrs,\n  HTMLOListElementAttrs, HTMLOptGroupElementAttrs, HTMLOptionElementAttrs, HTMLParagraphElementAttrs,\n  HTMLPictureElementAttrs, HTMLPreElementAttrs, HTMLProgressElementAttrs, HTMLScriptElementAttrs,\n  HTMLSelectElementAttrs, HTMLSourceElementAttrs, HTMLSpanElementAttrs, HTMLStyleElementAttrs,\n  HTMLTableDataCellElementAttrs, HTMLTableElementAttrs, HTMLTableHeaderCellElementAttrs, HTMLTableRowElementAttrs,\n  HTMLTableSectionElementAttrs, HTMLTemplateElementAttrs, HTMLTextAreaElementAttrs, HTMLTitleElementAttrs,\n  HTMLTrackElementAttrs, HTMLUListElementAttrs, HTMLVideoElementAttrs,\n\n  AttributeDirective, elementFactory, htmlElementFactory, NodeFlags,\n  emitAttribute, emitChildren, escapeAttributeValue, escapeText, IGNORE_RENDER_TO_STRING,\n} from \"ivi\";\n\n/**\n * {@link AttributeDirective} with `\"\"` value and {@link updateValue} sync function.\n */\nconst VALUE_EMPTY: AttributeDirective<string> = { v: \"\", u: updateValue };\n\n/**\n * {@link AttributeDirective} with `false` value and {@link updateChecked} sync function.\n */\nconst CHECKED_FALSE: AttributeDirective<boolean> = { v: false, u: updateChecked };\n\n/**\n * {@link AttributeDirective} with `true` value and {@link updateChecked} sync function.\n */\nconst CHECKED_TRUE: AttributeDirective<boolean> = { v: true, u: updateChecked };\n\n/**\n * {@link AttributeDirective} with `true` value that emits `checked` attribute.\n */\nconst CHECKED_TRUE_RENDER_TO_STRING: AttributeDirective<boolean> = { v: true, s: () => { emitAttribute(\"checked\"); } };\n\n/**\n * Render to string function for an {@link AttributeDirective} created with {@link VALUE} function.\n *\n * @param key Attribute key.\n * @param value Value.\n */\nfunction renderToStringValue(key: string, value: string) {\n  emitAttribute(`value=\"${escapeAttributeValue(value)}\"`);\n}\n\n/**\n * Render to string function for an {@link AttributeDirective} created with {@link CONTENT} function.\n *\n * @param key Attribute key.\n * @param value Value.\n */\nfunction renderToStringContent(key: string, value: string) {\n  emitChildren(escapeText(value));\n}\n\n/**\n * Synchronization function for {@link AttributeDirective} created with {@link VALUE} function.\n *\n * @param element Target element.\n * @param key Attribute key.\n * @param prev Previous value.\n * @param next Next value.\n */\nfunction updateValue(\n  element: Element,\n  key: string,\n  prev: string | undefined,\n  next: string | undefined,\n) {\n  if (prev === void 0) {\n    if (next !== \"\") {\n      (element as HTMLInputElement | HTMLTextAreaElement).value = next!;\n    }\n  } else if (next !== void 0 && ((element as HTMLInputElement | HTMLTextAreaElement).value !== next)) {\n    (element as HTMLInputElement | HTMLTextAreaElement).value = next;\n  }\n}\n\n/**\n * Synchronization function for {@link AttributeDirective} created with {@link CHECKED} function.\n *\n * @param element Target element.\n * @param key Attribute key.\n * @param prev Previous value.\n * @param next Next value.\n */\nfunction updateChecked(\n  element: Element,\n  key: string,\n  prev: boolean | undefined,\n  next: boolean | undefined,\n) {\n  if (prev === void 0) {\n    if (next) {\n      (element as HTMLInputElement).checked = next;\n    }\n  } else if (next !== void 0) {\n    if ((element as HTMLInputElement).checked !== next) {\n      (element as HTMLInputElement).checked = next!;\n    }\n  }\n}\n\n/**\n * VALUE function creates a {@link AttributeDirective} that assigns a `value` property to an HTMLInputElement.\n *\n * @example\n *\n *   const e = input(\"\", { value: VALUE(\"value\") });\n *\n * @param v Value.\n * @returns {@link AttributeDirective}\n */\nexport const VALUE = (v: string): AttributeDirective<string> => (\n  process.env.IVI_TARGET === \"ssr\" ?\n    v === \"\" ? IGNORE_RENDER_TO_STRING : { v, s: renderToStringValue } :\n    v === \"\" ? VALUE_EMPTY : { v, u: updateValue }\n);\n\n/**\n * CONTENT function creates a {@link AttributeDirective} that assigns a `value` property to an HTMLTextAreaElement.\n *\n * @example\n *\n *   const e = textarea(\"\", { content: CONTENT(\"content\") });\n *\n * @param v Value.\n * @returns {@link AttributeDirective}\n */\nexport const CONTENT = (\n  process.env.IVI_TARGET === \"ssr\" ?\n    (v: string): AttributeDirective<string> => (\n      v === \"\" ? IGNORE_RENDER_TO_STRING : ({ v, s: renderToStringContent })\n    ) :\n    VALUE\n);\n\n/**\n * CHECKED function creates a {@link AttributeDirective} that assigns a `checked` property to an HTMLInputElement.\n *\n * @example\n *\n *   const e = input(\"\", { checked: CHECKED(true) });\n *\n * @param v Checked value.\n * @returns {@link AttributeDirective}\n */\nexport const CHECKED = (v: boolean): AttributeDirective<boolean> => (\n  process.env.IVI_TARGET === \"ssr\" ?\n    v ? CHECKED_TRUE_RENDER_TO_STRING : IGNORE_RENDER_TO_STRING :\n    v ? CHECKED_TRUE : CHECKED_FALSE\n);\n\n/* tslint:disable:max-line-length */\n/**\n * Creates OpNode HTML element <a>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <a>\n */\nexport const a = /*#__PURE__*/htmlElementFactory<HTMLAnchorElementAttrs, HTMLAnchorElement>(\"a\");\n\n/**\n * Creates OpNode HTML element <abbr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/abbr}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <abbr>\n */\nexport const abbr = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"abbr\");\n\n/**\n * Creates OpNode HTML element <address>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/address}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <address>\n */\nexport const address = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"address\");\n\n/**\n * Creates OpNode HTML element <article>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <article>\n */\nexport const article = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"article\");\n\n/**\n * Creates OpNode HTML element <aside>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <aside>\n */\nexport const aside = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"aside\");\n\n/**\n * Creates OpNode HTML element <b>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/b}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <b>\n */\nexport const b = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"b\");\n\n/**\n * Creates OpNode HTML element <base>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <base>\n */\nexport const base = /*#__PURE__*/elementFactory<HTMLBaseElementAttrs, HTMLBaseElement>(\"base\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <bdo>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/bdo}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <bdo>\n */\nexport const bdo = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"bdo\");\n\n/**\n * Creates OpNode HTML element <blockquote>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <blockquote>\n */\nexport const blockquote = /*#__PURE__*/htmlElementFactory<HTMLQuoteElementAttrs, HTMLQuoteElement>(\"blockquote\");\n\n/**\n * Creates OpNode HTML element <body>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <body>\n */\nexport const body = /*#__PURE__*/htmlElementFactory<HTMLBodyElementAttrs, HTMLBodyElement>(\"body\");\n\n/**\n * Creates OpNode HTML element <br>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/br}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <br>\n */\nexport const br = /*#__PURE__*/elementFactory<HTMLBRElementAttrs, HTMLBRElement>(\"br\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <button>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <button>\n */\nexport const button = /*#__PURE__*/htmlElementFactory<HTMLButtonElementAttrs, HTMLButtonElement>(\"button\");\n\n/**\n * Creates OpNode HTML element <canvas>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <canvas>\n */\nexport const canvas = /*#__PURE__*/htmlElementFactory<HTMLCanvasElementAttrs, HTMLCanvasElement>(\"canvas\");\n\n/**\n * Creates OpNode HTML element <caption>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <caption>\n */\nexport const caption = /*#__PURE__*/htmlElementFactory<HTMLTableCaptionElementAttrs, HTMLTableCaptionElement>(\"caption\");\n\n/**\n * Creates OpNode HTML element <cite>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/cite}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <cite>\n */\nexport const cite = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"cite\");\n\n/**\n * Creates OpNode HTML element <code>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/code}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <code>\n */\nexport const code = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"code\");\n\n/**\n * Creates OpNode HTML element <col>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <col>\n */\nexport const col = /*#__PURE__*/elementFactory<HTMLTableColElementAttrs, HTMLTableColElement>(\"col\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <colgroup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/colgroup}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <colgroup>\n */\nexport const colgroup = /*#__PURE__*/htmlElementFactory<HTMLTableColElementAttrs, HTMLTableColElement>(\"colgroup\");\n\n/**\n * Creates OpNode HTML element <del>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/del}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <del>\n */\nexport const del = /*#__PURE__*/htmlElementFactory<HTMLModElementAttrs, HTMLModElement>(\"del\");\n\n/**\n * Creates OpNode HTML element <dfn>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dfn}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <dfn>\n */\nexport const dfn = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"dfn\");\n\n/**\n * Creates OpNode HTML element <div>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <div>\n */\nexport const div = /*#__PURE__*/htmlElementFactory<HTMLDivElementAttrs, HTMLDivElement>(\"div\");\n\n/**\n * Creates OpNode HTML element <dd>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dd}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <dd>\n */\nexport const dd = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"dd\");\n\n/**\n * Creates OpNode HTML element <dl>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dl}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <dl>\n */\nexport const dl = /*#__PURE__*/htmlElementFactory<HTMLDListElementAttrs, HTMLDListElement>(\"dl\");\n\n/**\n * Creates OpNode HTML element <dt>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <dt>\n */\nexport const dt = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"dt\");\n\n/**\n * Creates OpNode HTML element <em>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/em}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <em>\n */\nexport const em = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"em\");\n\n/**\n * Creates OpNode HTML element <fieldset>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/fieldset}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <fieldset>\n */\nexport const fieldset = /*#__PURE__*/htmlElementFactory<HTMLFieldSetElementAttrs, HTMLFieldSetElement>(\"fieldset\");\n\n/**\n * Creates OpNode HTML element <figcaption>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figcaption}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <figcaption>\n */\nexport const figcaption = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"figcaption\");\n\n/**\n * Creates OpNode HTML element <figure>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figure}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <figure>\n */\nexport const figure = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"figure\");\n\n/**\n * Creates OpNode HTML element <footer>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/footer}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <footer>\n */\nexport const footer = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"footer\");\n\n/**\n * Creates OpNode HTML element <form>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <form>\n */\nexport const form = /*#__PURE__*/htmlElementFactory<HTMLFormElementAttrs, HTMLFormElement>(\"form\");\n\n/**\n * Creates OpNode HTML element <h1>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h1}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h1>\n */\nexport const h1 = /*#__PURE__*/htmlElementFactory<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h1\");\n\n/**\n * Creates OpNode HTML element <h2>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h2}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h2>\n */\nexport const h2 = /*#__PURE__*/htmlElementFactory<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h2\");\n\n/**\n * Creates OpNode HTML element <h3>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h3}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h3>\n */\nexport const h3 = /*#__PURE__*/htmlElementFactory<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h3\");\n\n/**\n * Creates OpNode HTML element <h4>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h4}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h4>\n */\nexport const h4 = /*#__PURE__*/htmlElementFactory<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h4\");\n\n/**\n * Creates OpNode HTML element <h5>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h5}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h5>\n */\nexport const h5 = /*#__PURE__*/htmlElementFactory<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h5\");\n\n/**\n * Creates OpNode HTML element <h6>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h6}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h6>\n */\nexport const h6 = /*#__PURE__*/htmlElementFactory<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h6\");\n\n/**\n * Creates OpNode HTML element <head>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <head>\n */\nexport const head = /*#__PURE__*/htmlElementFactory<HTMLHeadElementAttrs, HTMLHeadElement>(\"head\");\n\n/**\n * Creates OpNode HTML element <header>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/header}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <header>\n */\nexport const header = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"header\");\n\n/**\n * Creates OpNode HTML element <hgroup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hgroup}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <hgroup>\n */\nexport const hgroup = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"hgroup\");\n\n/**\n * Creates OpNode HTML element <hr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hr}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <hr>\n */\nexport const hr = /*#__PURE__*/elementFactory<HTMLHRElementAttrs, HTMLHRElement>(\"hr\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <html>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <html>\n */\nexport const html = /*#__PURE__*/htmlElementFactory<HTMLHtmlElementAttrs, HTMLHtmlElement>(\"html\");\n\n/**\n * Creates OpNode HTML element <i>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/i}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <i>\n */\nexport const i = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"i\");\n\n/**\n * Creates OpNode HTML element <iframe>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <iframe>\n */\nexport const iframe = /*#__PURE__*/htmlElementFactory<HTMLIFrameElementAttrs, HTMLIFrameElement>(\"iframe\");\n\n/**\n * Creates OpNode HTML element <img>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <img>\n */\nexport const img = /*#__PURE__*/elementFactory<HTMLImageElementAttrs, HTMLImageElement>(\"img\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <area>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <area>\n */\nexport const area = /*#__PURE__*/elementFactory<HTMLAreaElementAttrs, HTMLAreaElement>(\"area\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <map>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <map>\n */\nexport const map = /*#__PURE__*/htmlElementFactory<HTMLMapElementAttrs, HTMLMapElement>(\"map\");\n\n/**\n * Creates OpNode HTML element <ins>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ins}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <ins>\n */\nexport const ins = /*#__PURE__*/htmlElementFactory<HTMLModElementAttrs, HTMLModElement>(\"ins\");\n\n/**\n * Creates OpNode HTML element <kbd>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/kbd}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <kbd>\n */\nexport const kbd = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"kbd\");\n\n/**\n * Creates OpNode HTML element <label>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <label>\n */\nexport const label = /*#__PURE__*/htmlElementFactory<HTMLLabelElementAttrs, HTMLLabelElement>(\"label\");\n\n/**\n * Creates OpNode HTML element <legend>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/legend}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <legend>\n */\nexport const legend = /*#__PURE__*/htmlElementFactory<HTMLLegendElementAttrs, HTMLLegendElement>(\"legend\");\n\n/**\n * Creates OpNode HTML element <li>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <li>\n */\nexport const li = /*#__PURE__*/htmlElementFactory<HTMLLIElementAttrs, HTMLLIElement>(\"li\");\n\n/**\n * Creates OpNode HTML element <link>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <link>\n */\nexport const link = /*#__PURE__*/elementFactory<HTMLLinkElementAttrs, HTMLLinkElement>(\"link\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <main>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/main}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <main>\n */\nexport const main = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"main\");\n\n/**\n * Creates OpNode HTML element <mark>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/mark}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <mark>\n */\nexport const mark = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"mark\");\n\n/**\n * Creates OpNode HTML element <menu>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/menu}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <menu>\n */\nexport const menu = /*#__PURE__*/htmlElementFactory<HTMLMenuElementAttrs, HTMLMenuElement>(\"menu\");\n\n/**\n * Creates OpNode HTML element <meta>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <meta>\n */\nexport const meta = /*#__PURE__*/elementFactory<HTMLMetaElementAttrs, HTMLMetaElement>(\"meta\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <meter>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meter}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <meter>\n */\nexport const meter = /*#__PURE__*/htmlElementFactory<HTMLMeterElementAttrs, HTMLMeterElement>(\"meter\");\n\n/**\n * Creates OpNode HTML element <nav>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <nav>\n */\nexport const nav = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"nav\");\n\n/**\n * Creates OpNode HTML element <noscript>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/noscript}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <noscript>\n */\nexport const noscript = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"noscript\");\n\n/**\n * Creates OpNode HTML element <ol>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ol}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <ol>\n */\nexport const ol = /*#__PURE__*/htmlElementFactory<HTMLOListElementAttrs, HTMLOListElement>(\"ol\");\n\n/**\n * Creates OpNode HTML element <optgroup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/optgroup}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <optgroup>\n */\nexport const optgroup = /*#__PURE__*/htmlElementFactory<HTMLOptGroupElementAttrs, HTMLOptGroupElement>(\"optgroup\");\n\n/**\n * Creates OpNode HTML element <option>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <option>\n */\nexport const option = /*#__PURE__*/htmlElementFactory<HTMLOptionElementAttrs, HTMLOptionElement>(\"option\");\n\n/**\n * Creates OpNode HTML element <p>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <p>\n */\nexport const p = /*#__PURE__*/htmlElementFactory<HTMLParagraphElementAttrs, HTMLParagraphElement>(\"p\");\n\n/**\n * Creates OpNode HTML element <picture>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <picture>\n */\nexport const picture = /*#__PURE__*/htmlElementFactory<HTMLPictureElementAttrs, HTMLPictureElement>(\"picture\");\n\n/**\n * Creates OpNode HTML element <pre>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/pre}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <pre>\n */\nexport const pre = /*#__PURE__*/elementFactory<HTMLPreElementAttrs, HTMLPreElement>(\"pre\", NodeFlags.Element | NodeFlags.NewlineEatingElement);\n\n/**\n * Creates OpNode HTML element <progress>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/progress}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <progress>\n */\nexport const progress = /*#__PURE__*/htmlElementFactory<HTMLProgressElementAttrs, HTMLProgressElement>(\"progress\");\n\n/**\n * Creates OpNode HTML element <q>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <q>\n */\nexport const q = /*#__PURE__*/htmlElementFactory<HTMLQuoteElementAttrs, HTMLQuoteElement>(\"q\");\n\n/**\n * Creates OpNode HTML element <rt>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/rt}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <rt>\n */\nexport const rt = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"rt\");\n\n/**\n * Creates OpNode HTML element <ruby>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ruby}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <ruby>\n */\nexport const ruby = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"ruby\");\n\n/**\n * Creates OpNode HTML element <s>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/s}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <s>\n */\nexport const s = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"s\");\n\n/**\n * Creates OpNode HTML element <samp>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/samp}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <samp>\n */\nexport const samp = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"samp\");\n\n/**\n * Creates OpNode HTML element <script>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <script>\n */\nexport const script = /*#__PURE__*/htmlElementFactory<HTMLScriptElementAttrs, HTMLScriptElement>(\"script\");\n\n/**\n * Creates OpNode HTML element <section>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/section}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <section>\n */\nexport const section = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"section\");\n\n/**\n * Creates OpNode HTML element <select>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <select>\n */\nexport const select = /*#__PURE__*/htmlElementFactory<HTMLSelectElementAttrs, HTMLSelectElement>(\"select\");\n\n/**\n * Creates OpNode HTML element <source>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <source>\n */\nexport const source = /*#__PURE__*/elementFactory<HTMLSourceElementAttrs, HTMLSourceElement>(\"source\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <span>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <span>\n */\nexport const span = /*#__PURE__*/htmlElementFactory<HTMLSpanElementAttrs, HTMLSpanElement>(\"span\");\n\n/**\n * Creates OpNode HTML element <strong>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/strong}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <strong>\n */\nexport const strong = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"strong\");\n\n/**\n * Creates OpNode HTML element <style>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <style>\n */\nexport const style = /*#__PURE__*/htmlElementFactory<HTMLStyleElementAttrs, HTMLStyleElement>(\"style\");\n\n/**\n * Creates OpNode HTML element <sub>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sub}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <sub>\n */\nexport const sub = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"sub\");\n\n/**\n * Creates OpNode HTML element <sup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sup}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <sup>\n */\nexport const sup = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"sup\");\n\n/**\n * Creates OpNode HTML element <table>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <table>\n */\nexport const table = /*#__PURE__*/htmlElementFactory<HTMLTableElementAttrs, HTMLTableElement>(\"table\");\n\n/**\n * Creates OpNode HTML element <tbody>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tbody}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <tbody>\n */\nexport const tbody = /*#__PURE__*/htmlElementFactory<HTMLTableSectionElementAttrs, HTMLTableSectionElement>(\"tbody\");\n\n/**\n * Creates OpNode HTML element <td>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <td>\n */\nexport const td = /*#__PURE__*/htmlElementFactory<HTMLTableDataCellElementAttrs, HTMLTableDataCellElement>(\"td\");\n\n/**\n * Creates OpNode HTML element <template>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <template>\n */\nexport const template = /*#__PURE__*/htmlElementFactory<HTMLTemplateElementAttrs, HTMLTemplateElement>(\"template\");\n\n/**\n * Creates OpNode HTML element <tfoot>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tfoot}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <tfoot>\n */\nexport const tfoot = /*#__PURE__*/htmlElementFactory<HTMLTableSectionElementAttrs, HTMLTableSectionElement>(\"tfoot\");\n\n/**\n * Creates OpNode HTML element <th>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <th>\n */\nexport const th = /*#__PURE__*/htmlElementFactory<HTMLTableHeaderCellElementAttrs, HTMLTableHeaderCellElement>(\"th\");\n\n/**\n * Creates OpNode HTML element <thead>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/thead}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <thead>\n */\nexport const thead = /*#__PURE__*/htmlElementFactory<HTMLTableSectionElementAttrs, HTMLTableSectionElement>(\"thead\");\n\n/**\n * Creates OpNode HTML element <time>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/time}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <time>\n */\nexport const time = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"time\");\n\n/**\n * Creates OpNode HTML element <title>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <title>\n */\nexport const title = /*#__PURE__*/htmlElementFactory<HTMLTitleElementAttrs, HTMLTitleElement>(\"title\");\n\n/**\n * Creates OpNode HTML element <tr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tr}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <tr>\n */\nexport const tr = /*#__PURE__*/htmlElementFactory<HTMLTableRowElementAttrs, HTMLTableRowElement>(\"tr\");\n\n/**\n * Creates OpNode HTML element <track>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <track>\n */\nexport const track = /*#__PURE__*/elementFactory<HTMLTrackElementAttrs, HTMLTrackElement>(\"track\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <u>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/u}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <u>\n */\nexport const u = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"u\");\n\n/**\n * Creates OpNode HTML element <ul>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <ul>\n */\nexport const ul = /*#__PURE__*/htmlElementFactory<HTMLUListElementAttrs, HTMLUListElement>(\"ul\");\n\n/**\n * Creates OpNode HTML element <wbr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/wbr}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <wbr>\n */\nexport const wbr = /*#__PURE__*/elementFactory<HTMLElementAttrs, HTMLElement>(\"wbr\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <textarea>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <textarea>\n */\nexport const textarea = /*#__PURE__*/elementFactory<HTMLTextAreaElementAttrs, HTMLTextAreaElement>(\"textarea\", NodeFlags.Element | NodeFlags.NewlineEatingElement);\n\n/**\n * Creates OpNode HTML element <input>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <input>\n */\nexport const input = /*#__PURE__*/elementFactory<HTMLInputElementAttrs, HTMLInputElement>(\"input\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <audio>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <audio>\n */\nexport const audio = /*#__PURE__*/htmlElementFactory<HTMLAudioElementAttrs, HTMLAudioElement>(\"audio\");\n\n/**\n * Creates OpNode HTML element <video>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <video>\n */\nexport const video = /*#__PURE__*/htmlElementFactory<HTMLVideoElementAttrs, HTMLVideoElement>(\"video\");\n","import { _, statelessComponent, withNextFrame, render, Events, onClick, TrackByKey, key } from \"ivi\";\nimport { td, tr, table, tbody, div, li, ul, pre } from \"ivi-html\";\nconst TableCell = statelessComponent((t) => (Events(onClick(() => { console.log(\"Click\", t); }), td(\"TableCell\", _, t))));\nconst TableRow = statelessComponent(({ id, active, props }) => (tr(active ? \"TableRow active\" : \"TableRow\", { \"data-id\": id }, [\n    TableCell(\"#\" + id),\n    props.map((item) => TableCell(item)),\n])));\nconst Table = statelessComponent((p) => (table(\"Table\", _, tbody(_, _, TrackByKey(p.items.map((item) => key(item.id, TableRow(item))))))));\nconst AnimBox = statelessComponent(({ id, time }) => (div(\"AnimBox\", {\n    \"data-id\": id,\n    style: {\n        \"background\": \"rgba(0,0,0,\" + (0.5 + ((time % 10) / 10)) + \")\",\n        \"border-radius\": (time % 10) + \"px\",\n    },\n})));\nconst Anim = statelessComponent((p) => (div(\"Anim\", _, TrackByKey(p.items.map((item) => key(item.id, AnimBox(item)))))));\nconst TreeLeaf = statelessComponent((p) => li(\"TreeLeaf\", _, p.id));\nconst TreeNode = statelessComponent((p) => (ul(\"TreeNode\", _, TrackByKey(p.children.map((n) => key(n.id, n.container ? TreeNode(n) : TreeLeaf(n)))))));\nconst Tree = statelessComponent((p) => div(\"Tree\", _, TreeNode(p.root)));\nfunction route(state) {\n    switch (state.location) {\n        case \"table\": return Table(state.table);\n        case \"anim\": return Anim(state.anim);\n        default: return Tree(state.tree);\n    }\n}\nconst Main = statelessComponent((state) => div(\"Main\", _, state ? route(state) : null));\nuibench.init(\"ivi\", \"0.26.0\");\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    const container = document.querySelector(\"#App\");\n    render(Main(), container);\n    uibench.run((state) => withNextFrame(() => { render(Main(state), container); })(), (samples) => { render(pre(_, _, JSON.stringify(samples, undefined, 2)), container); });\n});\n"],"sourceRoot":""}