{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:////home/void/w/ts/ivi-examples/node_modules/tslib/tslib.es6.js","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/vnode.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/vnode_collections.ts","webpack:////home/void/w/ts/ivi/packages/ivi-core/src/noop.ts","webpack:////home/void/w/ts/ivi/packages/ivi-core/src/error.ts","webpack:////home/void/w/ts/ivi/packages/ivi-core/src/array.ts","webpack:////home/void/w/ts/ivi/packages/ivi-core/src/repeatable_task_list.ts","webpack:////home/void/w/ts/ivi/packages/ivi-scheduler/src/index.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/component.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/vnode_factories.ts","webpack:////home/void/w/ts/ivi/packages/ivi-core/src/user_agent.ts","webpack:////home/void/w/ts/ivi/node_modules/tslib/tslib.es6.js","webpack:////home/void/w/ts/ivi/packages/ivi-core/src/shortcuts.ts","webpack:////home/void/w/ts/ivi/packages/ivi-core/src/const.ts","webpack:////home/void/w/ts/ivi/packages/ivi-events/src/sync_events.ts","webpack:////home/void/w/ts/ivi/packages/ivi-core/src/feature_detection.ts","webpack:////home/void/w/ts/ivi/packages/ivi-events/src/utils.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/sync_dom.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/implementation.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/root.ts","webpack:////home/void/w/ts/ivi/packages/ivi-events/src/synthetic_event.ts","webpack:////home/void/w/ts/ivi/packages/ivi-events/src/traverse_dom.ts","webpack:////home/void/w/ts/ivi/packages/ivi-events/src/dispatch.ts","webpack:////home/void/w/ts/ivi/packages/ivi-events/src/native_event_source.ts","webpack:////home/void/w/ts/ivi/packages/ivi-events/src/events.ts","webpack:////home/void/w/ts/ivi/packages/ivi-html/src/index.ts","webpack:///./src/main.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","extendStatics","setPrototypeOf","__proto__","Array","b","__extends","__","this","constructor","create","assign","VNode","flags","tag","props","className","children","prev","next","key","instance","style","events","k","e","a","attrs","arguments","first","length","last","unsafeHTML","html","getDOMInstanceFromVNode","node","map","array","fn","NOOP","_errorHandlers","catchError","apply","unorderedArrayDelete","index","pop","runRepeatableTasks","tasks","run","t","_isHidden","_flags","_microtasks","_tasks","_visibilityObservers","_animations","_readers","_updateDOMHandler","_currentFrame","write","read","after","_nextFrame","_autofocusedElement","runMicrotasks","MessageChannel","port1","onmessage","ev","handleVisibilityChange","newHidden","requestNextFrame","observers","_updateCurrentFrameStartTime","time","undefined","performance","now","_requestNextFrame","requestAnimationFrame","_handleNextFrame","task","Promise","resolve","then","push","document","hidden","addEventListener","frame","focus","addFrameTaskUpdate","triggerNextFrame","component_Component","Component","newPropsReceived","oldProps","newProps","attached","detached","shouldUpdate","updated","local","invalidated","invalidate","statefulComponent","ua","navigator","userAgent","USER_AGENT","test","window","indexOf","tslib_es6_extendStatics","tslib_es6_assign","nodeProto","Node","elementProto","Element","nodeInsertBefore","insertBefore","nodeRemoveChild","removeChild","nodeReplaceChild","replaceChild","nodeCloneNode","cloneNode","elementSetAttribute","setAttribute","elementSetAttributeNS","setAttributeNS","elementRemoveAttribute","removeAttribute","SVG_NAMESPACE","XLINK_NAMESPACE","XML_NAMESPACE","registerEventHandler","handler","source","addListener","unregisterEventHandler","removeListener","attachEvents","h","detachEvents","PASSIVE_EVENTS","v","opts","getEventTarget","target","correspondingUseElement","KeyboardEvent","MouseEvent","UIEvent","EVENT_CAPTURE_PASSIVE_OPTIONS","capture","passive","EVENT_PASSIVE_OPTIONS","getNativeEventOptions","setEventHandlersToDOMNode","_ev","syncStyle","bValue","setProperty","removeProperty","setDOMAttribute","svg","charCodeAt","startsWith","syncDOMAttrs","removeVNode","parent","_detach","_attach","vnode","child","component","dirtyCheck","context","dirtyContext","deepUpdate","syncVNode","render","connect","selectData","select","_removeAllChildren","firstNode","textContent","_setInputValue","input","checked","_render","createTextNode","tagName","createElementNS","createElement","factory","innerHTML","module_autofocus","renderVNode","refChild","_eqKeys","bFlags","nodeValue","h1","h2","syncEvents","aChild","bChild","aFlags","aFirstNode","bFirstNode","aNode","bNode","j","aStartNode","bStartNode","aEndNode","bEndNode","synced","finished","outer","aInnerLength","bInnerLength","moved","keyIndex","positionKeyIndex","Map","set","bArray","sources","fill","innerSynced","seq","u","slice","result","il","lis","_syncChildrenTrackByKeys","sc","prevSelectData","ROOTS","EMPTY_CONTEXT","_pendingUpdate","_update","update","root","container","currentVNode","newVNode","onclick","root_render","findRoot","updateNextFrame","renderNextFrame","addFrameTaskWrite","synthetic_event_SyntheticNativeEvent","_super","SyntheticNativeEvent","timestamp","native","_this","tslib_es6_extends","SyntheticEvent","stopPropagation","preventDefault","accumulateDispatchTargetsFromElement","match","matches","count","handlers","getFlags","dispatchEventToLocalEventHandlers","event","matchFlags","dispatch","isArray","createNativeEventSource","eventSource","listeners","dependencies","incDependencies","removeEventListener","decDependencies","onBeforeListeners","onAfterListeners","matchEventSource","targets","parentElement","accumulateDispatchTargets","syntheticEvent","timeStamp","dispatchToListeners","bubble","dispatchEvent","cbs","EventSourceClick","div","TableCell","class_1","onClick","console","log","state","createEventHandler","TableRow","class_2","id","data-id","item","Table","class_3","tbody","AnimBox","class_4","background","border-radius","Anim","class_5","TreeLeaf","class_6","TreeNode","class_7","Tree","class_8","Main","class_9","route","uibench","init","querySelector","samples","JSON","stringify"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { CSSStyleProps, NOOP } from \"ivi-core\";\nimport { EventHandler } from \"ivi-events\";\nimport { checkDOMAttributesForTypos, checkDOMStylesForTypos, checkDeprecatedDOMSVGAttributes } from \"../dev_mode/typos\";\nimport { VNodeFlags } from \"./flags\";\nimport { StatelessComponent, StatefulComponent, Component } from \"./component\";\nimport { ConnectDescriptor } from \"./connect_descriptor\";\n\n/**\n * Virtual DOM Node.\n *\n *     const vnode = h.div(\"div-class-name\")\n *       .a({ id: \"div-id\" })\n *       .e(Events.onClick((e) => console.log(\"click event\", e)))\n *       .c(\"Hello\");\n *\n * @final\n */\nexport class VNode<P = any, N = Node> {\n  /**\n   * Flags, see `VNodeFlags` for details.\n   */\n  flags: VNodeFlags;\n  /**\n   * Circular link to previous sibling node.\n   */\n  prev: VNode;\n  /**\n   * Next sibling node.\n   */\n  next: VNode | null;\n  /**\n   * Children.\n   */\n  children: VNode | string | number | boolean | null;\n  /**\n   * Tag property contains details about the type of the element.\n   */\n  tag:\n    | string\n    | VNode\n    | StatefulComponent<any>\n    | StatelessComponent<any>\n    | ConnectDescriptor<any, any, {}>\n    | null;\n  /**\n   * Children syncing algorithm is using key property to match nodes. Key should be unique among its siblings.\n   */\n  key: any;\n  /**\n   * Properties.\n   */\n  props: P | undefined;\n  /**\n   * Reference to HTML node or Component instance.\n   *\n   * It will be available after virtual node is created or synced. Each time VNode is synced, reference will be\n   * transferred from the old VNode to the new one.\n   */\n  instance: N | Component<any> | {} | null;\n  /**\n   * Class name.\n   */\n  className: string | undefined;\n  /**\n   * Style.\n   */\n  style: CSSStyleProps | null;\n  /**\n   * Events.\n   */\n  events: Array<EventHandler | null> | EventHandler | null;\n  /**\n   * Factory function that was used to instantiate this node.\n   *\n   * It is used for debugging and testing purposes.\n   */\n  factory!: Function;\n\n  constructor(\n    flags: number,\n    tag:\n      | string\n      | VNode\n      | StatelessComponent<P>\n      | StatefulComponent<P>\n      | ConnectDescriptor<any, any, {}>\n      | null,\n    props: P | undefined,\n    className: string | undefined,\n    children:\n      | VNode\n      | string\n      | number\n      | boolean\n      | null,\n  ) {\n    this.flags = flags;\n    this.prev = this;\n    this.next = null;\n    this.children = children;\n    this.tag = tag;\n    this.key = 0;\n    this.props = props;\n    this.instance = null;\n    this.className = className;\n    this.style = null;\n    this.events = null;\n    if (DEBUG) {\n      this.factory = NOOP;\n    }\n  }\n\n  /**\n   * k assigns a key.\n   *\n   * Children reconciliation algorithm is using keys to match nodes. Key should be unique among its siblings.\n   *\n   * @param key Any object that should be unique among its siblings.\n   * @returns VNode\n   */\n  k(key: any): this {\n    this.flags |= VNodeFlags.Key;\n    this.key = key;\n    return this;\n  }\n\n  /**\n   * s assigns style for an Element node.\n   *\n   * @param style Style.\n   * @returns VNode\n   */\n  s<U extends CSSStyleProps>(style: U | null): this {\n    if (DEBUG) {\n      if (!(this.flags & VNodeFlags.Element)) {\n        throw new Error(\"Failed to set style, style is available on element nodes only.\");\n      }\n\n      if (style !== null) {\n        checkDOMStylesForTypos(style);\n      }\n    }\n    this.style = style;\n    return this;\n  }\n\n  /**\n   * e assign events for an Element node.\n   *\n   * @param events Events.\n   * @returns VNode\n   */\n  e(events: Array<EventHandler | null> | EventHandler | null): this {\n    if (DEBUG) {\n      if (!(this.flags & VNodeFlags.Element)) {\n        throw new Error(\"Failed to set events, events are available on element nodes only.\");\n      }\n    }\n    this.flags |= VNodeFlags.ElementPropsEvents;\n    this.events = events;\n    return this;\n  }\n\n  /**\n   * a assigns DOM attributes for an Element node.\n   *\n   * @param attrs DOM attributes.\n   * @returns VNode\n   */\n  a(attrs: P | null): this {\n    if (DEBUG) {\n      if (!(this.flags & VNodeFlags.Element)) {\n        throw new Error(\"Failed to set attrs, attrs are available on element nodes only.\");\n      }\n\n      if (attrs) {\n        checkDOMAttributesForTypos(attrs);\n\n        if (this.flags & VNodeFlags.SvgElement) {\n          checkDeprecatedDOMSVGAttributes(this.tag as string, attrs);\n        }\n      }\n    }\n    this.props = attrs as P;\n    return this;\n  }\n\n  /**\n   * c assigns children for an Element node.\n   *\n   * @param children Children can be a simple string, single VNode or recursive list of VNodes with strings and null\n   *   values. It will automatically normalize recursive lists by flattening, filtering out null values and replacing\n   *   strings with text nodes.\n   * @returns VNode\n   */\n  c(...children: Array<VNode | string | number | null>): this;\n  c(): this {\n    if (DEBUG) {\n      if (this.flags & (VNodeFlags.ChildrenVNode | VNodeFlags.UnsafeHTML)) {\n        throw new Error(\"Failed to set children, VNode element is already having children.\");\n      }\n      if (!(this.flags & VNodeFlags.Element)) {\n        throw new Error(\"Failed to set children, children are available on element nodes only.\");\n      }\n      if (this.flags & VNodeFlags.InputElement) {\n        throw new Error(\"Failed to set children, input elements can't have children.\");\n      }\n      if (this.flags & VNodeFlags.TextAreaElement) {\n        throw new Error(\"Failed to set children, textarea elements can't have children.\");\n      }\n      if (this.flags & VNodeFlags.MediaElement) {\n        throw new Error(\"Failed to set children, media elements can't have children.\");\n      }\n      if (this.flags & VNodeFlags.VoidElement) {\n        throw new Error(`Failed to set children, ${this.tag} elements can't have children.`);\n      }\n    }\n\n    const children: Array<VNode | string | number | null> = arguments as any;\n    let first: VNode<any> | null = null;\n    let prev: VNode<any> | null = null;\n\n    for (let i = 0, p = 0; i < children.length; ++i, ++p) {\n      let n = children[i];\n\n      if (n !== null) {\n        if (typeof n !== \"object\") {\n          n = new VNode<null>(VNodeFlags.Text, null, null, void 0, n);\n        }\n        const last = n.prev;\n        const flags = n.flags;\n        if (last === n) {\n          if ((flags & VNodeFlags.Key) === 0) {\n            n.key = p;\n          }\n        } else if ((flags & VNodeFlags.KeyedList) === 0) {\n          let c: VNode | null = n;\n          do {\n            if ((c!.flags & VNodeFlags.Key) === 0) {\n              c!.key = p;\n            }\n            ++p;\n            c = c!.next;\n          } while (c !== null);\n          --p;\n        }\n\n        if (prev !== null) {\n          n.prev = prev;\n          prev.next = n;\n        } else {\n          first = n;\n        }\n        prev = last;\n      }\n    }\n    if (first !== null) {\n      first.prev = prev!;\n      this.flags |= VNodeFlags.ChildrenVNode;\n      this.children = first;\n      if (DEBUG) {\n        checkUniqueKeys(first);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * unsafeHTML assigns children as an innerHTML string. It is potentially vulnerable to XSS attacks.\n   *\n   * @param html innerHTML in a string format.\n   * @returns VNode\n   */\n  unsafeHTML(html: string | null): this {\n    if (DEBUG) {\n      if (this.flags & VNodeFlags.ChildrenVNode) {\n        throw new Error(\"Failed to set unsafeHTML, VNode element is already having children.\");\n      }\n      if (!(this.flags & VNodeFlags.Element)) {\n        throw new Error(\"Failed to set unsafeHTML, unsafeHTML is available on element nodes only.\");\n      }\n      if (this.flags & VNodeFlags.InputElement) {\n        throw new Error(\"Failed to set unsafeHTML, input elements can't have innerHTML.\");\n      }\n      if (this.flags & VNodeFlags.TextAreaElement) {\n        throw new Error(\"Failed to set unsafeHTML, textarea elements can't have innerHTML.\");\n      }\n      if (this.flags & VNodeFlags.MediaElement) {\n        throw new Error(\"Failed to set unsafeHTML, media elements can't have children.\");\n      }\n      if (this.flags & VNodeFlags.VoidElement) {\n        throw new Error(`Failed to set unsafeHTML, ${this.tag} elements can't have children.`);\n      }\n    }\n    this.flags |= VNodeFlags.UnsafeHTML;\n    this.children = html;\n    return this;\n  }\n\n  /**\n   * value assigns value for an HTMLInputElement and HTMLTextAreaElement elements.\n   *\n   * @param value input value.\n   * @returns VNode\n   */\n  value(value: string | boolean | null): this {\n    if (DEBUG) {\n      if (!(this.flags & (VNodeFlags.InputElement | VNodeFlags.TextAreaElement))) {\n        throw new Error(\"Failed to set value, value is available on input and textarea elements only.\");\n      }\n    }\n    this.children = value;\n    return this;\n  }\n}\n\nexport type Children = Array<VNode[] | VNode | string | number | null>;\n\n/**\n * getDOMInstanceFromVNode retrieves a reference to a DOM node from a VNode object.\n *\n * @param node VNode which contains reference to a DOM node.\n * @returns null if VNode doesn't have a reference to a DOM node.\n */\nexport function getDOMInstanceFromVNode<T extends Node>(node: VNode<any, T>): T | null {\n  if ((node.flags & (\n    VNodeFlags.StatelessComponent |\n    VNodeFlags.StatefulComponent |\n    VNodeFlags.Connect |\n    VNodeFlags.UpdateContext\n  )) !== 0) {\n    return getDOMInstanceFromVNode<T>(node.children as VNode<any, T>);\n  }\n  return node.instance as T;\n}\n\n/**\n * getComponentInstanceFromVNode retrieves a reference to a Component instance from a VNode object.\n *\n * @param node VNode which contains reference to a Component instance.\n * @returns null if VNode doesn't have a reference to a Component instance.\n */\nexport function getComponentInstanceFromVNode<T extends Component<any>>(node: VNode): T | null {\n  if (DEBUG) {\n    if ((node.flags & (\n      VNodeFlags.StatelessComponent |\n      VNodeFlags.StatefulComponent |\n      VNodeFlags.Connect |\n      VNodeFlags.UpdateContext\n    )) === 0) {\n      throw new Error(\"Failed to get component instance: VNode should represent a Component.\");\n    }\n  }\n  return node.instance as T | null;\n}\n\n/**\n * autofocus makes an element focused after instantiation.\n *\n * @param focus\n * @return VNode\n */\nexport function autofocus<N extends VNode>(node: N): N {\n  if (DEBUG) {\n    if (!(node.flags & (\n      VNodeFlags.Element |\n      VNodeFlags.StatelessComponent |\n      VNodeFlags.StatefulComponent |\n      VNodeFlags.Connect |\n      VNodeFlags.UpdateContext\n    ))) {\n      throw new Error(\"Failed to set autofocus, autofocus is available on element and component nodes only.\");\n    }\n  }\n  node.flags |= VNodeFlags.Autofocus;\n  return node;\n}\n\n/**\n * stopDirtyChecking stops dirty checking process when it goes through this node.\n *\n * @param node VNode.\n * @returns VNode.\n */\nexport function stopDirtyChecking<N extends VNode>(node: N): N {\n  node.flags |= VNodeFlags.StopDirtyChecking;\n  return node;\n}\n\n/**\n * checkUniqueKeys checks that all nodes have unique keys.\n *\n * @param children Children collection.\n */\nfunction checkUniqueKeys(children: VNode): void {\n  let keys: Set<any> | undefined;\n  let node: VNode<any> | null = children;\n  while (node !== null) {\n    if (node.flags & VNodeFlags.Key) {\n      if (keys === undefined) {\n        keys = new Set<any>();\n      } else if (keys.has(node.key)) {\n        throw new Error(`Failed to set children, invalid children list, key: \"${node.key}\" is used multiple times.`);\n      }\n      keys.add(node.key);\n    }\n    node = node.next;\n  }\n}\n","import { VNodeFlags } from \"./flags\";\nimport { VNode } from \"./vnode\";\n\n/**\n * fragment is a variadic function that creates a children collection.\n *\n *     const content = children(\n *       h.p().c(\"Paragraph 1\"),\n *       h.p().c(\"Paragraph 2\"),\n *     );\n *\n *     render(\n *       h.div().c(\n *         h.h1().c(\"Title\"),\n *         content,\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param args children.\n * @returns children collection.\n */\nexport function fragment(...args: Array<VNode | string | number | null>): VNode | null;\n\n/**\n * fragment is a variadic function that creates a children collection.\n *\n *     const content = children(\n *       h.p().c(\"Paragraph 1\"),\n *       h.p().c(\"Paragraph 2\"),\n *     );\n *\n *     render(\n *       h.div().c(\n *         h.h1().c(\"Title\"),\n *         content,\n *       ),\n *       DOMContainer,\n *     );\n *\n * @returns children collection.\n */\nexport function fragment(): VNode | null {\n  const args: Array<VNode | string | number | null> = arguments as any;\n  let first: VNode<any> | null = null;\n  let prev: VNode<any> | null = null;\n\n  for (let i = 0; i < args.length; ++i) {\n    let n = args[i];\n\n    if (n !== null) {\n      if (typeof n !== \"object\") {\n        n = new VNode<null>(VNodeFlags.Text, null, null, void 0, n);\n      }\n      const last = n.prev;\n      if (prev !== null) {\n        n.prev = prev;\n        prev.next = n;\n      } else {\n        first = n;\n      }\n      prev = last;\n    }\n  }\n  if (first !== null) {\n    first.prev = prev!;\n  }\n\n  return first;\n}\n\n/**\n * map creates a children collection with the results of calling a provided function on every element in the calling\n * array.\n *\n *     render(\n *       h.div().c(\n *         map([1, 2, 3], (item) => h.div().k(item)),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param items Array.\n * @param fn Function that produces an element for the children collection.\n */\nexport function map<T, U>(array: Array<T>, fn: (item: T, index: number) => VNode<U> | null): VNode<U> | null {\n  if (array.length) {\n    let first: VNode<any> | null = null;\n    let prev: VNode<any> | null = null;\n    for (let i = 0; i < array.length; ++i) {\n      const n = fn(array[i], i);\n      if (n !== null) {\n        /* istanbul ignore else */\n        if (DEBUG) {\n          if ((n.flags & VNodeFlags.Key) === 0) {\n            throw new Error(`VNodes created with a map() function should have an explicit key`);\n          }\n          if (n.prev !== n) {\n            throw new Error(`VNodes created with a map() function should be a singular nodes`);\n          }\n        }\n        if (prev !== null) {\n          n.prev = prev;\n          prev.next = n;\n        } else {\n          first = n;\n        }\n        prev = n;\n      }\n    }\n    if (first !== null) {\n      first.prev = prev!;\n      first.flags |= VNodeFlags.KeyedList;\n      return first;\n    }\n  }\n  return null;\n}\n\n/**\n * mapRange creates a children collection with the results of calling a provided function on every number in the\n * provided range.\n *\n *     const items = [1, 2, 3];\n *\n *     render(\n *       h.div().c(\n *         mapRange(0, items.length, (i) => h.div().k(items[i])),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param start Range start.\n * @param end Range end.\n * @param fn Function that produces an element for the children collection.\n */\nexport function mapRange<T>(start: number, end: number, fn: (idx: number) => VNode<T> | null): VNode<T> | null {\n  const length = end - start;\n  if (length) {\n    let first: VNode<any> | null = null;\n    let prev: VNode<any> | null = null;\n    do {\n      const n = fn(start++);\n      if (n !== null) {\n        /* istanbul ignore else */\n        if (DEBUG) {\n          if ((n.flags & VNodeFlags.Key) === 0) {\n            throw new Error(`VNodes created with a mapRange() function should have an explicit key`);\n          }\n          if (n.prev !== n) {\n            throw new Error(`VNodes created with a mapRange() function should be a singular nodes`);\n          }\n        }\n        if (prev !== null) {\n          n.prev = prev;\n          prev.next = n;\n        } else {\n          first = n;\n        }\n        prev = n;\n      }\n    } while (start < length);\n    if (first !== null) {\n      first.prev = prev!;\n      first.flags |= VNodeFlags.KeyedList;\n      return first;\n    }\n  }\n  return null;\n}\n","/**\n * NOOP function.\n */\nexport function NOOP(): void {\n  /* tslint:disable:no-empty */\n  /* tslint:enable:no-empty */\n}\n\n/**\n * NOOP_FALSE function always returns `false` value.\n *\n * @returns `false` value.\n */\nexport function NOOP_FALSE(): boolean {\n  return false;\n}\n","const _errorHandlers: Array<(e: any) => void> = [];\n\n/**\n * addErrorHandler adds an error handler for errors catched by functions decorated with `catchError()`.\n *\n * @param handler error handler.\n */\nexport function addErrorHandler(handler: (e: any) => void): void {\n  _errorHandlers.push(handler);\n}\n\nexport function catchError(fn: (...args: any[]) => void): (...args: any[]) => any;\n/**\n * catchError is a decorator that catches exceptions and invokes error handlers registered with `addErrorHandler()`.\n *\n * @noinline\n * @throws\n * @param fn function to decorate.\n * @returns function decorated with a catchError.\n */\nexport function catchError(fn: () => void): () => any {\n  return function () {\n    try {\n      return fn.apply(null, arguments);\n    } catch (e) {\n      for (let i = 0; i < _errorHandlers.length; ++i) {\n        _errorHandlers[i](e);\n      }\n      throw e;\n    }\n  };\n}\n","/**\n * append pushes item to an array and automatically create a new array when it doesn't exist.\n *\n * @param array Array\n * @param item Item\n * @returns Array\n */\nexport function append<T>(array: T[] | null, item: T): T[] {\n  if (array === null) {\n    return [item];\n  }\n  array.push(item);\n  return array;\n}\n\n/**\n * unorderedArrayDelete deletes element from an array with O(1) complexity.\n *\n * It swaps element at `index` position with the last element and removes the last one.\n *\n * @param array Array\n * @param index Index of an element to remove\n */\nexport function unorderedArrayDelete<T>(array: T[], index: number): void {\n  const length = array.length - 1;\n  const last = array.pop();\n  if (index !== length) {\n    array[index] = last!;\n  }\n}\n","import { unorderedArrayDelete } from \"./array\";\n\n/**\n * RepeatableTaskList is a data structure for tasks that will be repeated until they return `true` value.\n */\nexport type RepeatableTaskList = Array<() => boolean | undefined>;\n\n/**\n * runRepeatableTasks runs repeatable tasks.\n *\n * @param tasks repeatable tasks.\n */\nexport function runRepeatableTasks(tasks: RepeatableTaskList): void {\n  for (let i = 0; i < tasks.length; ++i) {\n    if (tasks[i]() === true) {\n      unorderedArrayDelete(tasks, i--);\n    }\n  }\n}\n","import { RepeatableTaskList, runRepeatableTasks, NOOP, unorderedArrayDelete, catchError } from \"ivi-core\";\n\n/**\n * Scheduler flags.\n */\nconst enum SchedulerFlags {\n  Hidden = 1,\n  VisibilityObserversCOW = 1 << 1,\n  MicrotaskPending = 1 << 2,\n  TaskPending = 1 << 3,\n  NextFramePending = 1 << 4,\n  CurrentFrameReady = 1 << 5,\n}\n\n/**\n * Frame Tasks Group flags.\n */\nconst enum FrameTasksGroupFlags {\n  /**\n   * Group contains update task.\n   */\n  Update = 1,\n  /**\n   * Group contains \"write\" tasks.\n   */\n  Write = 1 << 1,\n  /**\n   * Group contains \"read\" tasks\".\n   */\n  Read = 1 << 2,\n  /**\n   * Group contains \"after\" tasks.\n   */\n  After = 1 << 3,\n}\n\ninterface TaskList {\n  tasks: Array<() => void>;\n}\n\nfunction createTaskList(): TaskList {\n  return { tasks: [] };\n}\n\nfunction run(t: TaskList) {\n  const tasks = t.tasks;\n  t.tasks = [];\n  for (let i = 0; i < tasks.length; ++i) {\n    tasks[i]();\n  }\n}\n\n/**\n * FrameTasksGroup contains tasks for read and write DOM tasks, and tasks that should be executed after all other tasks\n * are finished.\n *\n * @final\n */\ninterface FrameTasksGroup {\n  /**\n   * See `FrameTasksGroupFlags` for details.\n   */\n  flags: number;\n  /**\n   * Write DOM task queue.\n   */\n  write: TaskList;\n  /**\n   * Read DOM task queue.\n   */\n  read: TaskList;\n  /**\n   * Tasks that should be executed when all other frame tasks are finished.\n   */\n  after: TaskList;\n}\n\nfunction createFrameTasksGroup(): FrameTasksGroup {\n  return {\n    flags: 0,\n    write: createTaskList(),\n    read: createTaskList(),\n    after: createTaskList(),\n  };\n}\n\nlet _flags: SchedulerFlags = 0;\nlet _clock = 0;\nconst _microtasks = createTaskList();\nconst _tasks = createTaskList();\n\nlet _visibilityObservers: Array<(hidden: boolean) => void> = [];\nlet _isHidden: () => boolean;\n\nconst _animations: RepeatableTaskList = [];\nconst _readers: RepeatableTaskList = [];\nlet _updateDOMHandler: () => void = NOOP;\nlet _currentFrame = createFrameTasksGroup();\nlet _nextFrame = createFrameTasksGroup();\nlet _currentFrameStartTime = 0;\nlet _autofocusedElement: Element | null = null;\n\nconst runMicrotasks = catchError(() => {\n  while (_microtasks.tasks.length > 0) {\n    run(_microtasks);\n  }\n\n  _flags ^= SchedulerFlags.MicrotaskPending;\n  ++_clock;\n});\n\n// Task scheduler based on MessageChannel\nconst _taskChannel = new MessageChannel();\n_taskChannel.port1.onmessage = catchError((ev: MessageEvent) => {\n  _flags ^= SchedulerFlags.TaskPending;\n  run(_tasks);\n  ++_clock;\n});\n\nconst handleVisibilityChange = catchError(() => {\n  const newHidden = _isHidden();\n  if (((_flags & SchedulerFlags.Hidden) !== 0) !== newHidden) {\n    _flags ^= SchedulerFlags.Hidden | SchedulerFlags.VisibilityObserversCOW;\n\n    if (newHidden === false && _animations.length > 0) {\n      requestNextFrame();\n    }\n\n    const observers = _visibilityObservers;\n    for (let i = 0; i < observers.length; ++i) {\n      observers[i](newHidden);\n    }\n    _flags ^= SchedulerFlags.VisibilityObserversCOW;\n  }\n});\n\nif (TARGET !== \"browser\" || typeof document[\"hidden\"] !== \"undefined\") {\n  _isHidden = function () {\n    return document.hidden;\n  };\n  document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n} else if (typeof (document as any)[\"webkitHidden\"] !== \"undefined\") {\n  /**\n   * #quirks\n   *\n   * Android 4.4\n   */\n  _isHidden = function () {\n    return (document as any)[\"webkitHidden\"];\n  };\n  document.addEventListener(\"webkitvisibilitychange\", handleVisibilityChange);\n} else {\n  _isHidden = function () {\n    return true;\n  };\n}\nif (_isHidden() === true) {\n  _flags |= SchedulerFlags.Hidden;\n}\n\n/**\n * clock returns monotonically increasing clock value.\n *\n * @returns current clock value.\n */\nexport function clock(): number {\n  return _clock;\n}\n\n/**\n * scheduleMicrotask adds task to the microtask queue.\n *\n * @param task Microtask.\n */\nexport function scheduleMicrotask(task: () => void): void {\n  if (!(_flags & SchedulerFlags.MicrotaskPending)) {\n    _flags |= SchedulerFlags.MicrotaskPending;\n    Promise.resolve().then(runMicrotasks);\n  }\n  _microtasks.tasks.push(task);\n}\n\n/**\n * scheduleTask adds task to the task queue.\n *\n * @param task Task.\n */\nexport function scheduleTask(task: () => void): void {\n  if (!(_flags & SchedulerFlags.TaskPending)) {\n    _flags |= SchedulerFlags.TaskPending;\n    _taskChannel.port2.postMessage(0);\n  }\n  _tasks.tasks.push(task);\n}\n\nexport function isHidden(): boolean {\n  return (_flags & SchedulerFlags.Hidden) !== 0;\n}\n\nexport function addVisibilityObserver(observer: (visible: boolean) => void): void {\n  if (_flags & SchedulerFlags.VisibilityObserversCOW) {\n    _visibilityObservers = _visibilityObservers.slice();\n  }\n  _visibilityObservers.push(observer);\n}\n\nexport function removeVisibilityObserver(observer: (visible: boolean) => void): void {\n  if (_flags & SchedulerFlags.VisibilityObserversCOW) {\n    _visibilityObservers = _visibilityObservers.slice();\n  }\n  const index = _visibilityObservers.indexOf(observer);\n  if (index > -1) {\n    unorderedArrayDelete(_visibilityObservers, index);\n  }\n}\n\nexport function setUpdateDOMHandler(handler: () => void): void {\n  _updateDOMHandler = handler;\n}\n\n/**\n * addAnimation adds animation to the RepeatableTaskList.\n *\n * @param animation Animation task.\n */\nexport function addAnimation(animation: () => boolean | undefined): void {\n  _animations.push(animation);\n  requestNextFrame();\n}\n\n/**\n * addDOMReader adds DOM Reader to the RepeatableTaskList.\n *\n * DOM Reader will be be invoked on each frame in the read phase.\n *\n * @param reader Task that will be executed until it returns `false`.\n */\nexport function addDOMReader(reader: () => boolean | undefined): void {\n  _readers.push(reader);\n}\n\nexport function autofocus(node: Node): void {\n  if (node instanceof Element) {\n    _autofocusedElement = node;\n  }\n}\n\n/**\n * frameStartTime returns current frame start time.\n *\n * @returns current frame start time.\n */\nexport function currentFrameStartTime(): number {\n  return _currentFrameStartTime;\n}\n\nfunction _updateCurrentFrameStartTime(time?: number): void {\n  _currentFrameStartTime = (time === undefined ? performance.now() : time) / 1000;\n}\n\n_updateCurrentFrameStartTime();\n\nfunction _requestNextFrame(): void {\n  if (_flags & SchedulerFlags.NextFramePending) {\n    requestAnimationFrame(_handleNextFrame);\n  }\n}\n\n/**\n * requestNextFrame triggers next frame tasks execution.\n */\nexport function requestNextFrame(): void {\n  if (!(_flags & SchedulerFlags.NextFramePending)) {\n    _flags |= SchedulerFlags.NextFramePending;\n    scheduleMicrotask(_requestNextFrame);\n  }\n}\n\n/**\n * Frame tasks scheduler event handler.\n *\n * @param t Current time.\n */\nconst _handleNextFrame = catchError((time?: number) => {\n  _flags ^= SchedulerFlags.NextFramePending | SchedulerFlags.CurrentFrameReady;\n\n  _updateCurrentFrameStartTime(time);\n\n  const frame = _nextFrame;\n  _nextFrame = _currentFrame;\n  _currentFrame = frame;\n\n  runRepeatableTasks(_readers);\n\n  // Perform read/write batching. Start with executing read DOM tasks, then update components, execute write DOM tasks\n  // and repeat until all read and write tasks are executed.\n  do {\n    while (frame.flags & FrameTasksGroupFlags.Read) {\n      frame.flags ^= FrameTasksGroupFlags.Read;\n      run(frame.read);\n    }\n\n    while (frame.flags & (FrameTasksGroupFlags.Update | FrameTasksGroupFlags.Write)) {\n      if (frame.flags & FrameTasksGroupFlags.Write) {\n        frame.flags ^= FrameTasksGroupFlags.Write;\n        run(frame.write);\n      }\n\n      if (frame.flags & FrameTasksGroupFlags.Update) {\n        frame.flags ^= FrameTasksGroupFlags.Update;\n        _updateDOMHandler();\n      }\n    }\n  } while (frame.flags & (\n    FrameTasksGroupFlags.Update |\n    FrameTasksGroupFlags.Write |\n    FrameTasksGroupFlags.Read\n  ));\n\n  _flags ^= SchedulerFlags.CurrentFrameReady;\n\n  if (!(_flags & SchedulerFlags.Hidden)) {\n    runRepeatableTasks(_animations);\n  }\n\n  // Perform tasks that should be executed when all DOM ops are finished.\n  while ((frame.flags & FrameTasksGroupFlags.After)) {\n    frame.flags ^= FrameTasksGroupFlags.After;\n    run(frame.after);\n  }\n\n  if (_autofocusedElement !== null) {\n    (_autofocusedElement as HTMLElement).focus();\n    _autofocusedElement = null;\n  }\n\n  if (_animations.length) {\n    requestNextFrame();\n  }\n\n  ++_clock;\n});\n\nfunction addFrameTaskUpdate(frame: FrameTasksGroup): void {\n  frame.flags |= FrameTasksGroupFlags.Update;\n}\n\nfunction addFrameTaskWrite(frame: FrameTasksGroup, task: () => void): void {\n  frame.flags |= FrameTasksGroupFlags.Write;\n  frame.write.tasks.push(task);\n}\n\nfunction addFrameTaskRead(frame: FrameTasksGroup, task: () => void): void {\n  frame.flags |= FrameTasksGroupFlags.Read;\n  frame.read.tasks.push(task);\n}\n\nfunction addFrameTaskAfter(frame: FrameTasksGroup, task: () => void): void {\n  frame.flags |= FrameTasksGroupFlags.After;\n  frame.after.tasks.push(task);\n}\n\nexport function nextFrameUpdate(): void {\n  requestNextFrame();\n  addFrameTaskUpdate(_nextFrame);\n}\n\nexport function nextFrameWrite(task: () => void): void {\n  requestNextFrame();\n  addFrameTaskWrite(_nextFrame, task);\n}\n\nexport function nextFrameRead(task: () => void): void {\n  requestNextFrame();\n  addFrameTaskRead(_nextFrame, task);\n}\n\nexport function nextFrameAfter(task: () => void): void {\n  requestNextFrame();\n  addFrameTaskAfter(_nextFrame, task);\n}\n\nexport function currentFrameUpdate(): void {\n  if (_flags & SchedulerFlags.CurrentFrameReady) {\n    addFrameTaskUpdate(_currentFrame);\n  } else {\n    nextFrameUpdate();\n  }\n}\n\nexport function currentFrameWrite(task: () => void): void {\n  if (_flags & SchedulerFlags.CurrentFrameReady) {\n    addFrameTaskWrite(_currentFrame, task);\n  } else {\n    nextFrameWrite(task);\n  }\n}\n\nexport function currentFrameRead(task: () => void): void {\n  if (_flags & SchedulerFlags.CurrentFrameReady) {\n    addFrameTaskRead(_currentFrame, task);\n  } else {\n    nextFrameRead(task);\n  }\n}\n\nexport function currentFrameAfter(task: () => void): void {\n  if (_flags & SchedulerFlags.CurrentFrameReady) {\n    addFrameTaskAfter(_currentFrame, task);\n  } else {\n    nextFrameAfter(task);\n  }\n}\n\n/**\n * triggerNextFrame triggers an update for the next frame.\n */\nexport function triggerNextFrame(): void {\n  if (_flags & SchedulerFlags.NextFramePending) {\n    _handleNextFrame();\n  }\n}\n","import { currentFrameUpdate } from \"ivi-scheduler\";\nimport { ComponentFlags } from \"./flags\";\nimport { VNode } from \"./vnode\";\n\n/**\n * Stateless Component descriptor.\n */\nexport interface StatelessComponent<P = undefined> {\n  render: (props: P) => VNode;\n  shouldUpdate: ((oldProps: P, newProps: P) => boolean) | null;\n}\n\n/**\n * Stateful Component class interface.\n */\nexport interface StatefulComponent<P = undefined> {\n  new(props: P): Component<P>;\n}\n\n/**\n * Component is a base class for stateful components.\n *\n * Component class has a parametric type `P` to specify `props` type.\n *\n * Example:\n *\n *     const Hello = component(class extends Component<string> {\n *       render() {\n *         return h.t(`Hello ${this.props}`);\n *       }\n *     });\n *\n *     render(Hello(\"world\"), document.getElementById(\"App\")!);\n */\nexport abstract class Component<P = undefined> {\n  /**\n   * Flags, see `ComponentFlags` for details.\n   */\n  flags: ComponentFlags;\n  /**\n   * Component properties.\n   */\n  props: P;\n\n  constructor(props: P) {\n    this.flags = 0;\n    this.props = props;\n  }\n\n  /**\n   * Lifecycle method `newPropsReceived` is invoked after new props are assigned.\n   *\n   * @param oldProps Old props.\n   * @param newProps New props.\n   */\n  newPropsReceived(oldProps: P, newProps: P): void {\n    /* tslint:disable:no-empty */\n    /* tslint:enable:no-empty */\n  }\n\n  /**\n   * Lifecycle method `attached` is invoked when component is attached to the document.\n   */\n  attached(): void {\n    /* tslint:disable:no-empty */\n    /* tslint:enable:no-empty */\n  }\n\n  /**\n   * Lifecycle method `detached` is invoked when component is detached from the document.\n   */\n  detached(): void {\n    /* tslint:disable:no-empty */\n    /* tslint:enable:no-empty */\n  }\n\n  /**\n   * Lifecycle method `shouldUpdate` is used as a hint to reduce unnecessary updates.\n   *\n   * @param oldProps Old props.\n   * @param newProps New props.\n   * @returns `true` when changes in props should trigger update.\n   */\n  shouldUpdate(oldProps: P, newProps: P): boolean {\n    return oldProps !== newProps;\n  }\n\n  /**\n   * Lifecycle method `updated` is invoked after update.\n   *\n   * @param local `true` when update was caused by local changes.\n   */\n  updated(local: boolean): void {\n    /* tslint:disable:no-empty */\n    /* tslint:enable:no-empty */\n  }\n\n  /**\n   * Lifecycle method `invalidated` is invoked after `invalidate` method is invoked.\n   */\n  invalidated(): void {\n    /* tslint:disable:no-empty */\n    /* tslint:enable:no-empty */\n  }\n\n  abstract render(): VNode;\n\n  /**\n   * Invalidate view.\n   */\n  invalidate(): void {\n    this.flags |= ComponentFlags.DirtyState;\n    this.invalidated();\n    if ((this.flags & ComponentFlags.Detached) === 0) {\n      currentFrameUpdate();\n    }\n  }\n}\n\n/**\n * isComponentAttached returns `true` when component is attached.\n *\n * @returns `true` when component is attached.\n */\nexport function isComponentAttached(component: Component<any>): boolean {\n  return (component.flags & ComponentFlags.Detached) === 0;\n}\n","import { VNodeFlags } from \"./flags\";\nimport { StatefulComponent, StatelessComponent } from \"./component\";\nimport { VNode } from \"./vnode\";\nimport { ConnectDescriptor } from \"./connect_descriptor\";\n\n/**\n * statelessComponent creates a virtual DOM node factory that produces nodes for stateless components.\n *\n *     const A = statelessComponent<{ text: string }>(\n *       (props) => h.div().c(props.text),\n *     );\n *\n *     render(\n *       A({ text: \"Hello\" }),\n *       DOMContainer,\n *     );\n *\n * @param render render function.\n * @returns factory that produces stateless component nodes.\n */\nexport function statelessComponent(c: () => VNode): () => VNode<undefined>;\n\n/**\n * statelessComponent creates a virtual DOM node factory that produces nodes for stateless components.\n *\n *     const A = statelessComponent<{ text: string }>(\n *       (props) => h.div().c(props.text),\n *     );\n *\n *     render(\n *       A({ text: \"Hello\" }),\n *       DOMContainer,\n *     );\n *\n * @param render render function.\n * @returns factory that produces stateless component nodes.\n */\nexport function statelessComponent<P>(\n  render: undefined extends P ? (props?: P) => VNode<any> : (props: P) => VNode<any>,\n): undefined extends P ? (props?: P) => VNode<P> : (props: P) => VNode<P>;\n\n/**\n * statelessComponent creates a virtual DOM node factory that produces nodes for stateless components.\n *\n *     const A = statelessComponent<{ text: string }>(\n *       (props) => h.div().c(props.text),\n *     );\n *\n *     render(\n *       A({ text: \"Hello\" }),\n *       DOMContainer,\n *     );\n *\n * @param render render function.\n * @returns factory that produces stateless component nodes.\n */\nexport function statelessComponent<P>(render: (props: P) => VNode<any>): (props: P) => VNode<P> {\n  const d = { render, shouldUpdate: null };\n  const f = function (props: P): VNode<P> {\n    const n = new VNode<P>(\n      VNodeFlags.StatelessComponent,\n      d,\n      props,\n      void 0,\n      null,\n    );\n    /* istanbul ignore else */\n    if (DEBUG) {\n      n.factory = f;\n    }\n    return n;\n  };\n  return f;\n}\n\n/**\n * withShouldUpdate creates a virtual DOM node factory that produces nodes for stateless components with custom\n * `shouldUpdate` function to prevent unnecessary updates.\n *\n *     const A = withShouldUpdate<{ text: string }>(\n *       (prevProps, nextProps) => prevProps.text !== nextProps.text,\n *       statelessComponent(\n *         (props) => h.div().c(props.text),\n *       ),\n *     );\n *\n *     render(\n *       A({ text: \"Hello\" }),\n *       DOMContainer,\n *     );\n *\n * @param shouldUpdate function that performs an early check that prevent unnecessary updates.\n * @param factory factory that produces stateless component nodes.\n * @returns factory that produces stateless component nodes.\n */\nexport function withShouldUpdate<P>(\n  shouldUpdate: (oldProps: P, newProps: P) => boolean,\n  factory: (props: P) => VNode<P>,\n): (props: P) => VNode<P> {\n  const v = factory(null as any);\n  const d = { render: (v.tag as StatelessComponent<P>).render, shouldUpdate };\n  const f = function (props: P): VNode<P> {\n    const n = new VNode<P>(\n      VNodeFlags.StatelessComponent | VNodeFlags.ShouldUpdateHint,\n      d,\n      props,\n      void 0,\n      null,\n    );\n    /* istanbul ignore else */\n    if (DEBUG) {\n      n.factory = f;\n    }\n    return n;\n  };\n  return f;\n}\n\n/**\n * statefulComponent creates a virtual DOM node factory that produces nodes for stateful components.\n *\n *     const A = component(class extends Component<string> {\n *       onClick = Events.onClick(() => console.log(this.props));\n *\n *       render() {\n *         return (\n *           h.button()\n *             .e(this.onClick)\n *             .c(\"Click Me\")\n *         );\n *       }\n *     });\n *\n *     render(\n *       A(\"clicked\"),\n *       DOMContainer,\n *     );\n *\n * @param c stateful component.\n * @returns factory that produces stateful component nodes.\n */\nexport function statefulComponent(c: StatefulComponent<undefined>): () => VNode<undefined>;\n\n/**\n * statefulComponent creates a virtual DOM node factory that produces nodes for stateful components.\n *\n *     const A = component(class extends Component<string> {\n *       onClick = Events.onClick(() => console.log(this.props));\n *\n *       render() {\n *         return (\n *           h.button()\n *             .e(this.onClick)\n *             .c(\"Click Me\")\n *         );\n *       }\n *     });\n *\n *     render(\n *       A(\"clicked\"),\n *       DOMContainer,\n *     );\n *\n * @param c stateful component.\n * @returns factory that produces stateful component nodes.\n */\nexport function statefulComponent<P>(\n  c: StatefulComponent<P>,\n): undefined extends P ? (props?: P) => VNode<P> : (props: P) => VNode<P>;\n\n/**\n * statefulComponent creates a virtual DOM node factory that produces nodes for stateful components.\n *\n *     const A = component(class extends Component<string> {\n *       onClick = Events.onClick(() => console.log(this.props));\n *\n *       render() {\n *         return (\n *           h.button()\n *             .e(this.onClick)\n *             .c(\"Click Me\")\n *         );\n *       }\n *     });\n *\n *     render(\n *       A(\"clicked\"),\n *       DOMContainer,\n *     );\n *\n * @param c stateful component.\n * @returns factory that produces stateful component nodes.\n */\nexport function statefulComponent<P>(\n  c: StatefulComponent<P>,\n): (props: P) => VNode<P> {\n  const f = function (props: P): VNode<P> {\n    const n = new VNode<P>(\n      VNodeFlags.StatefulComponent,\n      c,\n      props,\n      void 0,\n      null,\n    );\n    /* istanbul ignore else */\n    if (DEBUG) {\n      n.factory = f;\n    }\n    return n;\n  };\n  return f;\n}\n\n/**\n * context creates a virtual DOM node that will modify current context.\n *\n *     render(\n *       context({ key: 123 },\n *         ChildComponent(),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param ctx context object.\n * @param child child node.\n * @returns context node.\n */\nexport function context<T = {}>(ctx: T, child: VNode): VNode<T> {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (child.prev !== child) {\n      throw new Error(\"Context node contains an invalid child. Child should be a singular VNode.\");\n    }\n  }\n  return new VNode<T>(\n    VNodeFlags.UpdateContext,\n    null,\n    ctx,\n    void 0,\n    child,\n  );\n}\n\n/**\n * connect creates a virtual DOM node factory that produces connector nodes.\n *\n *     const Connector = connect<string, undefined, { result: string }>(\n *       (prev, props, context) => {\n *         const result = context.result;\n *\n *         return (prev !== null && prev === result) ? prev :\n *           result;\n *       },\n *       (text) => h.div().c(text),\n *     );\n *\n *     render(\n *       context({ result: \"text\" },\n *         Connector(),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param select selector function.\n * @param render render function.\n * @returns factory that produces connector nodes.\n */\nexport function connect<T>(\n  select: (prev: T | null) => T,\n  render: (props: T) => VNode<any>,\n): () => VNode<undefined>;\n\n/**\n * connect creates a virtual DOM node factory that produces connector nodes.\n *\n *     const Connector = connect<string, undefined, { result: string }>(\n *       (prev, props, context) => {\n *         const result = context.result;\n *\n *         return (prev !== null && prev === result) ? prev :\n *           result;\n *       },\n *       (text) => h.div().c(text),\n *     );\n *\n *     render(\n *       context({ result: \"text\" },\n *         Connector(),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param select selector function.\n * @param render render function.\n * @returns factory that produces connector nodes.\n */\nexport function connect<T, P>(\n  select: undefined extends P ? (prev: T | null, props?: P) => T : (prev: T | null, props: P) => T,\n  render: (props: T) => VNode<any>,\n): undefined extends P ? (props?: P) => VNode<P> : (props: P) => VNode<P>;\n\n/**\n * connect creates a virtual DOM node factory that produces connector nodes.\n *\n *     const Connector = connect<string, undefined, { result: string }>(\n *       (prev, props, context) => {\n *         const result = context.result;\n *\n *         return (prev !== null && prev === result) ? prev :\n *           result;\n *       },\n *       (text) => h.div().c(text),\n *     );\n *\n *     render(\n *       context({ result: \"text\" },\n *         Connector(),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param select selector function.\n * @param render render function.\n * @returns factory that produces connector nodes.\n */\nexport function connect<T, P, C>(\n  select: (prev: T | null, props: P, context: C) => T,\n  render: (props: T) => VNode<any>,\n): undefined extends P ? () => VNode<P> : (props: P) => VNode<P>;\n\n/**\n * connect creates a virtual DOM node factory that produces connector nodes.\n *\n *     const Connector = connect<string, undefined, { result: string }>(\n *       (prev, props, context) => {\n *         const result = context.result;\n *\n *         return (prev !== null && prev === result) ? prev :\n *           result;\n *       },\n *       (text) => h.div().c(text),\n *     );\n *\n *     render(\n *       context({ result: \"text\" },\n *         Connector(),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param select selector function.\n * @param render render function.\n * @returns factory that produces connector nodes.\n */\nexport function connect<T, P, C>(\n  select: (prev: T | null, props: P, context: C) => T,\n  render: (props: T) => VNode<any>,\n): (props: P) => VNode<P> {\n  const descriptor = { select, render };\n  const f = function (props: P): VNode<P> {\n    const n = new VNode<P>(\n      VNodeFlags.Connect,\n      descriptor as ConnectDescriptor<any, any, {}>,\n      props,\n      void 0,\n      null,\n    );\n    /* istanbul ignore else */\n    if (DEBUG) {\n      n.factory = f;\n    }\n    return n;\n  };\n  return f;\n}\n","/**\n * User Agent detection is used to fix some quirks like iOS event bubbling, etc.\n *\n * NOTE: Do not implement any browser detection that aren't used in `ivi` library.\n */\n\nconst ua = navigator.userAgent;\n\n/**\n * User Agent Flags.\n */\nexport const enum UserAgentFlags {\n  /**\n   * iOS browser (iPad, iPhone, iPod).\n   */\n  iOS = 1,\n  /**\n   * iOS full screen mode.\n   */\n  iOSStandalone = 1 << 1,\n  /**\n   * Android browser.\n   */\n  Android = 1 << 2,\n}\n\n/**\n * User Agent, see `UserAgentFlags` for details.\n */\nexport let USER_AGENT: UserAgentFlags = 0;\n\n/* istanbul ignore if */\nif (TARGET !== \"electron\") {\n  if (/iPad|iPhone|iPod/.test(ua) && !(\"MSStream\" in window)) {\n    USER_AGENT |= (\"standalone\" in navigator) ?\n      UserAgentFlags.iOS | UserAgentFlags.iOSStandalone :\n      UserAgentFlags.iOS;\n  }\n\n  if (ua.indexOf(\"Android\") > -1) {\n    USER_AGENT |= UserAgentFlags.Android;\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","const nodeProto = Node.prototype;\nconst elementProto = Element.prototype;\n\nexport const objectHasOwnProperty = Object.prototype.hasOwnProperty;\nexport const nodeInsertBefore = nodeProto.insertBefore;\nexport const nodeRemoveChild = nodeProto.removeChild;\nexport const nodeReplaceChild = nodeProto.replaceChild;\nexport const nodeCloneNode = nodeProto.cloneNode;\nexport const elementSetAttribute = elementProto.setAttribute;\nexport const elementSetAttributeNS = elementProto.setAttributeNS;\nexport const elementRemoveAttribute = elementProto.removeAttribute;\n","export const SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nexport const XLINK_NAMESPACE = \"http://www.w3.org/1999/xlink\";\nexport const XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n\n/**\n * KeyboardEvent keyCode values.\n */\nexport const enum KeyCode {\n  WinKeyFFLinux = 0,\n  MacEnter = 3,\n  Backspace = 8,\n  Tab = 9,\n  Clear = 12,\n  Enter = 13,\n  Shift = 16,\n  Control = 17,\n  Alt = 18,\n  Pause = 19,\n  CapsLock = 20,\n  Escape = 27,\n  Space = 32,\n  PageUp = 33,\n  PageDown = 34,\n  End = 35,\n  Home = 36,\n  ArrowLeft = 37,\n  ArrowUp = 38,\n  ArrowRight = 39,\n  ArrowDown = 40,\n  NumNorthEast = 33,\n  NumSouthEast = 34,\n  NumSouthWest = 35,\n  NumNorthWest = 36,\n  NumWest = 37,\n  NumNorth = 38,\n  NumEast = 39,\n  NumSouth = 40,\n  PrintScreen = 44,\n  Insert = 45,\n  NumInsert = 45,\n  Delete = 46,\n  NumDelete = 46,\n  Zero = 48,\n  Ono = 49,\n  Two = 50,\n  Three = 51,\n  Four = 52,\n  Five = 53,\n  Six = 54,\n  Seven = 55,\n  Eight = 56,\n  Nine = 57,\n  FFSemicolon = 59,\n  FFEquals = 61,\n  /**\n   * US keyboard layouts only.\n   */\n  QuestionMark = 63,\n  A = 65,\n  B = 66,\n  C = 67,\n  D = 68,\n  E = 69,\n  F = 70,\n  G = 71,\n  H = 72,\n  I = 73,\n  J = 74,\n  K = 75,\n  L = 76,\n  M = 77,\n  N = 78,\n  O = 79,\n  P = 80,\n  Q = 81,\n  R = 82,\n  S = 83,\n  T = 84,\n  U = 85,\n  V = 86,\n  W = 87,\n  X = 88,\n  Y = 89,\n  Z = 90,\n  Meta = 91,\n  WinKeyLeft = 91,\n  WinKeyRight = 92,\n  ContextMenu = 93,\n  NumZero = 96,\n  NumOne = 97,\n  NumTwo = 98,\n  NumThree = 99,\n  NumFour = 100,\n  NumFive = 101,\n  NumSix = 102,\n  NumSeven = 103,\n  NumEight = 104,\n  NumNine = 105,\n  NumMultiply = 106,\n  NumPlus = 107,\n  NumMinus = 109,\n  NumPeriod = 110,\n  NumDivision = 111,\n  F1 = 112,\n  F2 = 113,\n  F3 = 114,\n  F4 = 115,\n  F5 = 116,\n  F6 = 117,\n  F7 = 118,\n  F8 = 119,\n  F9 = 120,\n  F10 = 121,\n  F11 = 122,\n  F12 = 123,\n  NumLock = 144,\n  ScrollLock = 145,\n  /**\n   * First OS specific media key.\n   */\n  FirstMediaKey = 166,\n  /**\n   * Last OS specific media key.\n   */\n  LastMediaKey = 183,\n  /**\n   * US keyboard layouts only.\n   */\n  Semicolon = 186,\n  /**\n   * US keyboard layouts only.\n   */\n  Dash = 189,\n  /**\n   * US keyboard layouts only.\n   */\n  Equals = 187,\n  /**\n   * US keyboard layouts only.\n   */\n  Comma = 188,\n  /**\n   * US keyboard layouts only.\n   */\n  Period = 190,\n  /**\n   * US keyboard layouts only.\n   */\n  Slash = 191,\n  /**\n   * US keyboard layouts only.\n   */\n  Apostrophe = 192,\n  /**\n   * US keyboard layouts only.\n   */\n  Tilde = 192,\n  /**\n   * US keyboard layouts only.\n   */\n  SingleQuote = 222,\n  /**\n   * US keyboard layouts only.\n   */\n  OpenSquareBracket = 219,\n  /**\n   * US keyboard layouts only.\n   */\n  Backslash = 220,\n  /**\n   * US keyboard layouts only.\n   */\n  CloseSquareBracket = 221,\n  Win = 224,\n  MacFFMeta = 224,\n  WinIME = 229,\n}\n\n/**\n * KeyboardEvent keyLocation values.\n */\nexport const enum KeyLocation {\n  Standard = 0,\n  Left = 1,\n  Right = 2,\n  NumPad = 3,\n  Mobile = 4,\n  Joystick = 5,\n}\n\n/**\n * Flags for MouseEvent buttons property.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n */\nexport const enum MouseButtons {\n  Left = 1,\n  Right = 1 << 1,\n  /**\n   * Wheel or middle button.\n   */\n  Middle = 1 << 2,\n  /**\n   * Typically the \"Browser Back\" button.\n   */\n  Fourh = 1 << 3,\n  /**\n   * Typically the \"Browser Forward\" button.\n   */\n  Fifth = 1 << 4,\n}\n\nexport type KeyName =\n  \"Accept\" |\n  \"Add\" |\n  \"Again\" |\n  \"AllCandidates\" |\n  \"Alphanumeric\" |\n  \"Alt\" |\n  \"AltGraph\" |\n  \"Apps\" |\n  \"Attn\" |\n  \"BrowserBack\" |\n  \"BrowserFavorites\" |\n  \"BrowserForward\" |\n  \"BrowserHome\" |\n  \"BrowserRefresh\" |\n  \"BrowserSearch\" |\n  \"BrowserStop\" |\n  \"Camera\" |\n  \"CapsLock\" |\n  \"Clear\" |\n  \"CodeInput\" |\n  \"Compose\" |\n  \"Control\" |\n  \"Crsel\" |\n  \"Convert\" |\n  \"Copy\" |\n  \"Cut\" |\n  \"Decimal\" |\n  \"Divide\" |\n  \"Down\" |\n  \"DownLeft\" |\n  \"DownRight\" |\n  \"Eject\" |\n  \"End\" |\n  \"Enter\" |\n  \"EraseEof\" |\n  \"Execute\" |\n  \"Exsel\" |\n  \"Fn\" |\n  \"F1\" |\n  \"F2\" |\n  \"F3\" |\n  \"F4\" |\n  \"F5\" |\n  \"F6\" |\n  \"F7\" |\n  \"F8\" |\n  \"F9\" |\n  \"F10\" |\n  \"F11\" |\n  \"F12\" |\n  \"F13\" |\n  \"F14\" |\n  \"F15\" |\n  \"F16\" |\n  \"F17\" |\n  \"F18\" |\n  \"F19\" |\n  \"F20\" |\n  \"F21\" |\n  \"F22\" |\n  \"F23\" |\n  \"F24\" |\n  \"FinalMode\" |\n  \"Find\" |\n  \"FullWidth\" |\n  \"HalfWidth\" |\n  \"HangulMode\" |\n  \"HanjaMode\" |\n  \"Help\" |\n  \"Hiragana\" |\n  \"Home\" |\n  \"Insert\" |\n  \"JapaneseHiragana\" |\n  \"JapaneseKatakana\" |\n  \"JapaneseRomaji\" |\n  \"JunjaMode\" |\n  \"KanaMode\" |\n  \"KanjiMode\" |\n  \"Katakana\" |\n  \"LaunchApplication1\" |\n  \"LaunchApplication2\" |\n  \"LaunchMail\" |\n  \"Left\" |\n  \"Menu\" |\n  \"Meta\" |\n  \"MediaNextTrack\" |\n  \"MediaPlayPause\" |\n  \"MediaPreviousTrack\" |\n  \"MediaStop\" |\n  \"ModeChange\" |\n  \"NextCandidate\" |\n  \"Nonconvert\" |\n  \"NumLock\" |\n  \"PageDown\" |\n  \"PageUp\" |\n  \"Paste\" |\n  \"Pause\" |\n  \"Play\" |\n  \"Power\" |\n  \"PreviousCandidate\" |\n  \"PrintScreen\" |\n  \"Process\" |\n  \"Props\" |\n  \"Right\" |\n  \"RomanCharacters\" |\n  \"Scroll\" |\n  \"Select\" |\n  \"SelectMedia\" |\n  \"Separator\" |\n  \"Shift\" |\n  \"Soft1\" |\n  \"Soft2\" |\n  \"Soft3\" |\n  \"Soft4\" |\n  \"Stop\" |\n  \"Subtract\" |\n  \"SymbolLock\" |\n  \"Up\" |\n  \"UpLeft\" |\n  \"UpRight\" |\n  \"Undo\" |\n  \"VolumeDown\" |\n  \"VolumeMute\" |\n  \"VolumeUp\" |\n  \"Win\" |\n  \"Zoom\" |\n  \"Backspace\" |\n  \"Tab\" |\n  \"Cancel\" |\n  \"Esc\" |\n  \"Spacebar\" |\n  \"Del\" |\n  \"DeadGrave\" |\n  \"DeadEacute\" |\n  \"DeadCircumflex\" |\n  \"DeadTilde\" |\n  \"DeadMacron\" |\n  \"DeadBreve\" |\n  \"DeadAboveDot\" |\n  \"DeadUmlaut\" |\n  \"DeadAboveRing\" |\n  \"DeadDoubleacute\" |\n  \"DeadCaron\" |\n  \"DeadCedilla\" |\n  \"DeadOgonek\" |\n  \"DeadIota\" |\n  \"DeadVoicedSound\" |\n  \"DeadSemivoicedSound\" |\n  \"Unidentified\";\n","import { EventHandler } from \"./event_handler\";\nimport { EventHandlerFlags } from \"./flags\";\n\n/**\n * registerEventHandler is a shortcut for Event Handler registration.\n *\n * @param handler Event Handler.\n */\nfunction registerEventHandler(handler: EventHandler<any>): void {\n  if (DEBUG) {\n    handler.flags |= EventHandlerFlags.Active;\n  }\n  handler.source.addListener(handler);\n}\n\n/**\n * unregisterEventHandler is a shortcut for Event Handler unregistration.\n *\n * @param handler Event Handler.\n */\nfunction unregisterEventHandler(handler: EventHandler<any>): void {\n  if (DEBUG) {\n    handler.flags &= ~EventHandlerFlags.Active;\n  }\n  handler.source.removeListener(handler);\n}\n\n/**\n * syncEvents syncs event handlers and invokes EventSource callbacks when event handler is attached or detached.\n *\n * @param a Old event handlers.\n * @param b New event handlers.\n */\nexport function syncEvents(\n  a: Array<EventHandler | null> | EventHandler | null,\n  b: Array<EventHandler | null> | EventHandler | null,\n): void {\n  let i: number;\n  let h1: EventHandler | null;\n  let h2: EventHandler | null;\n\n  if (a === null) {\n    attachEvents(b!);\n  } else if (b === null) {\n    detachEvents(a);\n  } else {\n    if (a instanceof Array) {\n      if (b instanceof Array) {\n        i = 0;\n        while (i < a.length && i < b.length) {\n          h1 = a[i];\n          h2 = b[i++];\n          if (h1 !== h2) {\n            if (h2 !== null) {\n              registerEventHandler(h2);\n            }\n            if (h1 !== null) {\n              unregisterEventHandler(h1);\n            }\n          }\n        }\n        while (i < b.length) {\n          h1 = b[i++];\n          if (h1 !== null) {\n            registerEventHandler(h1);\n          }\n        }\n        while (i < a.length) {\n          h1 = a[i++];\n          if (h1 !== null) {\n            unregisterEventHandler(h1);\n          }\n        }\n      } else {\n        registerEventHandler(b as EventHandler);\n\n        for (i = 0; i < a.length; ++i) {\n          h1 = a[i];\n          if (h1 !== null) {\n            unregisterEventHandler(h1);\n          }\n        }\n      }\n    } else {\n      attachEvents(b);\n      unregisterEventHandler(a as EventHandler);\n    }\n  }\n}\n\n/**\n * attachEvents attaches event handlers and invokes EventSource callbacks.\n *\n * @param events Event handlers.\n */\nexport function attachEvents(events: Array<EventHandler | null> | EventHandler): void {\n  if (events instanceof Array) {\n    for (let i = 0; i < events.length; ++i) {\n      const h = events[i];\n      if (h !== null) {\n        registerEventHandler(h);\n      }\n    }\n  } else {\n    registerEventHandler(events as EventHandler);\n  }\n}\n\n/**\n * detachEvents detaches events handles and invokes EventSource callbacks.\n *\n * @param events Event handlers.\n */\nexport function detachEvents(events: Array<EventHandler | null> | EventHandler): void {\n  if (events instanceof Array) {\n    for (let i = 0; i < events.length; ++i) {\n      const h = events[i];\n      if (h !== null) {\n        unregisterEventHandler(h);\n      }\n    }\n  } else {\n    unregisterEventHandler(events as EventHandler);\n  }\n}\n","/**\n * Feature Detection is used to implement polyfills or just disable some features when browser doesn't support them.\n * For example, when browser doesn't support passive events, we can just ignore it and always use active events.\n */\n\n/* istanbul ignore next */\n/**\n * Passive event listeners are a new feature in the DOM spec that enable developers to opt-in to better scroll\n * performance by eliminating the need for scrolling to block on touch and wheel event listeners. Developers can\n * annotate touch and wheel listeners with {passive: true} to indicate that they will never invoke preventDefault.\n *\n * https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nexport const PASSIVE_EVENTS = (TARGET === \"electron\") ? true :\n  /*#__PURE__*/(() => {\n    let v = false;\n    try {\n      // Test via a getter in the options object to see if the passive property is accessed\n      const opts = Object.defineProperty({}, \"passive\", {\n        get() {\n          v = true;\n        },\n      });\n      window.addEventListener(\"test\", null as any as (ev: Event) => void, opts);\n    } catch (e) {\n      // ignore\n    }\n    return v;\n  })();\n\n/* istanbul ignore next */\n/**\n * `key` property is available on KeyboardEvent instances.\n */\nexport const KEYBOARD_EVENT_KEY = (TARGET === \"electron\") || (\"key\" in KeyboardEvent.prototype);\n\n/* istanbul ignore next */\n/**\n * `buttons` property is available on MouseEvent instances.\n */\nexport const MOUSE_EVENT_BUTTONS = (TARGET === \"electron\") || (\"buttons\" in MouseEvent.prototype);\n\n/* istanbul ignore next */\n/**\n * Touch Events support.\n */\nexport const TOUCH_EVENTS = (\"ontouchstart\" in window);\n\n/* istanbul ignore next */\n/**\n * Pointer Events support.\n */\nexport const POINTER_EVENTS = (TARGET === \"electron\") || (\"PointerEvent\" in window);\n\n/* istanbul ignore next */\n/**\n * InputDeviceCapabilities support.\n *\n * http://wicg.github.io/InputDeviceCapabilities/\n */\nexport const INPUT_DEVICE_CAPABILITIES = (TARGET === \"electron\") || (\"sourceCapabilities\" in UIEvent.prototype);\n","import { PASSIVE_EVENTS } from \"ivi-core\";\nimport { NativeEventSourceFlags } from \"./flags\";\nimport { EventHandler } from \"./event_handler\";\n\n/**\n * Extends Element interface with a special property that is used to assign synthetic event handlers list.\n */\ndeclare global {\n  interface Element {\n    _ev: Array<EventHandler | null> | EventHandler | null | undefined;\n  }\n}\n\n/* istanbul ignore next */\n/**\n * getEventTarget retrieves target element from an event.\n *\n * There are still some differences in modern browsers, so we need to use this function to retrieve event targets.\n *\n * #quirks\n *\n * @param ev Event.\n * @returns Target Element.\n */\nexport function getEventTarget(ev: Event): EventTarget {\n  let target = ev.target || window;\n\n  /**\n   * Some browsers are implementing it according to SVG 1.1 specs:\n   *\n   * https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7998724/\n   *\n   * \"If event attributes are assigned to referenced elements, then the actual target for the event will be the\n   * SVGElementInstance object within the 'instance tree' corresponding to the given referenced element.\"\n   *\n   * https://www.w3.org/TR/SVG/struct.html#UseElement\n   *\n   * SVG 2 redefined the use event handling model:\n   *\n   * - Removed the SVGElementInstance and SVGElementInstanceList interfaces, and the corresponding attributes on the\n   *   SVGUseElement interface.\n   * - Changed the use element event flow to follow the Shadow DOM spec.\n   *\n   * https://www.w3.org/TR/SVG2/changes.html#structure\n   */\n  if ((target as any).correspondingUseElement !== undefined) {\n    target = (target as any).correspondingUseElement;\n  }\n\n  return target;\n}\n\n/* istanbul ignore next */\n/**\n * `{ capture: true, passive: true }` object that should be used as a 3rd parameter for `addEventListener` method.\n */\nexport const EVENT_CAPTURE_PASSIVE_OPTIONS = PASSIVE_EVENTS ? { \"capture\": true, \"passive\": true } : true;\n\n/* istanbul ignore next */\n/**\n * `{ capture: true, passive: false }` object that should be used as a 3rd parameter for `addEventListener` method.\n */\nexport const EVENT_CAPTURE_ACTIVE_OPTIONS = PASSIVE_EVENTS ? { \"capture\": true, \"passive\": false } : true;\n\n/* istanbul ignore next */\n/**\n * `{ passive: true }` object that should be used as a 3rd parameter for `addEventListener` method.\n */\nexport const EVENT_PASSIVE_OPTIONS = PASSIVE_EVENTS ? { \"passive\": true } : false;\n\n/* istanbul ignore next */\n/**\n * `{ passive: false }` object that should be used as a 3rd parameter for `addEventListener` method.\n */\nexport const EVENT_ACTIVE_OPTIONS = PASSIVE_EVENTS ? { \"passive\": false } : false;\n\n/* istanbul ignore next */\n/**\n * getNativeEventOptions converts `NativeEventSourceFlags` to event options that can be used as a 3rd parameter\n * for `addEventListener` method.\n *\n * #quirks\n *\n * @param flags See `NativeEventSourceFlags` for details.\n * @returns Option object that can be used as a 3rd parameter for `addEventListener` method.\n */\nexport function getNativeEventOptions(\n  flags: NativeEventSourceFlags,\n): boolean | { capture?: boolean, passive?: boolean } {\n  if ((flags & NativeEventSourceFlags.Passive) !== 0) {\n    if ((flags & NativeEventSourceFlags.Capture) !== 0) {\n      return EVENT_CAPTURE_PASSIVE_OPTIONS;\n    }\n    return EVENT_PASSIVE_OPTIONS;\n  }\n  if ((flags & NativeEventSourceFlags.Capture) !== 0) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * setEventHandlersToDOMNode assigns a event handlers to the DOM node.\n *\n * @param node DOM Node.\n * @param events Event Handlers.\n */\nexport function setEventHandlersToDOMNode(\n  node: Element,\n  events: Array<EventHandler | null> | EventHandler | null,\n): void {\n  node._ev = events;\n}\n\n/**\n * getEventHandlersFromDOMNode retrieves event handlers from the DOM node.\n *\n * @param node DOM Node.\n * @returns Event Handlers.\n */\nexport function getEventHandlersFromDOMNode(\n  node: Element,\n): Array<EventHandler | null> | EventHandler | undefined | null {\n  return node._ev;\n}\n","import {\n  XML_NAMESPACE, XLINK_NAMESPACE, CSSStyleProps, elementRemoveAttribute, elementSetAttribute, elementSetAttributeNS,\n} from \"ivi-core\";\n\n/**\n * Sync DOM styles.\n *\n * @param node HTML or SVG Element.\n * @param a Old styles.\n * @param b New styles.\n */\nexport function syncStyle(\n  node: HTMLElement | SVGElement,\n  a: CSSStyleProps | null,\n  b: CSSStyleProps | null,\n): void {\n  const style = node.style;\n  let key: string;\n  let bValue;\n\n  if (a === null) {\n    // a is empty, insert all styles from b.\n    for (key in b!) {\n      bValue = (b as { [key: string]: string })[key];\n      if (bValue !== undefined) {\n        style.setProperty(key, bValue);\n      }\n    }\n  } else if (b !== null) {\n    for (key in b) {\n      bValue = (b as { [key: string]: string })[key];\n      if ((a as { [key: string]: string })[key] !== bValue) {\n        if (bValue !== undefined) {\n          style.setProperty(key, bValue);\n        } else {\n          style.removeProperty(key);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Set DOM property.\n *\n * @param node HTML or SVG Element.\n * @param svg SVG Element.\n * @param key Attribute name.\n * @param value Attribute value.\n */\nfunction setDOMAttribute(node: Element, svg: boolean, key: string, value: any): void {\n  if (typeof value === \"boolean\") {\n    if (value) {\n      value = \"\";\n    } else {\n      return;\n    }\n  }\n  if (svg === true) {\n    if (key.length > 5) {\n      if (key.charCodeAt(0) === 120 &&\n        // 58 === \":\"\n        (\n          key.charCodeAt(3) === 58 || // \"xml:\"\n          key.charCodeAt(5) === 58    // \"xlink:\"\n        )\n      ) {\n        if (key.startsWith(\"xml:\")) {\n          /**\n           * All attributes that starts with an \"xml:\" prefix will be assigned with XML namespace.\n           */\n          /* istanbul ignore else */\n          if (DEBUG) {\n            node.setAttributeNS(XML_NAMESPACE, key, value);\n          } else {\n            elementSetAttributeNS.call(node, XML_NAMESPACE, key, value);\n          }\n          return;\n        } else if (key.startsWith(\"xlink:\")) {\n          /**\n           * All attributes that starts with an \"xlink:\" prefix will be assigned with XLINK namespace.\n           */\n          /* istanbul ignore else */\n          if (DEBUG) {\n            node.setAttributeNS(XLINK_NAMESPACE, key, value);\n          } else {\n            elementSetAttributeNS.call(node, XLINK_NAMESPACE, key, value);\n          }\n          return;\n        }\n      }\n    }\n  }\n  /* istanbul ignore else */\n  if (DEBUG) {\n    node.setAttribute(key, value);\n  } else {\n    elementSetAttribute.call(node, key, value);\n  }\n}\n\n/**\n * Sync DOM Attributes.\n *\n * @param node HTML or SVG Element.\n * @param svg SVG Element.\n * @param a Old DOM properties.\n * @param b New DOM properties.\n */\nexport function syncDOMAttrs(\n  node: Element,\n  svg: boolean,\n  a: { [key: string]: any } | null,\n  b: { [key: string]: any } | null,\n): void {\n  let key: string;\n  let bValue;\n\n  if (a === null) {\n    // a is empty, insert all attributes from b.\n    for (key in b!) {\n      bValue = b![key];\n      if (bValue !== undefined) {\n        setDOMAttribute(node, svg, key, bValue);\n      }\n    }\n  } else if (b !== null) {\n    for (key in b) {\n      bValue = b[key];\n      if (a[key] !== bValue) {\n        if (bValue !== undefined) {\n          setDOMAttribute(node, svg, key, bValue);\n        } else {\n          /* istanbul ignore else */\n          if (DEBUG) {\n            node.removeAttribute(key);\n          } else {\n            elementRemoveAttribute.call(node, key);\n          }\n        }\n      }\n    }\n  }\n}\n","/**\n * DO NOT MOVE THIS FUNCTIONS TO SEPARATE MODULES!\n *\n * There are so many circular dependencies between functions in this module, so just leave it all here instead of\n * creating many circular dependencies between JS modules.\n */\n\nimport {\n  SVG_NAMESPACE, nodeRemoveChild, nodeInsertBefore, elementSetAttribute, nodeCloneNode, nodeReplaceChild,\n} from \"ivi-core\";\nimport { autofocus } from \"ivi-scheduler\";\nimport { setEventHandlersToDOMNode, syncEvents, attachEvents, detachEvents } from \"ivi-events\";\nimport { VNodeFlags, ComponentFlags } from \"./flags\";\nimport { VNode, getDOMInstanceFromVNode } from \"./vnode\";\nimport { ConnectDescriptor } from \"./connect_descriptor\";\nimport { StatefulComponent, StatelessComponent, Component } from \"./component\";\nimport { syncDOMAttrs, syncStyle } from \"./sync_dom\";\n\n/**\n * Remove VNode entry point.\n *\n * @param parent Parent DOM node.\n * @param node VNode element to remove.\n */\nexport function removeVNode(parent: Node, node: VNode): void {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    parent.removeChild(getDOMInstanceFromVNode(node)!);\n  } else {\n    nodeRemoveChild.call(parent, getDOMInstanceFromVNode(node)!);\n  }\n  _detach(node);\n}\n\n/**\n * Recursively attach all nodes.\n *\n * @param vnode VNode.\n */\nfunction _attach(vnode: VNode): void {\n  const flags = vnode.flags;\n\n  if ((flags & (VNodeFlags.ChildrenVNode | VNodeFlags.ElementPropsEvents)) !== 0) {\n    if ((flags & VNodeFlags.ChildrenVNode) !== 0) {\n      let child: VNode | null = vnode.children as VNode;\n      do {\n        _attach(child!);\n        child = child.next;\n      } while (child !== null);\n    }\n    if ((flags & VNodeFlags.ElementPropsEvents) !== 0) {\n      if (vnode.events !== null) {\n        attachEvents(vnode.events);\n      }\n    }\n  } else if (\n    (flags & (\n      VNodeFlags.StatelessComponent |\n      VNodeFlags.StatefulComponent |\n      VNodeFlags.Connect |\n      VNodeFlags.UpdateContext\n    )) !== 0) {\n    if ((flags & VNodeFlags.StatefulComponent) !== 0) {\n      (vnode.instance as Component<any>).attached();\n    }\n    _attach(vnode.children as VNode);\n  }\n}\n\n/**\n * Recursively detach all nodes.\n *\n * @param vnode VNode.\n */\nfunction _detach(vnode: VNode): void {\n  const flags = vnode.flags;\n\n  if ((flags & (VNodeFlags.ChildrenVNode | VNodeFlags.ElementPropsEvents)) !== 0) {\n    if ((flags & VNodeFlags.ChildrenVNode) !== 0) {\n      let child: VNode | null = vnode.children as VNode;\n      do {\n        _detach(child!);\n        child = child.next;\n      } while (child !== null);\n    }\n    if ((flags & VNodeFlags.ElementPropsEvents) !== 0) {\n      if (vnode.events !== null) {\n        detachEvents(vnode.events);\n      }\n    }\n  } else if ((flags & (\n    VNodeFlags.StatelessComponent |\n    VNodeFlags.StatefulComponent |\n    VNodeFlags.Connect |\n    VNodeFlags.UpdateContext\n  )) !== 0) {\n    _detach(vnode.children as VNode);\n    if ((flags & VNodeFlags.StatefulComponent) !== 0) {\n      const component = vnode.instance as Component<any>;\n      component.flags |= ComponentFlags.Detached;\n      component.detached();\n    }\n  }\n}\n\n/**\n * Recursively perform dirty checking.\n *\n * @param parent Parent DOM Node.\n * @param vnode VNode.\n * @param context New context.\n * @param dirtyContext Dirty context.\n */\nexport function dirtyCheck(parent: Node, vnode: VNode, context: {}, dirtyContext: boolean): number {\n  const flags = vnode.flags;\n  let deepUpdate = 0;\n  let children: VNode | null | undefined;\n  let instance: Node | Component<any> | {} | undefined;\n\n  if ((flags & (\n    VNodeFlags.StopDirtyChecking | // StopDirtyChecking will convert this value to -value\n    VNodeFlags.ChildrenVNode |\n    VNodeFlags.StatelessComponent |\n    VNodeFlags.StatefulComponent |\n    VNodeFlags.Connect |\n    VNodeFlags.UpdateContext\n  )) > 0) {\n    children = vnode.children as VNode;\n    if ((flags & VNodeFlags.ChildrenVNode) !== 0) {\n      instance = vnode.instance as Node;\n      do {\n        deepUpdate |= dirtyCheck(instance as Node, children, context, dirtyContext);\n        children = children.next;\n      } while (children !== null);\n    } else if ((flags & VNodeFlags.StatefulComponent) !== 0) {\n      instance = vnode.instance as Component<any>;\n      if (((instance as Component<any>).flags & ComponentFlags.Dirty) !== 0) {\n        syncVNode(\n          parent,\n          children,\n          vnode.children = DEBUG ?\n            shouldBeSingleVNode((instance as Component<any>).render()) :\n            /* istanbul ignore next */(instance as Component<any>).render(),\n          context,\n          dirtyContext,\n        );\n        (instance as Component<any>).flags &= ~ComponentFlags.Dirty;\n        (instance as Component<any>).updated(true);\n        deepUpdate = 1;\n      } else {\n        deepUpdate = dirtyCheck(parent, children, context, dirtyContext);\n        if (deepUpdate !== 0) {\n          (instance as Component<any>).updated(false);\n        }\n      }\n    } else { // (flags & (VNodeFlags.StatelessComponent | VNodeFlags.Connect | VNodeFlags.UpdateContext))\n      if ((flags & VNodeFlags.Connect) !== 0) {\n        const connect = vnode.tag as ConnectDescriptor<any, any, {}>;\n        instance = vnode.instance as {};\n        const selectData = connect.select(instance, vnode.props, context);\n        if (instance === selectData) {\n          deepUpdate = dirtyCheck(parent, children, context, dirtyContext);\n        } else {\n          deepUpdate = 1;\n          vnode.instance = selectData;\n          syncVNode(\n            parent,\n            children,\n            vnode.children = DEBUG ?\n              shouldBeSingleVNode(connect.render(selectData)) :\n              /* istanbul ignore next */connect.render(selectData),\n            context,\n            dirtyContext,\n          );\n        }\n      } else {\n        if ((flags & VNodeFlags.UpdateContext) !== 0) {\n          if (dirtyContext === true) {\n            vnode.instance = { ...context, ...vnode.props };\n          }\n          context = vnode.instance as {};\n        }\n        deepUpdate = dirtyCheck(parent, children, context, dirtyContext);\n      }\n    }\n  }\n  return deepUpdate;\n}\n\n/**\n * Remove all children.\n *\n * `detach` lifecycle methods will be invoked for all children and their subtrees.\n *\n * @param parent Parent DOM node.\n * @param firstNode Arrays of VNodes to remove.\n */\nfunction _removeAllChildren(parent: Node, firstNode: VNode): void {\n  parent.textContent = \"\";\n  let node: VNode | null = firstNode;\n  do {\n    _detach(node);\n    node = node.next;\n  } while (node !== null);\n}\n\n/**\n * Set value for HTMLInputElement.\n *\n * When value has a string type it is assigned to `value` property, otherwise it is assigned to `checked` property.\n *\n * @param input HTMLInputElement.\n * @param value Value.\n */\nfunction _setInputValue(input: HTMLInputElement, value: string | boolean): void {\n  if (typeof value === \"string\") {\n    input.value = value;\n  } else {\n    input.checked = value;\n  }\n}\n\n/**\n * Render VNode.\n *\n * @param parent Parent DOM Node.\n * @param vnode VNode to render.\n * @param context Current context.\n * @returns Rendered DOM Node.\n */\nfunction _render(parent: Node, vnode: VNode, context: {}): Node {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (vnode.instance !== null) {\n      throw new Error(\"VNode is already have a reference to an instance. VNodes can't be used mutliple times, \" +\n        \"clone VNode with `cloneVNode`.\");\n    }\n  }\n\n  const flags = vnode.flags;\n  let instance: Node | Component<any> | null = null;\n  let node: Node;\n\n  if ((flags & VNodeFlags.Text) !== 0) {\n    instance = node = document.createTextNode(vnode.children as string);\n  } else {\n    if ((flags & (VNodeFlags.Element | VNodeFlags.StatefulComponent)) !== 0) {\n      if ((flags & VNodeFlags.Element) !== 0) {\n        const svg = (flags & VNodeFlags.SvgElement) !== 0;\n        if ((flags & VNodeFlags.ElementFactory) === 0) {\n          const tagName = vnode.tag as string;\n          node = svg ?\n            document.createElementNS(SVG_NAMESPACE, tagName) :\n            document.createElement(tagName);\n        } else {\n          const factory = vnode.tag as VNode;\n          if (factory.instance === null) {\n            _render(parent, factory, context);\n          }\n          /* istanbul ignore else */\n          if (DEBUG) {\n            node = (factory.instance as Node).cloneNode(false);\n          } else {\n            node = nodeCloneNode.call(factory.instance as Node, false);\n          }\n        }\n\n        if (vnode.className !== void 0) {\n          /**\n           * SVGElement.className returns `SVGAnimatedString`\n           */\n          if (svg === true) {\n            /* istanbul ignore else */\n            if (DEBUG) {\n              (node as Element).setAttribute(\"class\", vnode.className);\n            } else {\n              elementSetAttribute.call(node as Element, \"class\", vnode.className);\n            }\n          } else {\n            (node as Element).className = vnode.className;\n          }\n        }\n\n        if (vnode.props !== null) {\n          syncDOMAttrs(node as Element, svg, null, vnode.props);\n        }\n        if (vnode.style !== null) {\n          syncStyle(node as HTMLElement, null, vnode.style);\n        }\n        if (vnode.events !== null) {\n          setEventHandlersToDOMNode(node as Element, vnode.events);\n        }\n\n        let children = vnode.children;\n        if (children !== null) {\n          if ((flags & VNodeFlags.ChildrenVNode) !== 0) {\n            children = children as VNode;\n            do {\n              /* istanbul ignore else */\n              if (DEBUG) {\n                node.insertBefore(_render(node, children, context), null);\n              } else {\n                nodeInsertBefore.call(node, _render(node, children, context), null);\n              }\n              children = children.next;\n            } while (children !== null);\n          } else if ((flags & (VNodeFlags.InputElement | VNodeFlags.TextAreaElement)) !== 0) {\n            /**\n             * #quirks\n             *\n             * It is important that input value is assigned after all properties. It prevents some issues with\n             * rounding, etc. `value` should be assigned after `step`, `min` and `max` properties.\n             */\n            _setInputValue(node as HTMLInputElement, children as string | boolean);\n          } else { // (flags & VNodeFlags.UnsafeHTML)\n            (node as Element).innerHTML = children as string;\n          }\n        }\n\n        instance = node;\n      } else { // ((flags & VNodeFlags.StatefulComponent) !== 0)\n        const component = instance = new (vnode.tag as StatefulComponent<any>)(vnode.props);\n        const root = vnode.children = DEBUG ?\n          shouldBeSingleVNode(component.render()) :\n          /* istanbul ignore next */component.render();\n        node = _render(parent, root, context);\n      }\n    } else { // ((flags & (VNodeFlags.StatelessComponent | VNodeFlags.UpdateContext | VNodeFlags.Connect)) !== 0)\n      if ((flags & (VNodeFlags.UpdateContext | VNodeFlags.Connect)) !== 0) {\n        if ((flags & VNodeFlags.Connect) !== 0) {\n          const connect = (vnode.tag as ConnectDescriptor<any, any, {}>);\n          const selectData = instance = connect.select(null, vnode.props, context);\n          vnode.children = DEBUG ?\n            shouldBeSingleVNode(connect.render(selectData)) :\n            /* istanbul ignore next */connect.render(selectData);\n        } else {\n          context = instance = { ...context, ...vnode.props };\n        }\n      } else {\n        vnode.children = DEBUG ?\n          shouldBeSingleVNode((vnode.tag as StatelessComponent<any>).render(vnode.props)) :\n          /* istanbul ignore next */(vnode.tag as StatelessComponent<any>).render(vnode.props);\n      }\n      node = _render(parent, vnode.children as VNode, context);\n    }\n\n    if ((flags & VNodeFlags.Autofocus) !== 0) {\n      autofocus(node as Element);\n    }\n  }\n\n  vnode.instance = instance;\n\n  return node;\n}\n\n/**\n * Render VNode into container and invoke `attached` lifecycle methods after VNode is inserted into container.\n *\n * It is important that `attached` methods are invoked only after DOM Nodes have been inserted into container, so it\n * goes twice through the entire vnode tree, first time when everything is rendered and the second time when `attached`\n * methods are invoked.\n *\n * @param parent Parent DOM Node.\n * @param refChild Reference to the next Node, when it is `null` child will be inserted at the end.\n * @param vnode VNode.\n * @param context Current context.\n * @returns Rendered DOM Node.\n */\nexport function renderVNode(\n  parent: Node,\n  refChild: Node | null,\n  vnode: VNode,\n  context: {},\n): Node {\n  const node = _render(parent, vnode, context);\n  /* istanbul ignore else */\n  if (DEBUG) {\n    parent.insertBefore(node, refChild);\n  } else {\n    nodeInsertBefore.call(parent, node, refChild);\n  }\n  _attach(vnode);\n  return node;\n}\n\n/**\n * Check if two nodes has equal keys.\n *\n * @param a VNode.\n * @param b VNode.\n * @returns true if nodes has equal keys.\n */\nfunction _eqKeys(a: VNode, b: VNode): boolean {\n  return (\n    (a.key === b.key) &&\n    ((a.flags ^ b.flags) & VNodeFlags.Key) === 0\n  );\n}\n\n/**\n * Sync two VNodes.\n *\n * When node `a` is synced with node `b`, `a` node should be considered as destroyed, and any access to it after sync\n * is an undefined behavior.\n *\n * @param parent Parent node.\n * @param a Old VNode.\n * @param b New VNode.\n * @param context Current context.\n * @param dirtyContext Dirty context.\n */\nexport function syncVNode(\n  parent: Node,\n  a: VNode,\n  b: VNode,\n  context: {},\n  dirtyContext: boolean,\n): void {\n  if (a === b) {\n    dirtyCheck(parent, b, context, dirtyContext);\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (b.instance !== null) {\n      throw new Error(\"VNode is already have a reference to an instance. VNodes can't be used mutliple times\");\n    }\n  }\n\n  let instance;\n  const bFlags = b.flags;\n  if (\n    (((a.flags ^ b.flags) & VNodeFlags.Syncable) === 0) &&\n    (\n      (a.flags & (\n        VNodeFlags.ElementFactory |\n        VNodeFlags.StatelessComponent |\n        VNodeFlags.StatefulComponent |\n        VNodeFlags.Connect\n      )) === 0 ||\n      a.tag === b.tag\n    ) &&\n    a.key === b.key\n  ) {\n    b.instance = instance = a.instance;\n\n    if ((bFlags & (VNodeFlags.Text | VNodeFlags.Element)) !== 0) {\n      if ((bFlags & VNodeFlags.Text) !== 0) {\n        if (a.children !== b.children) {\n          (instance as Text).nodeValue = b.children as string;\n        }\n      } else { // (flags & VNodeFlags.Element)\n        const svg = (bFlags & VNodeFlags.SvgElement) !== 0;\n\n        if (a.className !== b.className) {\n          const className = b.className === void 0 ? \"\" : b.className;\n          if (svg === true) {\n            /* istanbul ignore else */\n            if (DEBUG) {\n              (instance as Element).setAttribute(\"class\", className);\n            } else {\n              elementSetAttribute.call(instance, \"class\", className);\n            }\n          } else {\n            (instance as Element).className = className;\n          }\n        }\n\n        if (a.props !== b.props) {\n          syncDOMAttrs(instance as Element, svg, a.props, b.props);\n        }\n        if (a.style !== b.style) {\n          syncStyle(instance as HTMLElement, a.style, b.style);\n        }\n        if (a.events !== b.events) {\n          syncEvents(a.events, b.events);\n          setEventHandlersToDOMNode(instance as Element, b.events);\n        }\n\n        const aChild = a.children;\n        let bChild = b.children;\n        if (aChild !== bChild) {\n          const aFlags = a.flags;\n          if (aChild === null) {\n            if ((bFlags & VNodeFlags.ChildrenVNode) !== 0) {\n              bChild = bChild as VNode;\n              do {\n                renderVNode(instance as Element, null, bChild, context);\n                bChild = bChild.next!;\n              } while (bChild !== null);\n            } else if ((bFlags & (VNodeFlags.InputElement | VNodeFlags.TextAreaElement)) !== 0) {\n              _setInputValue(instance as Element as HTMLInputElement, bChild as string | boolean);\n            } else { // (bParentFlags & VNodeFlags.UnsafeHTML)\n              (instance as Element).innerHTML = bChild as string;\n            }\n          } else if (bChild === null) {\n            if ((aFlags & VNodeFlags.ChildrenVNode) !== 0) {\n              _removeAllChildren(instance as Element, aChild as VNode);\n            } else if ((aFlags & VNodeFlags.UnsafeHTML) !== 0) {\n              (instance as Element).textContent = \"\";\n            } else { // (bParentFlags & VNodeFlags.InputElement)\n              /**\n               * When value/checked isn't specified, we should just ignore it.\n               */\n            }\n          } else {\n            if ((aFlags & VNodeFlags.ChildrenVNode) !== 0) {\n              _syncChildrenTrackByKeys(instance as Element, aChild as VNode, bChild as VNode, context, dirtyContext);\n            } else if ((aFlags & VNodeFlags.UnsafeHTML) !== 0) {\n              (instance as Element).innerHTML = bChild as string;\n            } else { // (aParentFlags & VNodeFlags.InputElement)\n              /**\n               * Input elements has an internal state with a `value` property, so it should be checked before an\n               * assignment to prevent unnecessary events when `value` is the same as the `value` in the internal\n               * state.\n               *\n               * In general we don't want to override behaviour of DOM Elements with an internal state. Assigning props\n               * to such elements should be treated as a one-time assignment, so it works almost like `value` attribute,\n               * except when a new value is passed down, it can override previous value when it doesn't match the\n               * previous one. There is absolutely no reasons to overcomplicate such behaviour just to make it more\n               * beatiful like it is a declarative assignment and can't be changed, because in real applications,\n               * component that controls this element will always track changes, and when it changes it will invalidate\n               * its representation, so everything will stay in-sync.\n               */\n              if (typeof bChild === \"string\") {\n                if ((instance as HTMLInputElement).value !== bChild) {\n                  (instance as HTMLInputElement).value = bChild;\n                }\n              } else {\n                (instance as HTMLInputElement).checked = bChild as boolean;\n              }\n            }\n          }\n        }\n      }\n    } else { // (flags & VNodeFlags.Component)\n      if ((bFlags & VNodeFlags.StatefulComponent) !== 0) {\n        const component = instance as Component<any>;\n        // Update component props\n        const oldProps = a.props;\n        const newProps = b.props;\n        if (oldProps !== newProps) {\n          // There is no reason to call `newPropsReceived` when props aren't changed, even when they are\n          // reassigned later to reduce memory usage.\n          component.newPropsReceived(oldProps, newProps);\n        }\n        // Reassign props even when they aren't changed to reduce overall memory usage.\n        //\n        // New value always stays alive because it is referenced from virtual dom tree, so instead of keeping\n        // in memory two values even when they are the same, we just always reassign it to the new value.\n        component.props = newProps;\n\n        if (\n          ((component.flags & ComponentFlags.Dirty) !== 0) ||\n          (component.shouldUpdate(oldProps, newProps) === true)\n        ) {\n          syncVNode(\n            parent,\n            a.children as VNode,\n            b.children = DEBUG ?\n              shouldBeSingleVNode(component.render()) :\n              /* istanbul ignore next */component.render(),\n            context,\n            dirtyContext,\n          );\n          component.flags &= ~ComponentFlags.Dirty;\n          component.updated(true);\n        } else {\n          if (dirtyCheck(parent, b.children = a.children as VNode, context, dirtyContext) !== 0) {\n            component.updated(false);\n          }\n        }\n      } else { // (flags & VNodeFlags.ComponentFunction)\n        const sc = b.tag as StatelessComponent<any>;\n\n        if ((bFlags & (VNodeFlags.UpdateContext | VNodeFlags.Connect)) !== 0) {\n          if ((bFlags & VNodeFlags.Connect) !== 0) {\n            const connect = b.tag as ConnectDescriptor<any, any, {}>;\n            const prevSelectData = instance;\n            const selectData = connect.select(prevSelectData, b.props, context);\n            b.instance = selectData;\n            if (prevSelectData === selectData) {\n              b.children = a.children;\n              dirtyCheck(parent, b.children as VNode, context, dirtyContext);\n            } else {\n              syncVNode(\n                parent,\n                a.children as VNode,\n                b.children = DEBUG ?\n                  shouldBeSingleVNode(connect.render(selectData)) :\n                  /* istanbul ignore next */connect.render(selectData),\n                context,\n                dirtyContext,\n              );\n            }\n          } else {\n            if (a.props !== b.props) {\n              dirtyContext = true;\n            }\n            b.instance = context = (dirtyContext === true) ?\n              { ...context, ...b.props } :\n              instance as {};\n            syncVNode(parent, a.children as VNode, b.children as VNode, context, dirtyContext);\n          }\n        } else {\n          if (\n            (a.props !== b.props) &&\n            ((bFlags & VNodeFlags.ShouldUpdateHint) === 0 || sc.shouldUpdate!(a.props, b.props) === true)\n          ) {\n            syncVNode(\n              parent,\n              a.children as VNode,\n              b.children = DEBUG ?\n                shouldBeSingleVNode(sc.render(b.props)) :\n                /* istanbul ignore next */sc.render(b.props),\n              context,\n              dirtyContext,\n            );\n          } else {\n            b.children = a.children;\n            dirtyCheck(parent, b.children as VNode, context, dirtyContext);\n          }\n        }\n      }\n    }\n  } else {\n    instance = _render(parent, b, context);\n    /* istanbul ignore else */\n    if (DEBUG) {\n      parent.replaceChild(instance, getDOMInstanceFromVNode(a)!);\n    } else {\n      nodeReplaceChild.call(parent, instance, getDOMInstanceFromVNode(a)!);\n    }\n    _detach(a);\n    _attach(b);\n  }\n}\n\n/**\n * Sync children.\n *\n * High-level overview of the algorithm that is implemented in this function (this overview doesn't include some details\n * how it handles nodes with implicit keys and many small tricks to reduce memory allocations and unnecessary work).\n *\n * This algorithm finds a minimum[1] number of DOM operations. It works in several steps:\n *\n * 1. Find common suffix and prefix.\n *\n * This optimization technique is searching for nodes with identical keys by simultaneously iterating over nodes in the\n * old children list `A` and new children list `B` from both sides:\n *\n *  A: -> [a b c d] <-\n *  B: -> [a b d] <-\n *\n * Here we can skip nodes \"a\" and \"b\" at the begininng, and node \"d\" at the end.\n *\n *  A: -> [c] <-\n *  B: -> [] <-\n *\n * Here it will check if the size of one of the list is equal to zero. When length of the old children list is zero,\n * it will insert all remaining nodes from the new list, and when length of the new children list is zero, it will\n * remove all remaining nodes from the old list.\n *\n * When algorithm can't find a solution with this simple optimization technique, it will go to the next step of the\n * algorithm. For example:\n *\n *  A: -> [a b c d e f g] <-\n *  B: -> [a c b h f e g] <-\n *\n * Nodes \"a\" and \"g\" at the edges are the same, skipping them.\n *\n *  A: -> [b c d e f] <-\n *  B: -> [c b h f e] <-\n *\n * Here we are stuck, so we need to switch to the next step.\n *\n * 2. Look for removed and inserted nodes, and simultaneously check if one of the nodes is moved.\n *\n * First we create an array `P` with the length of the new children list and assign to each position value `-1`, it has\n * a meaning of a new node that should be inserted. Later we will assign node positions in the old children list to this\n * array.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [. . . . .] // . == -1\n *\n * Then we need to build an index `I` that maps keys with node positions of the remaining nodes from the new children\n * list.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [. . . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 0\n *\n * With this index, we start to iterate over the remaining nodes from the old children list and check if we can find a\n * node with the same key in the index. If we can't find any node, it means that it should be removed, otherwise we\n * assign position of the node in the old children list to the positions array.\n *\n *  A: [b c d e f]\n *      ^\n *  B: [c b h f e]\n *  P: [. 0 . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1, <-\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 1\n *\n * When we assigning positions to the positions array, we also keep a position of the last seen node in the new children\n * list, if the last seen position is larger than current position of the node at the new list, then we are switching\n * `moved` flag to `true`.\n *\n *  A: [b c d e f]\n *        ^\n *  B: [c b h f e]\n *  P: [1 0 . . .] // . == -1\n *  I: {\n *    c: 0, <-\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 1 // last > 0; moved = true\n *\n * The last position `1` is larger than current position of the node at the new list `0`, switching `moved` flag to\n * `true`.\n *\n *  A: [b c d e f]\n *          ^\n *  B: [c b h f e]\n *  P: [1 0 . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  moved = true\n *\n * Node with key \"d\" doesn't exist in the index, removing node.\n *\n *  A: [b c d e f]\n *            ^\n *  B: [c b h f e]\n *  P: [1 0 . . 3] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4, <-\n *  }\n *  moved = true\n *\n * Assign position for `e`.\n *\n *  A: [b c d e f]\n *              ^\n *  B: [c b h f e]\n *  P: [1 0 . 4 3] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3, <-\n *    e: 4,\n *  }\n *  moved = true\n *\n * Assign position for 'f'.\n *\n * At this point we are checking if `moved` flag is on, or if the length of the old children list minus the number of\n * removed nodes isn't equal to the length of the new children list. If any of this conditions is true, then we are\n * going to the next step.\n *\n * 3. Find minimum number of moves if `moved` flag is on, or insert new nodes if the length is changed.\n *\n * When `moved` flag is on, we need to find the\n * [longest increasing subsequence](http://en.wikipedia.org/wiki/Longest_increasing_subsequence) in the positions array,\n * and move all nodes that doesn't belong to this subsequence.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *  moved = true\n *\n * Now we just need to simultaneously iterate over the new children list and LIS from the end and check if the current\n * position is equal to a value from LIS.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *              ^  // new_pos == 4\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *              ^  // new_pos == 4\n *  moved = true\n *\n * Node \"e\" stays at the same place.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *            ^    // new_pos == 3\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *            ^    // new_pos != 1\n *  moved = true\n *\n * Node \"f\" is moved, move it before the next node \"e\".\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *          ^      // new_pos == 2\n *  P: [1 0 . 4 3] // . == -1\n *          ^      // old_pos == -1\n *  LIS:     [1 4]\n *            ^\n *  moved = true\n *\n * Node \"h\" has a `-1` value in the positions array, insert new node \"h\".\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *        ^        // new_pos == 1\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *            ^    // new_pos == 1\n *  moved = true\n *\n * Node \"b\" stays at the same place.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *      ^          // new_pos == 0\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *          ^      // new_pos != undefined\n *  moved = true\n *\n * Node \"c\" is moved, move it before the next node \"b\".\n *\n * When moved flag is off, we don't need to find LIS, and we just iterate over the new children list and check its\n * current position in the positions array, if it is `-1`, then we insert new node.\n *\n * [1] Actually it is almost minimum number of dom ops, when node is removed and another one is inserted at the same\n * place, instead of insert and remove dom ops, we can use one replace op. It will make everything even more\n * complicated, and other use cases will be slower, so I don't think that it is worth to use replace here.\n *\n * @param parent Parent node.\n * @param a Old VNode list.\n * @param b New VNode list.\n * @param context Current context.\n * @param dirtyContext Dirty context.\n */\nfunction _syncChildrenTrackByKeys(\n  parent: Node,\n  aFirstNode: VNode,\n  bFirstNode: VNode,\n  context: {},\n  dirtyContext: boolean,\n): void {\n  const aLastNode = aFirstNode.prev!;\n  const bLastNode = bFirstNode.prev!;\n  let aStartNode: VNode<any> | null = aFirstNode;\n  let bStartNode: VNode<any> | null = bFirstNode;\n  let aEndNode: VNode<any> = aLastNode;\n  let bEndNode: VNode<any> = bLastNode;\n  let aNode: VNode<any> | null;\n  let bNode: VNode<any> | null;\n  let i: number;\n  let j: number | undefined;\n  let next: Node | null;\n  let synced = 0;\n  let finished = 0;\n\n  // Step 1\n  outer: while (true) {\n    // Sync nodes with the same key at the beginning.\n    while (_eqKeys(aStartNode!, bStartNode!) === true) {\n      syncVNode(parent, aStartNode!, bStartNode!, context, dirtyContext);\n      synced++;\n      if (aStartNode === aEndNode) {\n        finished |= 1;\n      } else {\n        aStartNode = aStartNode!.next;\n      }\n      if (bStartNode === bEndNode) {\n        finished |= 2;\n      } else {\n        bStartNode = bStartNode!.next;\n      }\n      if (finished) {\n        break outer;\n      }\n    }\n\n    // Sync nodes with the same key at the end.\n    while (_eqKeys(aEndNode, bEndNode) === true) {\n      syncVNode(parent, aEndNode, bEndNode, context, dirtyContext);\n      synced++;\n      if (aStartNode === aEndNode) {\n        finished |= 1;\n      } else {\n        aEndNode = aEndNode.prev;\n      }\n      if (bStartNode === bEndNode) {\n        finished |= 2;\n      } else {\n        bEndNode = bEndNode.prev;\n      }\n      if (finished) {\n        break outer;\n      }\n    }\n\n    break;\n  }\n\n  if (finished) {\n    if (finished !== 3) {\n      if (finished === 1) {\n        // All nodes from a are synced, insert the rest from b.\n        next = bEndNode.next === null ? null : getDOMInstanceFromVNode(bEndNode.next!);\n        do {\n          renderVNode(parent, next, bStartNode!, context);\n          bStartNode = bStartNode!.next;\n        } while (bStartNode !== bEndNode.next);\n      } else {\n        // All nodes from b are synced, remove the rest from a.\n        do {\n          removeVNode(parent, aStartNode!);\n          aStartNode = aStartNode!.next;\n        } while (aStartNode !== aEndNode.next);\n      }\n    }\n  } else { // Step 2\n    // Inner length after prefix/suffix optimization.\n    let aInnerLength = 0;\n    let bInnerLength = 0;\n\n    // Flag indicating that some node should be moved.\n    let moved = false;\n\n    // Reverse indexes for keys.\n    let keyIndex: Map<any, number> | undefined;\n    let positionKeyIndex: Map<number, number> | undefined;\n\n    bNode = bStartNode;\n    do {\n      if (bNode!.flags & VNodeFlags.Key) {\n        if (keyIndex === undefined) {\n          keyIndex = new Map<any, number>();\n        }\n        keyIndex.set(bNode!.key, bInnerLength);\n      } else {\n        if (positionKeyIndex === undefined) {\n          positionKeyIndex = new Map<number, number>();\n        }\n        positionKeyIndex.set(bNode!.key, bInnerLength);\n      }\n      bInnerLength++;\n      bNode = bNode!.next;\n    } while (bNode !== bEndNode.next);\n\n    // Mark all nodes as inserted.\n    const bArray = new Array<VNode<any>>(bInnerLength);\n    const sources = new Array<number>(bInnerLength).fill(-1);\n\n    bNode = bStartNode;\n    for (i = 0; i < bInnerLength; i++) {\n      bArray[i] = bNode!;\n      bNode = bNode!.next;\n    }\n\n    let innerSynced = 0;\n    i = 0;\n    aNode = aStartNode;\n    do {\n      if (aNode!.flags & VNodeFlags.Key) {\n        j = keyIndex ? keyIndex.get(aNode!.key) : undefined;\n      } else {\n        j = positionKeyIndex ? positionKeyIndex.get(aNode!.key) : undefined;\n      }\n\n      if (j === undefined) {\n        aNode!.key = null;\n      } else {\n        sources[j] = aInnerLength;\n        if (i > j) {\n          moved = true;\n        } else {\n          i = j;\n        }\n        bNode = bArray[j];\n        syncVNode(parent, aNode!, bNode, context, dirtyContext);\n        innerSynced++;\n      }\n      aInnerLength++;\n      aNode = aNode!.next;\n    } while (aNode !== aEndNode.next);\n\n    if (!synced && !innerSynced) {\n      // Noone is synced, remove all children with one dom op.\n      _removeAllChildren(parent, aFirstNode);\n      while (bStartNode !== bEndNode.next) {\n        renderVNode(parent, null, bStartNode!, context);\n        bStartNode = bStartNode!.next;\n      }\n    } else {\n      i = aInnerLength - innerSynced;\n      while (i > 0) {\n        if (aStartNode!.key === null) {\n          removeVNode(parent, aStartNode!);\n          i--;\n        }\n        aStartNode = aStartNode!.next;\n      }\n\n      // Step 3\n      if (moved) {\n        const seq = lis(sources);\n        j = seq.length - 1;\n        bNode = bEndNode;\n        for (i = bInnerLength - 1; i >= 0; i--) {\n          if (sources[i] === -1) {\n            next = bNode.next === null ? null : getDOMInstanceFromVNode(bNode.next);\n            renderVNode(parent, next, bNode!, context);\n          } else {\n            if (j < 0 || i !== seq[j]) {\n              next = bNode.next === null ? null : getDOMInstanceFromVNode(bNode.next);\n              /* istanbul ignore else */\n              if (DEBUG) {\n                parent.insertBefore(getDOMInstanceFromVNode(bNode)!, next);\n              } else {\n                nodeInsertBefore.call(parent, getDOMInstanceFromVNode(bNode)!, next);\n              }\n            } else {\n              j--;\n            }\n          }\n          bNode = bNode.prev;\n        }\n      } else if (innerSynced !== bInnerLength) {\n        bNode = bEndNode;\n        for (i = bInnerLength - 1; i >= 0; i--) {\n          if (sources[i] === -1) {\n            next = bNode.next === null ? null : getDOMInstanceFromVNode(bNode.next);\n            renderVNode(parent, next, bNode, context);\n          }\n          bNode = bNode.prev;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Slightly modified Longest Increased Subsequence algorithm, it ignores items that have -1 value, they're representing\n * new items.\n *\n * http://en.wikipedia.org/wiki/Longest_increasing_subsequence\n *\n * @param a Array of numbers.\n * @returns Longest increasing subsequence.\n * @noinline\n */\nfunction lis(a: number[]): number[] {\n  const p = a.slice();\n  const result: number[] = [];\n  result.push(0);\n  let u: number;\n  let v: number;\n\n  for (let i = 0, il = a.length; i < il; ++i) {\n    if (a[i] === -1) {\n      continue;\n    }\n\n    const j = result[result.length - 1];\n    if (a[j] < a[i]) {\n      p[i] = j;\n      result.push(i);\n      continue;\n    }\n\n    u = 0;\n    v = result.length - 1;\n\n    while (u < v) {\n      const c = ((u + v) / 2) | 0;\n      if (a[result[c]] < a[i]) {\n        u = c + 1;\n      } else {\n        v = c;\n      }\n    }\n\n    if (a[i] < a[result[u]]) {\n      if (u > 0) {\n        p[i] = result[u - 1];\n      }\n      result[u] = i;\n    }\n  }\n\n  u = result.length;\n  v = result[u - 1];\n\n  while (u-- > 0) {\n    result[u] = v;\n    v = p[v];\n  }\n\n  return result;\n}\n\nfunction shouldBeSingleVNode<T extends VNode>(vnode: T): T {\n  if (vnode.prev !== vnode) {\n    throw new Error(\"Invalid render function. Render function should return singular VNode.\");\n  }\n  return vnode;\n}\n","import { USER_AGENT, UserAgentFlags, NOOP, unorderedArrayDelete } from \"ivi-core\";\nimport { setUpdateDOMHandler, nextFrameWrite, triggerNextFrame } from \"ivi-scheduler\";\nimport { VNode } from \"./vnode\";\nimport { renderVNode, syncVNode, removeVNode, dirtyCheck } from \"./implementation\";\nimport { checkNestingViolations } from \"../dev_mode/html_nesting_rules\";\n\n/**\n * Root.\n */\nexport interface Root {\n  container: Element;\n  currentVNode: VNode | null;\n  newVNode: VNode | null;\n  invalidated: boolean;\n}\n\n/**\n * Root nodes.\n */\nexport const ROOTS = [] as Root[];\n\n/**\n * Empty Context object.\n */\nconst EMPTY_CONTEXT = {};\n\nlet _pendingUpdate = false;\n\n/**\n * Find Root node in container.\n *\n * @param container DOM Node that contains root node.\n * @returns root node or undefined when root node doesn't exist.\n */\nexport function findRoot(container: Element): Root | undefined {\n  for (let i = 0; i < ROOTS.length; ++i) {\n    const r = ROOTS[i];\n    if (r.container === container) {\n      return r;\n    }\n  }\n\n  return;\n}\n\n/**\n * Update root nodes.\n */\nfunction _update() {\n  if (_pendingUpdate) {\n    _pendingUpdate = false;\n    setUpdateDOMHandler(update);\n    for (let i = 0; i < ROOTS.length; ++i) {\n      const root = ROOTS[i];\n      const container = root.container;\n      const currentVNode = root.currentVNode;\n\n      if (root.invalidated) {\n        const newVNode = root.newVNode;\n\n        if (newVNode) {\n          if (currentVNode) {\n            syncVNode(container, currentVNode, newVNode, EMPTY_CONTEXT, false);\n          } else {\n            renderVNode(container, null, newVNode!, EMPTY_CONTEXT);\n            /* istanbul ignore if */\n            /**\n             * Fix for the Mouse Event bubbling on iOS devices.\n             *\n             * #quirks\n             *\n             * http://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n             */\n            if (TARGET === \"browser\" && (USER_AGENT & UserAgentFlags.iOS)) {\n              (container as HTMLElement).onclick = NOOP;\n            }\n          }\n          root.currentVNode = newVNode;\n        } else if (currentVNode) {\n          removeVNode(container, currentVNode);\n          unorderedArrayDelete(ROOTS, ROOTS.indexOf(root));\n          --i;\n        }\n\n        root.newVNode = null;\n        root.invalidated = false;\n      } else if (currentVNode) {\n        dirtyCheck(container, currentVNode, EMPTY_CONTEXT, false);\n      }\n\n      /* istanbul ignore else */\n      if (DEBUG) {\n        if (root.currentVNode) {\n          checkNestingViolations(container, root.currentVNode);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Render VNode into container.\n *\n * @param node VNode to render.\n * @param container DOM Node that will contain rendered node.\n */\nexport function render(\n  node: VNode | null,\n  container: Element,\n): void {\n  renderNextFrame(node, container);\n  triggerNextFrame();\n}\n\n/**\n * Render VNode into container on the next frame.\n *\n * @param node VNode to render.\n * @param container DOM Node that will contain rendered node.\n */\nexport function renderNextFrame(\n  node: VNode | null,\n  container: Element,\n): void {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (container === document.body) {\n      throw new Error(\"Rendering in the <body> aren't allowed, create an element inside body that will contain \" +\n        \"your application.\");\n    }\n    if (!document.body.contains(container)) {\n      throw new Error(\"Container element should be attached to the document.\");\n    }\n  }\n\n  const root = findRoot(container);\n  if (root) {\n    root.newVNode = node;\n    root.invalidated = true;\n  } else {\n    ROOTS.push({\n      container: container,\n      currentVNode: null,\n      newVNode: node,\n      invalidated: true,\n    });\n  }\n\n  updateNextFrame();\n}\n\n/**\n * update updates dirty components.\n */\nexport function update() {\n  updateNextFrame();\n  triggerNextFrame();\n}\n\n/**\n * updateNextFrame adds a task to update dirty components that will be executed at the next frame.\n */\nexport function updateNextFrame() {\n  if (!_pendingUpdate) {\n    _pendingUpdate = true;\n    nextFrameWrite(_update);\n  }\n}\n","import { SyntheticEventFlags } from \"./flags\";\n\n/**\n * SyntheticEvent is a base class for all synthetic events.\n */\nexport class SyntheticEvent {\n  /**\n   * See `SyntheticEventFlags` for details.\n   */\n  flags: SyntheticEventFlags;\n  /**\n   * Timestamp when event was created.\n   */\n  readonly timestamp: number;\n\n  constructor(\n    flags: SyntheticEventFlags,\n    timestamp: number,\n  ) {\n    this.flags = flags;\n    this.timestamp = timestamp;\n  }\n\n  /**\n   * Stops event propagation.\n   */\n  stopPropagation() {\n    this.flags |= SyntheticEventFlags.StoppedPropagation;\n  }\n\n  /**\n   * Prevents default behaviour for an event.\n   */\n  preventDefault() {\n    this.flags |= SyntheticEventFlags.PreventedDefault;\n  }\n}\n\nexport class SyntheticNativeEvent<E extends Event> extends SyntheticEvent {\n  readonly target: any;\n  native: E;\n\n  constructor(\n    flags: SyntheticEventFlags,\n    target: EventTarget,\n    timestamp: number,\n    native: E,\n  ) {\n    super(flags, timestamp);\n    this.target = target;\n    this.native = native;\n  }\n}\n","import { EventHandler } from \"./event_handler\";\nimport { DispatchTarget } from \"./dispatch\";\nimport { getEventHandlersFromDOMNode } from \"./utils\";\n\n/**\n * accumulateDispatchTargetsFromElement accumulates matching Event Handlers in `result` array from the `target` Element.\n *\n * @param result Accumulated Dispatch Targets.\n * @param target Target Element.\n * @param match Matching function.\n */\nexport function accumulateDispatchTargetsFromElement(\n  result: DispatchTarget[],\n  target: Element,\n  match: (h: EventHandler) => boolean,\n): void {\n  const events = getEventHandlersFromDOMNode(target);\n  if (events !== null && events !== undefined) {\n    let matches: EventHandler[] | EventHandler | undefined;\n    if (events instanceof Array) {\n      let count = 0;\n      for (let i = 0; i < events.length; ++i) {\n        const h = events[i];\n        if (h !== null && match(h) === true) {\n          if (count === 0) {\n            matches = h;\n          } else if (count === 1) {\n            matches = [matches as EventHandler, h];\n          } else {\n            (matches as EventHandler[]).push(h);\n          }\n          ++count;\n        }\n      }\n    } else {\n      if (match(events) === true) {\n        matches = events;\n      }\n    }\n    if (matches !== undefined) {\n      result.push({\n        target: target,\n        handlers: matches,\n      });\n    }\n  }\n}\n\n/**\n * accumulateDispatchTargets traverses the DOM tree from the `target` Element to the document top and accumulates\n * matching Event Handlers in `result` array.\n *\n * @param result Accumulated Dispatch Targets.\n * @param target Target DOM Element.\n * @param match Matching function.\n */\nexport function accumulateDispatchTargets(\n  result: DispatchTarget[],\n  target: Element | null,\n  match: (h: EventHandler) => boolean,\n): void {\n  while (target !== null) {\n    accumulateDispatchTargetsFromElement(result, target, match);\n    target = target.parentElement;\n  }\n}\n","import { EventHandlerFlags, SyntheticEventFlags, EventFlags } from \"./flags\";\nimport { EventHandler } from \"./event_handler\";\nimport { SyntheticEvent } from \"./synthetic_event\";\n\n/**\n * DispatchTarget.\n */\nexport interface DispatchTarget {\n  /**\n   * Target.\n   */\n  target: any;\n  /**\n   * Matched Event Handlers.\n   */\n  handlers: EventHandler | EventHandler[];\n}\n\nfunction getFlags(flags: EventFlags | void): EventFlags {\n  return (flags === void 0) ? 0 : flags;\n}\n\n/**\n * dispatchEventToLocalEventHandlers dispatches event to local(at the same DOM Node) event handlers.\n *\n * @param target Dispatch Target.\n * @param event Synthetic Event.\n * @param matchFlags Flags that should match to deliver event.\n * @param dispatch Dispatch callback.\n */\nfunction dispatchEventToLocalEventHandlers(\n  target: DispatchTarget,\n  event: SyntheticEvent,\n  matchFlags: EventHandlerFlags,\n  dispatch: ((h: EventHandler, ev: SyntheticEvent) => EventFlags | void) | undefined,\n): void {\n  const handlers = target.handlers;\n  let flags: EventFlags = 0;\n\n  if (Array.isArray(handlers)) {\n    for (let j = 0; j < handlers.length; ++j) {\n      const handler = handlers[j];\n      if ((handler.flags & matchFlags) !== 0) {\n        flags |= getFlags((dispatch === void 0) ? handler.handler(event) : dispatch(handler, event));\n      }\n    }\n  } else {\n    if ((handlers.flags & matchFlags) !== 0) {\n      flags = getFlags((dispatch === void 0) ? handlers.handler(event) : dispatch(handlers, event));\n    }\n  }\n\n  event.flags |= flags;\n}\n\n/**\n * dispatchEvent dispatches event to the list of dispatch targets.\n *\n * Simplified version of w3 Events flow algorithm. This algorithm doesn't include target phase, only capture and\n * bubbling phases. We don't care too much about w3 events compatibility, and there aren't any use cases that require\n * target phase.\n *\n * https://www.w3.org/TR/DOM-Level-3-Events/#event-flow\n *\n * @param targets Dispatch targets.\n * @param event Event to dispatch.\n * @param bubble Use bubbling phase.\n * @param dispatch Dispatch callback.\n */\nexport function dispatchEvent(\n  targets: DispatchTarget[],\n  event: SyntheticEvent,\n  bubble: boolean,\n  dispatch?: (h: EventHandler, ev: SyntheticEvent) => EventFlags | void,\n): void {\n  let i = targets.length - 1;\n  let target;\n\n  // capture phase\n  while (i >= 0) {\n    target = targets[i--];\n    dispatchEventToLocalEventHandlers(target, event, EventHandlerFlags.Capture, dispatch);\n    if ((event.flags & SyntheticEventFlags.StoppedPropagation) !== 0) {\n      return;\n    }\n  }\n\n  // bubble phase\n  if (bubble === true) {\n    event.flags |= SyntheticEventFlags.BubblePhase;\n    for (i = 0; i < targets.length; ++i) {\n      dispatchEventToLocalEventHandlers(targets[i], event, EventHandlerFlags.Bubble, dispatch);\n      if ((event.flags & SyntheticEventFlags.StoppedPropagation) !== 0) {\n        return;\n      }\n    }\n  }\n}\n","import { append, unorderedArrayDelete, catchError } from \"ivi-core\";\nimport { getEventTarget, getNativeEventOptions } from \"./utils\";\nimport { NativeEventSourceFlags, SyntheticEventFlags } from \"./flags\";\nimport { SyntheticNativeEvent } from \"./synthetic_event\";\nimport { EventSource } from \"./event_source\";\nimport { EventHandler } from \"./event_handler\";\nimport { accumulateDispatchTargets } from \"./traverse_dom\";\nimport { DispatchTarget, dispatchEvent } from \"./dispatch\";\n\n/**\n * NativeEventSource dispatches native events.\n *\n * It is using two-phase dispatching algorithm similar to native DOM events flow.\n */\nexport interface NativeEventSource<E extends Event> {\n  /**\n   * Public EventSource interface.\n   */\n  readonly eventSource: EventSource;\n  /**\n   * Number of active dependencies.\n   *\n   * When there are active dependencies, event source will be activated by attaching native event listeners to the\n   * document. When it goes to zero it will be deactivated, and all event listeners will be removed.\n   */\n  dependencies: number;\n  /**\n   * Number of active listeners.\n   */\n  listeners: number;\n  /**\n   * See `NativeEventSourceFlags` for details.\n   */\n  flags: NativeEventSourceFlags;\n  /**\n   * DOM event name.\n   */\n  readonly name: string;\n  onBeforeListeners: Array<(ev: SyntheticNativeEvent<E>) => void> | null;\n  onAfterListeners: Array<(ev: SyntheticNativeEvent<E>) => void> | null;\n  dispatch: (() => void) | null;\n}\n\nexport function createNativeEventSource<E extends Event>(\n  flags: NativeEventSourceFlags,\n  name: string,\n): NativeEventSource<E> {\n  const source: NativeEventSource<E> = {\n    eventSource: {\n      addListener: () => { ++source.listeners; incDependencies(source); },\n      removeListener: () => { --source.listeners; decDependencies(source); },\n    },\n    dependencies: 0,\n    listeners: 0,\n    flags: flags,\n    name: name,\n    onBeforeListeners: null,\n    onAfterListeners: null,\n    dispatch: null,\n  };\n\n  const matchEventSource = (h: EventHandler) => h.source === source.eventSource;\n\n  source.dispatch = catchError((ev: E): void => {\n    const targets: DispatchTarget[] = [];\n    if (source.listeners > 0) {\n      accumulateDispatchTargets(targets, getEventTarget(ev) as Element, matchEventSource);\n    }\n\n    if (targets.length || source.onBeforeListeners !== null || source.onAfterListeners !== null) {\n      const syntheticEvent = new SyntheticNativeEvent<E>(0, getEventTarget(ev), ev.timeStamp, ev);\n\n      dispatchToListeners(source.onBeforeListeners, syntheticEvent);\n      if (targets.length) {\n        dispatchEvent(targets, syntheticEvent, (source.flags & NativeEventSourceFlags.Bubbles) !== 0);\n      }\n      dispatchToListeners(source.onAfterListeners, syntheticEvent);\n\n      if ((syntheticEvent.flags & SyntheticEventFlags.PreventedDefault) !== 0) {\n        ev.preventDefault();\n      }\n    }\n  });\n\n  return source;\n}\n\nexport function addBeforeListener<E extends Event>(\n  source: NativeEventSource<E>,\n  cb: (e: SyntheticNativeEvent<E>) => void,\n): void {\n  source.onBeforeListeners = append(source.onBeforeListeners, cb);\n  incDependencies(source);\n}\n\nexport function addAfterListener<E extends Event>(\n  source: NativeEventSource<E>,\n  cb: (e: SyntheticNativeEvent<E>) => void,\n): void {\n  source.onAfterListeners = append(source.onAfterListeners, cb);\n  incDependencies(source);\n}\n\nexport function removeBeforeListener<E extends Event>(\n  source: NativeEventSource<E>,\n  cb: (e: SyntheticNativeEvent<E>) => void,\n): void {\n  if (source.onBeforeListeners !== null) {\n    unorderedArrayDelete(source.onBeforeListeners, source.onBeforeListeners.indexOf(cb));\n    decDependencies(source);\n  }\n}\n\nexport function removeAfterListener<E extends Event>(\n  source: NativeEventSource<E>,\n  cb: (e: SyntheticNativeEvent<E>) => void,\n): void {\n  if (source.onAfterListeners !== null) {\n    unorderedArrayDelete(source.onAfterListeners, source.onAfterListeners.indexOf(cb));\n    decDependencies(source);\n  }\n}\n\nfunction incDependencies<E extends Event>(source: NativeEventSource<E>): void {\n  if (source.dependencies++ === 0) {\n    document.addEventListener(\n      source.name,\n      source.dispatch!,\n      getNativeEventOptions(source.flags) as boolean,\n    );\n  }\n}\n\nfunction decDependencies<E extends Event>(source: NativeEventSource<E>): void {\n  if (--source.dependencies === 0) {\n    document.removeEventListener(\n      source.name,\n      source.dispatch!,\n      getNativeEventOptions(source.flags) as boolean,\n    );\n  }\n}\n\nfunction dispatchToListeners<E extends Event>(\n  listeners: Array<(ev: SyntheticNativeEvent<E>) => void> | null,\n  ev: SyntheticNativeEvent<E>,\n): void {\n  if (listeners !== null) {\n    const cbs = listeners.slice();\n    for (let i = 0; i < cbs.length; ++i) {\n      cbs[i](ev);\n    }\n  }\n}\n","/**\n * Event Handlers.\n *\n * Optimizing compilers should inline all this functions and completely remove unused code.\n */\n\nimport { EventHandlerFlags, NativeEventSourceFlags, EventFlags } from \"./flags\";\nimport { EventHandler } from \"./event_handler\";\nimport { EventSource } from \"./event_source\";\nimport { NativeEventSource, createNativeEventSource } from \"./native_event_source\";\nimport { SyntheticNativeEvent } from \"./synthetic_event\";\n\n/* tslint:disable:max-line-length */\nexport const EventSourceAbort: NativeEventSource<UIEvent> = /*#__PURE__*/createNativeEventSource<UIEvent>(NativeEventSourceFlags.Capture, \"abort\");\nexport const EventSourceActivate = /*#__PURE__*/createNativeEventSource<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"activate\");\nexport const EventSourceAriaRequest = /*#__PURE__*/createNativeEventSource<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"ariarequest\");\nexport const EventSourceBeforeActivate = /*#__PURE__*/createNativeEventSource<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"beforeactivate\");\nexport const EventSourceBeforeCopy = /*#__PURE__*/createNativeEventSource<ClipboardEvent>(NativeEventSourceFlags.Capture, \"beforecopy\");\nexport const EventSourceBeforeCut = /*#__PURE__*/createNativeEventSource<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"beforecut\");\nexport const EventSourceBeforeDeactivate = /*#__PURE__*/createNativeEventSource<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"beforedeactivate\");\nexport const EventSourceBeforePaste = /*#__PURE__*/createNativeEventSource<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"beforepaste\");\nexport const EventSourceBlur = /*#__PURE__*/createNativeEventSource<FocusEvent>(NativeEventSourceFlags.Capture, \"blur\");\nexport const EventSourceCanPlay = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"canplay\");\nexport const EventSourceCanPlaythrough = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"canplaythrough\");\nexport const EventSourceChange = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"change\");\nexport const EventSourceClick = /*#__PURE__*/createNativeEventSource<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"click\");\nexport const EventSourceContextMenu = /*#__PURE__*/createNativeEventSource<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"contextmenu\");\nexport const EventSourceCopy = /*#__PURE__*/createNativeEventSource<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"copy\");\nexport const EventSourceCueChange = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"cuechange\");\nexport const EventSourceCut = /*#__PURE__*/createNativeEventSource<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"cut\");\nexport const EventSourceDoubleClick = /*#__PURE__*/createNativeEventSource<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dblclick\");\nexport const EventSourceDeactivate = /*#__PURE__*/createNativeEventSource<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"deactivate\");\nexport const EventSourceDrag = /*#__PURE__*/createNativeEventSource<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"drag\");\nexport const EventSourceDragEnd = /*#__PURE__*/createNativeEventSource<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragend\");\nexport const EventSourceDragEnter = /*#__PURE__*/createNativeEventSource<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragenter\");\nexport const EventSourceDragLeave = /*#__PURE__*/createNativeEventSource<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragleave\");\nexport const EventSourceDragOver = /*#__PURE__*/createNativeEventSource<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragover\");\nexport const EventSourceDragStart = /*#__PURE__*/createNativeEventSource<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragstart\");\nexport const EventSourceDrop = /*#__PURE__*/createNativeEventSource<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"drop\");\nexport const EventSourceDurationChange = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"durationchange\");\nexport const EventSourceEmptied = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"emptied\");\nexport const EventSourceEncrypted = /*#__PURE__*/createNativeEventSource<MediaEncryptedEvent>(NativeEventSourceFlags.Capture, \"encrypted\");\nexport const EventSourceEnded = /*#__PURE__*/createNativeEventSource<MediaStreamErrorEvent>(NativeEventSourceFlags.Capture, \"ended\");\nexport const EventSourceError = /*#__PURE__*/createNativeEventSource<ErrorEvent>(NativeEventSourceFlags.Capture, \"error\");\nexport const EventSourceFocus = /*#__PURE__*/createNativeEventSource<FocusEvent>(NativeEventSourceFlags.Capture, \"focus\");\nexport const EventSourceGotPointerCapture = /*#__PURE__*/createNativeEventSource<PointerEvent>(NativeEventSourceFlags.Capture, \"gotpointercapture\");\nexport const EventSourceInput = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"input\");\nexport const EventSourceInvalid = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"invalid\");\nexport const EventSourceKeyDown = /*#__PURE__*/createNativeEventSource<KeyboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"keydown\");\nexport const EventSourceKeyPress = /*#__PURE__*/createNativeEventSource<KeyboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"keypress\");\nexport const EventSourceKeyUp = /*#__PURE__*/createNativeEventSource<KeyboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"keyup\");\nexport const EventSourceLoad = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"load\");\nexport const EventSourceLoadedSata = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"loadeddata\");\nexport const EventSourceLoadedMetadata = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"loadedmetadata\");\nexport const EventSourceLoadStart = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"loadstart\");\nexport const EventSourceLostPointerCapture = /*#__PURE__*/createNativeEventSource<PointerEvent>(NativeEventSourceFlags.Capture, \"lostpointercapture\");\nexport const EventSourceMouseDown = /*#__PURE__*/createNativeEventSource<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mousedown\");\nexport const EventSourceMouseEnter = /*#__PURE__*/createNativeEventSource<MouseEvent>(NativeEventSourceFlags.Capture, \"mouseenter\");\nexport const EventSourceMouseLeave = /*#__PURE__*/createNativeEventSource<MouseEvent>(NativeEventSourceFlags.Capture, \"mouseleave\");\nexport const EventSourceMouseMove = /*#__PURE__*/createNativeEventSource<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mousemove\");\nexport const EventSourceMouseOut = /*#__PURE__*/createNativeEventSource<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mouseout\");\nexport const EventSourceMouseOver = /*#__PURE__*/createNativeEventSource<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mouseover\");\nexport const EventSourceMouseUp = /*#__PURE__*/createNativeEventSource<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mouseup\");\nexport const EventSourcePaste = /*#__PURE__*/createNativeEventSource<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"paste\");\nexport const EventSourcePause = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"pause\");\nexport const EventSourcePlay = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"play\");\nexport const EventSourcePlaying = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"playing\");\nexport const EventSourcePointerCancel = /*#__PURE__*/createNativeEventSource<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointercancel\");\nexport const EventSourcePointerDown = /*#__PURE__*/createNativeEventSource<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointerdown\");\nexport const EventSourcePointerEnter = /*#__PURE__*/createNativeEventSource<PointerEvent>(NativeEventSourceFlags.Capture, \"pointerenter\");\nexport const EventSourcePointerLeave = /*#__PURE__*/createNativeEventSource<PointerEvent>(NativeEventSourceFlags.Capture, \"pointerleave\");\nexport const EventSourcePointerMove = /*#__PURE__*/createNativeEventSource<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointermove\");\nexport const EventSourcePointerOut = /*#__PURE__*/createNativeEventSource<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointerout\");\nexport const EventSourcePointerOver = /*#__PURE__*/createNativeEventSource<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointerover\");\nexport const EventSourcePointerUp = /*#__PURE__*/createNativeEventSource<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointerup\");\nexport const EventSourceProgress = /*#__PURE__*/createNativeEventSource<ProgressEvent>(NativeEventSourceFlags.Capture, \"progress\");\nexport const EventSourceRateChange = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"ratechange\");\nexport const EventSourceReset = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"reset\");\nexport const EventSourceScroll = /*#__PURE__*/createNativeEventSource<UIEvent>(NativeEventSourceFlags.Capture, \"scroll\");\nexport const EventSourceSeeked = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"seeked\");\nexport const EventSourceSeeking = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"seeking\");\nexport const EventSourceSelect = /*#__PURE__*/createNativeEventSource<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"select\");\nexport const EventSourceSelectStart = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"selectstart\");\nexport const EventSourceStalled = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"stalled\");\nexport const EventSourceSubmit = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"submit\");\nexport const EventSourceSuspend = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"suspend\");\nexport const EventSourceTimeUpdate = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"timeupdate\");\nexport const EventSourceTouchCancel = /*#__PURE__*/createNativeEventSource<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"touchcancel\");\nexport const EventSourceTouchEnd = /*#__PURE__*/createNativeEventSource<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles | NativeEventSourceFlags.Passive, \"touchend\");\nexport const EventSourceTouchMove = /*#__PURE__*/createNativeEventSource<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles | NativeEventSourceFlags.Passive, \"touchmove\");\nexport const EventSourceTouchStart = /*#__PURE__*/createNativeEventSource<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles | NativeEventSourceFlags.Passive, \"touchstart\");\nexport const EventSourceUnload = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"unload\");\nexport const EventSourceVolumeChange = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"volumechange\");\nexport const EventSourceWaiting = /*#__PURE__*/createNativeEventSource<Event>(NativeEventSourceFlags.Capture, \"waiting\");\nexport const EventSourceWheel = /*#__PURE__*/createNativeEventSource<WheelEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles | NativeEventSourceFlags.Passive, \"wheel\");\n\nexport const EventSourceActiveTouchEnd = /*#__PURE__*/createNativeEventSource<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"touchend\");\nexport const EventSourceActiveTouchMove = /*#__PURE__*/createNativeEventSource<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"touchmove\");\nexport const EventSourceActiveTouchStart = /*#__PURE__*/createNativeEventSource<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"touchstart\");\nexport const EventSourceActiveWheel = /*#__PURE__*/createNativeEventSource<WheelEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"wheel\");\n\n/**\n * Helper function that creates Event Handler objects.\n *\n * @param dispatcher Dispatcher instance.\n * @param fn Event Handler function.\n * @param options Event Options. Value with a boolean type indicates that events of this type should use capture mode\n *   and it will be dispatched to the registered listener before being dispatched to any EventTarget beneath it in the\n *   DOM tree.\n * @returns EventHandler object.\n */\nexport function createEventHandler<E extends SyntheticNativeEvent<any>>(\n  source: EventSource,\n  fn: (ev: E) => EventFlags | void,\n  capture?: boolean,\n): EventHandler<E> {\n  return {\n    source: source,\n    flags: capture === true ? EventHandlerFlags.Capture : EventHandlerFlags.Bubble,\n    handler: fn,\n    listeners: 0,\n    props: null,\n    state: null,\n  };\n}\n\nexport function onAbort(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<UIEvent>> {\n  return createEventHandler<SyntheticNativeEvent<UIEvent>>(EventSourceAbort.eventSource, handler, capture);\n}\nexport function onActivate(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<UIEvent>> {\n  return createEventHandler<SyntheticNativeEvent<UIEvent>>(EventSourceActivate.eventSource, handler, capture);\n}\nexport function onAriaRequest(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<UIEvent>> {\n  return createEventHandler<SyntheticNativeEvent<UIEvent>>(EventSourceAriaRequest.eventSource, handler, capture);\n}\nexport function onBeforeActivate(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<UIEvent>> {\n  return createEventHandler<SyntheticNativeEvent<UIEvent>>(EventSourceBeforeActivate.eventSource, handler, capture);\n}\nexport function onBeforeCopy(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<ClipboardEvent>> {\n  return createEventHandler<SyntheticNativeEvent<ClipboardEvent>>(EventSourceBeforeCopy.eventSource, handler, capture);\n}\nexport function onBeforeCut(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<ClipboardEvent>> {\n  return createEventHandler<SyntheticNativeEvent<ClipboardEvent>>(EventSourceBeforeCut.eventSource, handler, capture);\n}\nexport function onBeforeDeactivate(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<UIEvent>> {\n  return createEventHandler<SyntheticNativeEvent<UIEvent>>(EventSourceBeforeDeactivate.eventSource, handler, capture);\n}\nexport function onBeforePaste(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<ClipboardEvent>> {\n  return createEventHandler<SyntheticNativeEvent<ClipboardEvent>>(EventSourceBeforePaste.eventSource, handler, capture);\n}\nexport function onBlur(\n  handler: (ev: SyntheticNativeEvent<FocusEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<FocusEvent>> {\n  return createEventHandler<SyntheticNativeEvent<FocusEvent>>(EventSourceBlur.eventSource, handler, capture);\n}\nexport function onCanPlay(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceCanPlay.eventSource, handler, capture);\n}\nexport function onCanPlaythrough(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceCanPlaythrough.eventSource, handler, capture);\n}\nexport function onChange(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceChange.eventSource, handler, capture);\n}\nexport function onClick(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MouseEvent>> {\n  return createEventHandler<SyntheticNativeEvent<MouseEvent>>(EventSourceClick.eventSource, handler, capture);\n}\nexport function onContextMenu(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createEventHandler<SyntheticNativeEvent<PointerEvent>>(EventSourceContextMenu.eventSource, handler, capture);\n}\nexport function onCopy(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<ClipboardEvent>> {\n  return createEventHandler<SyntheticNativeEvent<ClipboardEvent>>(EventSourceCopy.eventSource, handler, capture);\n}\nexport function onCueChange(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceCueChange.eventSource, handler, capture);\n}\nexport function onCut(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<ClipboardEvent>> {\n  return createEventHandler<SyntheticNativeEvent<ClipboardEvent>>(EventSourceCut.eventSource, handler, capture);\n}\nexport function onDoubleClick(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MouseEvent>> {\n  return createEventHandler<SyntheticNativeEvent<MouseEvent>>(EventSourceDoubleClick.eventSource, handler, capture);\n}\nexport function onDeactivate(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<UIEvent>> {\n  return createEventHandler<SyntheticNativeEvent<UIEvent>>(EventSourceDeactivate.eventSource, handler, capture);\n}\nexport function onDrag(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<DragEvent>> {\n  return createEventHandler<SyntheticNativeEvent<DragEvent>>(EventSourceDrag.eventSource, handler, capture);\n}\nexport function onDragEnd(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<DragEvent>> {\n  return createEventHandler<SyntheticNativeEvent<DragEvent>>(EventSourceDragEnd.eventSource, handler, capture);\n}\nexport function onDragEnter(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<DragEvent>> {\n  return createEventHandler<SyntheticNativeEvent<DragEvent>>(EventSourceDragEnter.eventSource, handler, capture);\n}\nexport function onDragLeave(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<DragEvent>> {\n  return createEventHandler<SyntheticNativeEvent<DragEvent>>(EventSourceDragLeave.eventSource, handler, capture);\n}\nexport function onDragOver(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<DragEvent>> {\n  return createEventHandler<SyntheticNativeEvent<DragEvent>>(EventSourceDragOver.eventSource, handler, capture);\n}\nexport function onDragStart(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<DragEvent>> {\n  return createEventHandler<SyntheticNativeEvent<DragEvent>>(EventSourceDragStart.eventSource, handler, capture);\n}\nexport function onDrop(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<DragEvent>> {\n  return createEventHandler<SyntheticNativeEvent<DragEvent>>(EventSourceDrop.eventSource, handler, capture);\n}\nexport function onDurationChange(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceDurationChange.eventSource, handler, capture);\n}\nexport function onEmptied(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceEmptied.eventSource, handler, capture);\n}\nexport function onEncrypted(\n  handler: (ev: SyntheticNativeEvent<MediaEncryptedEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MediaEncryptedEvent>> {\n  return createEventHandler<SyntheticNativeEvent<MediaEncryptedEvent>>(EventSourceEncrypted.eventSource, handler, capture);\n}\nexport function onEnded(\n  handler: (ev: SyntheticNativeEvent<MediaStreamErrorEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MediaStreamErrorEvent>> {\n  return createEventHandler<SyntheticNativeEvent<MediaStreamErrorEvent>>(EventSourceEnded.eventSource, handler, capture);\n}\nexport function onError(\n  handler: (ev: SyntheticNativeEvent<ErrorEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<ErrorEvent>> {\n  return createEventHandler<SyntheticNativeEvent<ErrorEvent>>(EventSourceError.eventSource, handler, capture);\n}\nexport function onFocus(\n  handler: (ev: SyntheticNativeEvent<FocusEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<FocusEvent>> {\n  return createEventHandler<SyntheticNativeEvent<FocusEvent>>(EventSourceFocus.eventSource, handler, capture);\n}\nexport function onGotPointerCapture(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createEventHandler<SyntheticNativeEvent<PointerEvent>>(EventSourceGotPointerCapture.eventSource, handler, capture);\n}\nexport function onInput(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceInput.eventSource, handler, capture);\n}\nexport function onInvalid(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceInvalid.eventSource, handler, capture);\n}\nexport function onKeyDown(\n  handler: (ev: SyntheticNativeEvent<KeyboardEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<KeyboardEvent>> {\n  return createEventHandler<SyntheticNativeEvent<KeyboardEvent>>(EventSourceKeyDown.eventSource, handler, capture);\n}\nexport function onKeyPress(\n  handler: (ev: SyntheticNativeEvent<KeyboardEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<KeyboardEvent>> {\n  return createEventHandler<SyntheticNativeEvent<KeyboardEvent>>(EventSourceKeyPress.eventSource, handler, capture);\n}\nexport function onKeyUp(\n  handler: (ev: SyntheticNativeEvent<KeyboardEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<KeyboardEvent>> {\n  return createEventHandler<SyntheticNativeEvent<KeyboardEvent>>(EventSourceKeyUp.eventSource, handler, capture);\n}\nexport function onLoad(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceLoad.eventSource, handler, capture);\n}\nexport function onLoadedData(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceLoadedSata.eventSource, handler, capture);\n}\nexport function onLoadedMetadata(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceLoadedMetadata.eventSource, handler, capture);\n}\nexport function onLoadStart(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceLoadStart.eventSource, handler, capture);\n}\nexport function onLostPointerCapture(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createEventHandler<SyntheticNativeEvent<PointerEvent>>(EventSourceLostPointerCapture.eventSource, handler, capture);\n}\nexport function onMouseDown(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MouseEvent>> {\n  return createEventHandler<SyntheticNativeEvent<MouseEvent>>(EventSourceMouseDown.eventSource, handler, capture);\n}\nexport function onMouseEnter(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MouseEvent>> {\n  return createEventHandler<SyntheticNativeEvent<MouseEvent>>(EventSourceMouseEnter.eventSource, handler, capture);\n}\nexport function onMouseLeave(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MouseEvent>> {\n  return createEventHandler<SyntheticNativeEvent<MouseEvent>>(EventSourceMouseLeave.eventSource, handler, capture);\n}\nexport function onMouseMove(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MouseEvent>> {\n  return createEventHandler<SyntheticNativeEvent<MouseEvent>>(EventSourceMouseMove.eventSource, handler, capture);\n}\nexport function onMouseOut(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MouseEvent>> {\n  return createEventHandler<SyntheticNativeEvent<MouseEvent>>(EventSourceMouseOut.eventSource, handler, capture);\n}\nexport function onMouseOver(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MouseEvent>> {\n  return createEventHandler<SyntheticNativeEvent<MouseEvent>>(EventSourceMouseOver.eventSource, handler, capture);\n}\nexport function onMouseUp(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MouseEvent>> {\n  return createEventHandler<SyntheticNativeEvent<MouseEvent>>(EventSourceMouseUp.eventSource, handler, capture);\n}\nexport function onPaste(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<ClipboardEvent>> {\n  return createEventHandler<SyntheticNativeEvent<ClipboardEvent>>(EventSourcePaste.eventSource, handler, capture);\n}\nexport function onPause(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourcePause.eventSource, handler, capture);\n}\nexport function onPlay(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourcePlay.eventSource, handler, capture);\n}\nexport function onPlaying(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourcePlaying.eventSource, handler, capture);\n}\nexport function onPointerCancel(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createEventHandler<SyntheticNativeEvent<PointerEvent>>(EventSourcePointerCancel.eventSource, handler, capture);\n}\nexport function onPointerDown(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createEventHandler<SyntheticNativeEvent<PointerEvent>>(EventSourcePointerDown.eventSource, handler, capture);\n}\nexport function onPointerEnter(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createEventHandler<SyntheticNativeEvent<PointerEvent>>(EventSourcePointerEnter.eventSource, handler, capture);\n}\nexport function onPointerLeave(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createEventHandler<SyntheticNativeEvent<PointerEvent>>(EventSourcePointerLeave.eventSource, handler, capture);\n}\nexport function onPointerMove(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createEventHandler<SyntheticNativeEvent<PointerEvent>>(EventSourcePointerMove.eventSource, handler, capture);\n}\nexport function onPointerOut(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createEventHandler<SyntheticNativeEvent<PointerEvent>>(EventSourcePointerOut.eventSource, handler, capture);\n}\nexport function onPointerOver(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createEventHandler<SyntheticNativeEvent<PointerEvent>>(EventSourcePointerOver.eventSource, handler, capture);\n}\nexport function onPointerUp(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createEventHandler<SyntheticNativeEvent<PointerEvent>>(EventSourcePointerUp.eventSource, handler, capture);\n}\nexport function onProgress(\n  handler: (ev: SyntheticNativeEvent<ProgressEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<ProgressEvent>> {\n  return createEventHandler<SyntheticNativeEvent<ProgressEvent>>(EventSourceProgress.eventSource, handler, capture);\n}\nexport function onRateChange(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceRateChange.eventSource, handler, capture);\n}\nexport function onReset(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceReset.eventSource, handler, capture);\n}\nexport function onScroll(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<UIEvent>> {\n  return createEventHandler<SyntheticNativeEvent<UIEvent>>(EventSourceScroll.eventSource, handler, capture);\n}\nexport function onSeeked(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceSeeked.eventSource, handler, capture);\n}\nexport function onSeeking(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceSeeking.eventSource, handler, capture);\n}\nexport function onSelect(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<UIEvent>> {\n  return createEventHandler<SyntheticNativeEvent<UIEvent>>(EventSourceSelect.eventSource, handler, capture);\n}\nexport function onSelectStart(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceSelectStart.eventSource, handler, capture);\n}\nexport function onStalled(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceStalled.eventSource, handler, capture);\n}\nexport function onSubmit(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceSubmit.eventSource, handler, capture);\n}\nexport function onSuspend(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceSuspend.eventSource, handler, capture);\n}\nexport function onTimeUpdate(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceTimeUpdate.eventSource, handler, capture);\n}\nexport function onTouchCancel(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<TouchEvent>> {\n  return createEventHandler<SyntheticNativeEvent<TouchEvent>>(EventSourceTouchCancel.eventSource, handler, capture);\n}\nexport function onTouchEnd(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<TouchEvent>> {\n  return createEventHandler<SyntheticNativeEvent<TouchEvent>>(EventSourceTouchEnd.eventSource, handler, capture);\n}\nexport function onTouchMove(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<TouchEvent>> {\n  return createEventHandler<SyntheticNativeEvent<TouchEvent>>(EventSourceTouchMove.eventSource, handler, capture);\n}\nexport function onTouchStart(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<TouchEvent>> {\n  return createEventHandler<SyntheticNativeEvent<TouchEvent>>(EventSourceTouchStart.eventSource, handler, capture);\n}\nexport function onUnload(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceUnload.eventSource, handler, capture);\n}\nexport function onVolumeChange(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceVolumeChange.eventSource, handler, capture);\n}\nexport function onWaiting(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceWaiting.eventSource, handler, capture);\n}\nexport function onWheel(\n  handler: (ev: SyntheticNativeEvent<WheelEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<WheelEvent>> {\n  return createEventHandler<SyntheticNativeEvent<WheelEvent>>(EventSourceWheel.eventSource, handler, capture);\n}\n\nexport function onActiveTouchEnd(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<TouchEvent>> {\n  return createEventHandler<SyntheticNativeEvent<TouchEvent>>(EventSourceActiveTouchEnd.eventSource, handler, capture);\n}\nexport function onActiveTouchMove(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<TouchEvent>> {\n  return createEventHandler<SyntheticNativeEvent<TouchEvent>>(EventSourceActiveTouchMove.eventSource, handler, capture);\n}\nexport function onActiveTouchStart(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<TouchEvent>> {\n  return createEventHandler<SyntheticNativeEvent<TouchEvent>>(EventSourceActiveTouchStart.eventSource, handler, capture);\n}\nexport function onActiveWheel(\n  handler: (ev: SyntheticNativeEvent<WheelEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<WheelEvent>> {\n  return createEventHandler<SyntheticNativeEvent<WheelEvent>>(EventSourceActiveWheel.eventSource, handler, capture);\n}\n\n/* tslint:enable:max-line-length */\n","import {\n  HTMLAnchorElementProps, HTMLElementProps, HTMLAreaElementProps, HTMLAudioElementProps,\n  HTMLBaseElementProps, HTMLBaseFontElementProps, HTMLBodyElementProps, HTMLBRElementProps, HTMLButtonElementProps,\n  HTMLCanvasElementProps, HTMLQuoteElementProps, HTMLTableCaptionElementProps, HTMLTableColElementProps,\n  HTMLDataListElementProps, HTMLModElementProps, HTMLDirectoryElementProps, HTMLDivElementProps,\n  HTMLDListElementProps, HTMLEmbedElementProps, HTMLFieldSetElementProps, HTMLFontElementProps, HTMLFormElementProps,\n  HTMLFrameElementProps, HTMLFrameSetElementProps, HTMLHeadElementProps, HTMLHeadingElementProps, HTMLHRElementProps,\n  HTMLHtmlElementProps, HTMLIFrameElementProps, HTMLImageElementProps, HTMLInputElementProps, HTMLLabelElementProps,\n  HTMLLegendElementProps, HTMLLIElementProps, HTMLLinkElementProps, HTMLMapElementProps,\n  HTMLMenuElementProps, HTMLMetaElementProps, HTMLMeterElementProps, HTMLObjectElementProps, HTMLOListElementProps,\n  HTMLOptGroupElementProps, HTMLOptionElementProps, HTMLParagraphElementProps, HTMLParamElementProps,\n  HTMLPictureElementProps, HTMLPreElementProps, HTMLProgressElementProps, HTMLScriptElementProps,\n  HTMLSelectElementProps, HTMLSourceElementProps, HTMLSpanElementProps, HTMLStyleElementProps,\n  HTMLTableDataCellElementProps, HTMLTableElementProps, HTMLTableHeaderCellElementProps, HTMLTableRowElementProps,\n  HTMLTableSectionElementProps, HTMLTemplateElementProps, HTMLTextAreaElementProps, HTMLTitleElementProps,\n  HTMLTrackElementProps, HTMLUListElementProps, HTMLVideoElementProps,\n} from \"ivi-core\";\nimport { VNode, VNodeFlags } from \"ivi\";\n\nconst enum TagId {\n  A = 1,\n  Abbr = 2,\n  Acronym = 3,\n  Address = 4,\n  Area = 5,\n  Article = 6,\n  Aside = 7,\n  B = 8,\n  Base = 9,\n  Basefont = 10,\n  Bdo = 11,\n  Big = 12,\n  Blockquote = 13,\n  Body = 14,\n  Br = 15,\n  Button = 16,\n  Canvas = 17,\n  Caption = 18,\n  Center = 19,\n  Cite = 20,\n  Code = 21,\n  Col = 22,\n  Colgroup = 23,\n  Data = 24,\n  Datalist = 25,\n  Dd = 26,\n  Del = 27,\n  Dfn = 28,\n  Dir = 29,\n  Div = 30,\n  Dl = 31,\n  Dt = 32,\n  Em = 33,\n  Embed = 34,\n  Fieldset = 35,\n  Figcaption = 36,\n  Figure = 37,\n  Font = 38,\n  Footer = 39,\n  Form = 40,\n  Frame = 41,\n  Frameset = 42,\n  H1 = 43,\n  H2 = 44,\n  H3 = 45,\n  H4 = 46,\n  H5 = 47,\n  H6 = 48,\n  Head = 49,\n  Header = 50,\n  Hgroup = 51,\n  Hr = 52,\n  Html = 53,\n  I = 54,\n  Iframe = 55,\n  Img = 56,\n  Input = 57,\n  Ins = 58,\n  Kbd = 59,\n  Label = 60,\n  Legend = 61,\n  Li = 62,\n  Link = 63,\n  Listing = 64,\n  Main = 65,\n  Map = 66,\n  Mark = 67,\n  Menu = 68,\n  Meta = 69,\n  Meter = 70,\n  Nav = 71,\n  Nobr = 72,\n  Noframes = 73,\n  Noscript = 74,\n  Object = 75,\n  Ol = 76,\n  Optgroup = 77,\n  Option = 78,\n  P = 79,\n  Param = 80,\n  Picture = 81,\n  Plaintext = 82,\n  Pre = 83,\n  Progress = 84,\n  Q = 85,\n  Rt = 86,\n  Ruby = 87,\n  S = 88,\n  Samp = 89,\n  Script = 90,\n  Section = 91,\n  Select = 92,\n  Small = 93,\n  Source = 94,\n  Span = 95,\n  Strike = 96,\n  Strong = 97,\n  Style = 98,\n  Sub = 99,\n  Sup = 100,\n  Table = 101,\n  Tbody = 102,\n  Td = 103,\n  Template = 104,\n  Textarea = 105,\n  Tfoot = 106,\n  Th = 107,\n  Thead = 108,\n  Time = 109,\n  Title = 110,\n  Tr = 111,\n  Track = 112,\n  Tt = 113,\n  U = 114,\n  Ul = 115,\n  Wbr = 116,\n  Xmp = 117,\n  Audio = 118,\n  Video = 119,\n}\n\n/**\n * Create a VNode representing a Text node.\n *\n * @param content Text content.\n * @returns VNode object.\n */\nexport function t(content: string | number | null): VNode<null, Text> {\n  return new VNode(VNodeFlags.Text, null, null, void 0, content);\n}\n\n// HTML Elements:\nexport function a(className?: string): VNode<HTMLAnchorElementProps | null, HTMLAnchorElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.A << VNodeFlags.ElementIdOffset),\n    \"a\",\n    null,\n    className,\n    null,\n  );\n}\nexport function abbr(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Abbr << VNodeFlags.ElementIdOffset),\n    \"abbr\",\n    null,\n    className,\n    null,\n  );\n}\nexport function acronym(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Acronym << VNodeFlags.ElementIdOffset),\n    \"acronym\",\n    null,\n    className,\n    null,\n  );\n}\nexport function address(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Address << VNodeFlags.ElementIdOffset),\n    \"address\",\n    null,\n    className,\n    null,\n  );\n}\nexport function area(className?: string): VNode<HTMLAreaElementProps | null, HTMLAreaElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Area << VNodeFlags.ElementIdOffset),\n    \"area\",\n    null,\n    className,\n    null,\n  );\n}\nexport function article(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Article << VNodeFlags.ElementIdOffset),\n    \"article\",\n    null,\n    className,\n    null,\n  );\n}\nexport function aside(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Aside << VNodeFlags.ElementIdOffset),\n    \"aside\",\n    null,\n    className,\n    null,\n  );\n}\nexport function b(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.B << VNodeFlags.ElementIdOffset),\n    \"b\",\n    null,\n    className,\n    null,\n  );\n}\nexport function base(className?: string): VNode<HTMLBaseElementProps | null, HTMLBaseElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Base << VNodeFlags.ElementIdOffset),\n    \"base\",\n    null,\n    className,\n    null,\n  );\n}\nexport function basefont(className?: string): VNode<HTMLBaseFontElementProps | null, HTMLBaseFontElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Basefont << VNodeFlags.ElementIdOffset),\n    \"basefont\",\n    null,\n    className,\n    null,\n  );\n}\nexport function bdo(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Bdo << VNodeFlags.ElementIdOffset),\n    \"bdo\",\n    null,\n    className,\n    null,\n  );\n}\nexport function big(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Big << VNodeFlags.ElementIdOffset),\n    \"big\",\n    null,\n    className,\n    null,\n  );\n}\nexport function blockquote(className?: string): VNode<HTMLQuoteElementProps | null, HTMLQuoteElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Blockquote << VNodeFlags.ElementIdOffset),\n    \"blockquote\",\n    null,\n    className,\n    null,\n  );\n}\nexport function body(className?: string): VNode<HTMLBodyElementProps | null, HTMLBodyElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Body << VNodeFlags.ElementIdOffset),\n    \"body\",\n    null,\n    className,\n    null,\n  );\n}\nexport function br(className?: string): VNode<HTMLBRElementProps | null, HTMLBRElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Br << VNodeFlags.ElementIdOffset),\n    \"br\",\n    null,\n    className,\n    null,\n  );\n}\nexport function button(className?: string): VNode<HTMLButtonElementProps | null, HTMLButtonElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Button << VNodeFlags.ElementIdOffset),\n    \"button\",\n    null,\n    className,\n    null,\n  );\n}\nexport function canvas(className?: string): VNode<HTMLCanvasElementProps | null, HTMLCanvasElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Canvas << VNodeFlags.ElementIdOffset),\n    \"canvas\",\n    null,\n    className,\n    null,\n  );\n}\nexport function caption(className?: string): VNode<HTMLTableCaptionElementProps | null, HTMLTableCaptionElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Caption << VNodeFlags.ElementIdOffset),\n    \"caption\",\n    null,\n    className,\n    null,\n  );\n}\nexport function center(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Center << VNodeFlags.ElementIdOffset),\n    \"center\",\n    null,\n    className,\n    null,\n  );\n}\nexport function cite(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Cite << VNodeFlags.ElementIdOffset),\n    \"cite\",\n    null,\n    className,\n    null,\n  );\n}\nexport function code(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Code << VNodeFlags.ElementIdOffset),\n    \"code\",\n    null,\n    className,\n    null,\n  );\n}\nexport function col(className?: string): VNode<HTMLTableColElementProps | null, HTMLTableColElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Col << VNodeFlags.ElementIdOffset),\n    \"col\",\n    null,\n    className,\n    null,\n  );\n}\nexport function colgroup(className?: string): VNode<HTMLTableColElementProps | null, HTMLTableColElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Colgroup << VNodeFlags.ElementIdOffset),\n    \"colgroup\",\n    null,\n    className,\n    null,\n  );\n}\nexport function data(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Data << VNodeFlags.ElementIdOffset),\n    \"data\",\n    null,\n    className,\n    null,\n  );\n}\nexport function datalist(className?: string): VNode<HTMLDataListElementProps | null, HTMLDataListElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Datalist << VNodeFlags.ElementIdOffset),\n    \"datalist\",\n    null,\n    className,\n    null,\n  );\n}\nexport function dd(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Dd << VNodeFlags.ElementIdOffset),\n    \"dd\",\n    null,\n    className,\n    null,\n  );\n}\nexport function del(className?: string): VNode<HTMLModElementProps | null, HTMLModElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Del << VNodeFlags.ElementIdOffset),\n    \"del\",\n    null,\n    className,\n    null,\n  );\n}\nexport function dfn(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Dfn << VNodeFlags.ElementIdOffset),\n    \"dfn\",\n    null,\n    className,\n    null,\n  );\n}\nexport function dir(className?: string): VNode<HTMLDirectoryElementProps | null, HTMLDirectoryElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Dir << VNodeFlags.ElementIdOffset),\n    \"dir\",\n    null,\n    className,\n    null,\n  );\n}\nexport function div(className?: string): VNode<HTMLDivElementProps | null, HTMLDivElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Div << VNodeFlags.ElementIdOffset),\n    \"div\",\n    null,\n    className,\n    null,\n  );\n}\nexport function dl(className?: string): VNode<HTMLDListElementProps | null, HTMLDListElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Dl << VNodeFlags.ElementIdOffset),\n    \"dl\",\n    null,\n    className,\n    null,\n  );\n}\nexport function dt(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Dt << VNodeFlags.ElementIdOffset),\n    \"dt\",\n    null,\n    className,\n    null,\n  );\n}\nexport function em(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Em << VNodeFlags.ElementIdOffset),\n    \"em\",\n    null,\n    className,\n    null,\n  );\n}\nexport function embed(className?: string): VNode<HTMLEmbedElementProps | null, HTMLEmbedElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Embed << VNodeFlags.ElementIdOffset),\n    \"embed\",\n    null,\n    className,\n    null,\n  );\n}\nexport function fieldset(className?: string): VNode<HTMLFieldSetElementProps | null, HTMLFieldSetElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Fieldset << VNodeFlags.ElementIdOffset),\n    \"fieldset\",\n    null,\n    className,\n    null,\n  );\n}\nexport function figcaption(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Figcaption << VNodeFlags.ElementIdOffset),\n    \"figcaption\",\n    null,\n    className,\n    null,\n  );\n}\nexport function figure(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Figure << VNodeFlags.ElementIdOffset),\n    \"figure\",\n    null,\n    className,\n    null,\n  );\n}\nexport function font(className?: string): VNode<HTMLFontElementProps | null, HTMLFontElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Font << VNodeFlags.ElementIdOffset),\n    \"font\",\n    null,\n    className,\n    null,\n  );\n}\nexport function footer(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Footer << VNodeFlags.ElementIdOffset),\n    \"footer\",\n    null,\n    className,\n    null,\n  );\n}\nexport function form(className?: string): VNode<HTMLFormElementProps | null, HTMLFormElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Form << VNodeFlags.ElementIdOffset),\n    \"form\",\n    null,\n    className,\n    null,\n  );\n}\nexport function frame(className?: string): VNode<HTMLFrameElementProps | null, HTMLFrameElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Frame << VNodeFlags.ElementIdOffset),\n    \"frame\",\n    null,\n    className,\n    null,\n  );\n}\nexport function frameset(className?: string): VNode<HTMLFrameSetElementProps | null, HTMLFrameSetElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Frameset << VNodeFlags.ElementIdOffset),\n    \"frameset\",\n    null,\n    className,\n    null,\n  );\n}\nexport function h1(className?: string): VNode<HTMLHeadingElementProps | null, HTMLHeadingElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.H1 << VNodeFlags.ElementIdOffset),\n    \"h1\",\n    null,\n    className,\n    null,\n  );\n}\nexport function h2(className?: string): VNode<HTMLHeadingElementProps | null, HTMLHeadingElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.H2 << VNodeFlags.ElementIdOffset),\n    \"h2\",\n    null,\n    className,\n    null,\n  );\n}\nexport function h3(className?: string): VNode<HTMLHeadingElementProps | null, HTMLHeadingElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.H3 << VNodeFlags.ElementIdOffset),\n    \"h3\",\n    null,\n    className,\n    null,\n  );\n}\nexport function h4(className?: string): VNode<HTMLHeadingElementProps | null, HTMLHeadingElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.H4 << VNodeFlags.ElementIdOffset),\n    \"h4\",\n    null,\n    className,\n    null,\n  );\n}\nexport function h5(className?: string): VNode<HTMLHeadingElementProps | null, HTMLHeadingElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.H5 << VNodeFlags.ElementIdOffset),\n    \"h5\",\n    null,\n    className,\n    null,\n  );\n}\nexport function h6(className?: string): VNode<HTMLHeadingElementProps | null, HTMLHeadingElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.H6 << VNodeFlags.ElementIdOffset),\n    \"h6\",\n    null,\n    className,\n    null,\n  );\n}\nexport function head(className?: string): VNode<HTMLHeadElementProps | null, HTMLHeadElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Head << VNodeFlags.ElementIdOffset),\n    \"head\",\n    null,\n    className,\n    null,\n  );\n}\nexport function header(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Header << VNodeFlags.ElementIdOffset),\n    \"header\",\n    null,\n    className,\n    null,\n  );\n}\nexport function hgroup(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Hgroup << VNodeFlags.ElementIdOffset),\n    \"hgroup\",\n    null,\n    className,\n    null,\n  );\n}\nexport function hr(className?: string): VNode<HTMLHRElementProps | null, HTMLHRElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Hr << VNodeFlags.ElementIdOffset),\n    \"hr\",\n    null,\n    className,\n    null,\n  );\n}\nexport function html(className?: string): VNode<HTMLHtmlElementProps | null, HTMLHtmlElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Html << VNodeFlags.ElementIdOffset),\n    \"html\",\n    null,\n    className,\n    null,\n  );\n}\nexport function i(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.I << VNodeFlags.ElementIdOffset),\n    \"i\",\n    null,\n    className,\n    null,\n  );\n}\nexport function iframe(className?: string): VNode<HTMLIFrameElementProps | null, HTMLIFrameElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Iframe << VNodeFlags.ElementIdOffset),\n    \"iframe\",\n    null,\n    className,\n    null,\n  );\n}\nexport function img(className?: string): VNode<HTMLImageElementProps | null, HTMLImageElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Img << VNodeFlags.ElementIdOffset),\n    \"img\",\n    null,\n    className,\n    null,\n  );\n}\nexport function ins(className?: string): VNode<HTMLModElementProps | null, HTMLModElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Ins << VNodeFlags.ElementIdOffset),\n    \"ins\",\n    null,\n    className,\n    null,\n  );\n}\nexport function kbd(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Kbd << VNodeFlags.ElementIdOffset),\n    \"kbd\",\n    null,\n    className,\n    null,\n  );\n}\nexport function label(className?: string): VNode<HTMLLabelElementProps | null, HTMLLabelElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Label << VNodeFlags.ElementIdOffset),\n    \"label\",\n    null,\n    className,\n    null,\n  );\n}\nexport function legend(className?: string): VNode<HTMLLegendElementProps | null, HTMLLegendElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Legend << VNodeFlags.ElementIdOffset),\n    \"legend\",\n    null,\n    className,\n    null,\n  );\n}\nexport function li(className?: string): VNode<HTMLLIElementProps | null, HTMLLIElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Li << VNodeFlags.ElementIdOffset),\n    \"li\",\n    null,\n    className,\n    null,\n  );\n}\nexport function link(className?: string): VNode<HTMLLinkElementProps | null, HTMLLinkElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Link << VNodeFlags.ElementIdOffset),\n    \"link\",\n    null,\n    className,\n    null,\n  );\n}\nexport function listing(className?: string): VNode<HTMLPreElementProps | null, HTMLPreElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Listing << VNodeFlags.ElementIdOffset),\n    \"listing\",\n    null,\n    className,\n    null,\n  );\n}\nexport function main(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Main << VNodeFlags.ElementIdOffset),\n    \"main\",\n    null,\n    className,\n    null,\n  );\n}\nexport function map(className?: string): VNode<HTMLMapElementProps | null, HTMLMapElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Map << VNodeFlags.ElementIdOffset),\n    \"map\",\n    null,\n    className,\n    null,\n  );\n}\nexport function mark(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Mark << VNodeFlags.ElementIdOffset),\n    \"mark\",\n    null,\n    className,\n    null,\n  );\n}\nexport function menu(className?: string): VNode<HTMLMenuElementProps | null, HTMLMenuElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Menu << VNodeFlags.ElementIdOffset),\n    \"menu\",\n    null,\n    className,\n    null,\n  );\n}\nexport function meta(className?: string): VNode<HTMLMetaElementProps | null, HTMLMetaElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Meta << VNodeFlags.ElementIdOffset),\n    \"meta\",\n    null,\n    className,\n    null,\n  );\n}\nexport function meter(className?: string): VNode<HTMLMeterElementProps | null, HTMLMeterElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Meter << VNodeFlags.ElementIdOffset),\n    \"meter\",\n    null,\n    className,\n    null,\n  );\n}\nexport function nav(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Nav << VNodeFlags.ElementIdOffset),\n    \"nav\",\n    null,\n    className,\n    null,\n  );\n}\nexport function nobr(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Nobr << VNodeFlags.ElementIdOffset),\n    \"nobr\",\n    null,\n    className,\n    null,\n  );\n}\nexport function noframes(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Noframes << VNodeFlags.ElementIdOffset),\n    \"noframes\",\n    null,\n    className,\n    null,\n  );\n}\nexport function noscript(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Noscript << VNodeFlags.ElementIdOffset),\n    \"noscript\",\n    null,\n    className,\n    null,\n  );\n}\nexport function object(className?: string): VNode<HTMLObjectElementProps | null, HTMLObjectElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Object << VNodeFlags.ElementIdOffset),\n    \"object\",\n    null,\n    className,\n    null,\n  );\n}\nexport function ol(className?: string): VNode<HTMLOListElementProps | null, HTMLOListElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Ol << VNodeFlags.ElementIdOffset),\n    \"ol\",\n    null,\n    className,\n    null,\n  );\n}\nexport function optgroup(className?: string): VNode<HTMLOptGroupElementProps | null, HTMLOptGroupElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Optgroup << VNodeFlags.ElementIdOffset),\n    \"optgroup\",\n    null,\n    className,\n    null,\n  );\n}\nexport function option(className?: string): VNode<HTMLOptionElementProps | null, HTMLOptionElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Option << VNodeFlags.ElementIdOffset),\n    \"option\",\n    null,\n    className,\n    null,\n  );\n}\nexport function p(className?: string): VNode<HTMLParagraphElementProps | null, HTMLParagraphElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.P << VNodeFlags.ElementIdOffset),\n    \"p\",\n    null,\n    className,\n    null,\n  );\n}\nexport function param(className?: string): VNode<HTMLParamElementProps | null, HTMLParamElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Param << VNodeFlags.ElementIdOffset),\n    \"param\",\n    null,\n    className,\n    null,\n  );\n}\nexport function picture(className?: string): VNode<HTMLPictureElementProps | null, HTMLPictureElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Picture << VNodeFlags.ElementIdOffset),\n    \"picture\",\n    null,\n    className,\n    null,\n  );\n}\nexport function plaintext(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Plaintext << VNodeFlags.ElementIdOffset),\n    \"plaintext\",\n    null,\n    className,\n    null,\n  );\n}\nexport function pre(className?: string): VNode<HTMLPreElementProps | null, HTMLPreElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Pre << VNodeFlags.ElementIdOffset),\n    \"pre\",\n    null,\n    className,\n    null,\n  );\n}\nexport function progress(className?: string): VNode<HTMLProgressElementProps | null, HTMLProgressElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Progress << VNodeFlags.ElementIdOffset),\n    \"progress\",\n    null,\n    className,\n    null,\n  );\n}\nexport function q(className?: string): VNode<HTMLQuoteElementProps | null, HTMLQuoteElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Q << VNodeFlags.ElementIdOffset),\n    \"q\",\n    null,\n    className,\n    null,\n  );\n}\nexport function rt(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Rt << VNodeFlags.ElementIdOffset),\n    \"rt\",\n    null,\n    className,\n    null,\n  );\n}\nexport function ruby(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Ruby << VNodeFlags.ElementIdOffset),\n    \"ruby\",\n    null,\n    className,\n    null,\n  );\n}\nexport function s(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.S << VNodeFlags.ElementIdOffset),\n    \"s\",\n    null,\n    className,\n    null,\n  );\n}\nexport function samp(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Samp << VNodeFlags.ElementIdOffset),\n    \"samp\",\n    null,\n    className,\n    null,\n  );\n}\nexport function script(className?: string): VNode<HTMLScriptElementProps | null, HTMLScriptElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Script << VNodeFlags.ElementIdOffset),\n    \"script\",\n    null,\n    className,\n    null,\n  );\n}\nexport function section(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Section << VNodeFlags.ElementIdOffset),\n    \"section\",\n    null,\n    className,\n    null,\n  );\n}\nexport function select(className?: string): VNode<HTMLSelectElementProps | null, HTMLSelectElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Select << VNodeFlags.ElementIdOffset),\n    \"select\",\n    null,\n    className,\n    null,\n  );\n}\nexport function small(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Small << VNodeFlags.ElementIdOffset),\n    \"small\",\n    null,\n    className,\n    null,\n  );\n}\nexport function source(className?: string): VNode<HTMLSourceElementProps | null, HTMLSourceElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Source << VNodeFlags.ElementIdOffset),\n    \"source\",\n    null,\n    className,\n    null,\n  );\n}\nexport function span(className?: string): VNode<HTMLSpanElementProps | null, HTMLSpanElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Span << VNodeFlags.ElementIdOffset),\n    \"span\",\n    null,\n    className,\n    null,\n  );\n}\nexport function strike(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Strike << VNodeFlags.ElementIdOffset),\n    \"strike\",\n    null,\n    className,\n    null,\n  );\n}\nexport function strong(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Strong << VNodeFlags.ElementIdOffset),\n    \"strong\",\n    null,\n    className,\n    null,\n  );\n}\nexport function style(className?: string): VNode<HTMLStyleElementProps | null, HTMLStyleElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Style << VNodeFlags.ElementIdOffset),\n    \"style\",\n    null,\n    className,\n    null,\n  );\n}\nexport function sub(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Sub << VNodeFlags.ElementIdOffset),\n    \"sub\",\n    null,\n    className,\n    null,\n  );\n}\nexport function sup(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Sup << VNodeFlags.ElementIdOffset),\n    \"sup\",\n    null,\n    className,\n    null,\n  );\n}\nexport function table(className?: string): VNode<HTMLTableElementProps | null, HTMLTableElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Table << VNodeFlags.ElementIdOffset),\n    \"table\",\n    null,\n    className,\n    null,\n  );\n}\nexport function tbody(className?: string): VNode<HTMLTableSectionElementProps | null, HTMLTableSectionElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Tbody << VNodeFlags.ElementIdOffset),\n    \"tbody\",\n    null,\n    className,\n    null,\n  );\n}\nexport function td(className?: string): VNode<HTMLTableDataCellElementProps | null, HTMLTableDataCellElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Td << VNodeFlags.ElementIdOffset),\n    \"td\",\n    null,\n    className,\n    null,\n  );\n}\nexport function template(className?: string): VNode<HTMLTemplateElementProps | null, HTMLTemplateElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Template << VNodeFlags.ElementIdOffset),\n    \"template\",\n    null,\n    className,\n    null,\n  );\n}\nexport function tfoot(className?: string): VNode<HTMLTableSectionElementProps | null, HTMLTableSectionElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Tfoot << VNodeFlags.ElementIdOffset),\n    \"tfoot\",\n    null,\n    className,\n    null,\n  );\n}\nexport function th(className?: string): VNode<HTMLTableHeaderCellElementProps | null, HTMLTableHeaderCellElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Th << VNodeFlags.ElementIdOffset),\n    \"th\",\n    null,\n    className,\n    null,\n  );\n}\nexport function thead(className?: string): VNode<HTMLTableSectionElementProps | null, HTMLTableSectionElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Thead << VNodeFlags.ElementIdOffset),\n    \"thead\",\n    null,\n    className,\n    null,\n  );\n}\nexport function time(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Time << VNodeFlags.ElementIdOffset),\n    \"time\",\n    null,\n    className,\n    null,\n  );\n}\nexport function title(className?: string): VNode<HTMLTitleElementProps | null, HTMLTitleElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Title << VNodeFlags.ElementIdOffset),\n    \"title\",\n    null,\n    className,\n    null,\n  );\n}\nexport function tr(className?: string): VNode<HTMLTableRowElementProps | null, HTMLTableRowElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Tr << VNodeFlags.ElementIdOffset),\n    \"tr\",\n    null,\n    className,\n    null,\n  );\n}\nexport function track(className?: string): VNode<HTMLTrackElementProps | null, HTMLTrackElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Track << VNodeFlags.ElementIdOffset),\n    \"track\",\n    null,\n    className,\n    null,\n  );\n}\nexport function tt(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Tt << VNodeFlags.ElementIdOffset),\n    \"tt\",\n    null,\n    className,\n    null,\n  );\n}\nexport function u(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.U << VNodeFlags.ElementIdOffset),\n    \"u\",\n    null,\n    className,\n    null,\n  );\n}\nexport function ul(className?: string): VNode<HTMLUListElementProps | null, HTMLUListElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Ul << VNodeFlags.ElementIdOffset),\n    \"ul\",\n    null,\n    className,\n    null,\n  );\n}\nexport function wbr(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Wbr << VNodeFlags.ElementIdOffset),\n    \"wbr\",\n    null,\n    className,\n    null,\n  );\n}\nexport function xmp(className?: string): VNode<HTMLPreElementProps | null, HTMLPreElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Xmp << VNodeFlags.ElementIdOffset),\n    \"xmp\",\n    null,\n    className,\n    null,\n  );\n}\n\n// Textarea / Input Elements:\nexport function textarea(className?: string): VNode<HTMLTextAreaElementProps | null, HTMLTextAreaElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.TextAreaElement | (TagId.Textarea << VNodeFlags.ElementIdOffset),\n    \"textarea\",\n    null,\n    className,\n    null,\n  );\n}\nexport function input(className?: string): VNode<HTMLInputElementProps | null, HTMLInputElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.VoidElement | (TagId.Input << VNodeFlags.ElementIdOffset),\n    \"input\",\n    null,\n    className,\n    null,\n  );\n}\n\n// Media Elements:\nexport function audio(className?: string): VNode<HTMLAudioElementProps | null, HTMLAudioElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.MediaElement | (TagId.Audio << VNodeFlags.ElementIdOffset),\n    \"audio\",\n    null,\n    className,\n    null,\n  );\n}\n\nexport function video(className?: string): VNode<HTMLVideoElementProps | null, HTMLVideoElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.MediaElement | (TagId.Video << VNodeFlags.ElementIdOffset),\n    \"video\",\n    null,\n    className,\n    null,\n  );\n}\n","import * as tslib_1 from \"tslib\";\nimport { Component, statefulComponent, render, map } from \"ivi\";\nimport * as Events from \"ivi-events\";\nimport * as h from \"ivi-html\";\nvar TableCell = statefulComponent(/** @class */ (function (_super) {\n    tslib_1.__extends(class_1, _super);\n    function class_1() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.onClick = Events.onClick(function (ev) {\n            console.log(\"Click\", _this.props);\n        });\n        return _this;\n    }\n    class_1.prototype.render = function () {\n        return h.td(\"TableCell\")\n            .e(this.onClick)\n            .c(this.props);\n    };\n    return class_1;\n}(Component)));\nvar TableRow = statefulComponent(/** @class */ (function (_super) {\n    tslib_1.__extends(class_2, _super);\n    function class_2() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    class_2.prototype.render = function () {\n        var p = this.props;\n        var id = p[\"id\"];\n        var i = 0;\n        return h.tr(p[\"active\"] ? \"TableRow active\" : \"TableRow\")\n            .a({ \"data-id\": id })\n            .c(TableCell(\"#\" + id), map(p[\"props\"], function (item) { return TableCell(item).k(i++); }));\n    };\n    return class_2;\n}(Component)));\nvar Table = statefulComponent(/** @class */ (function (_super) {\n    tslib_1.__extends(class_3, _super);\n    function class_3() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    class_3.prototype.render = function () {\n        return h.table(\"Table\").c(h.tbody().c(map(this.props[\"items\"], function (item) { return TableRow(item).k(item[\"id\"]); })));\n    };\n    return class_3;\n}(Component)));\nvar AnimBox = statefulComponent(/** @class */ (function (_super) {\n    tslib_1.__extends(class_4, _super);\n    function class_4() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    class_4.prototype.render = function () {\n        var time = this.props[\"time\"];\n        return h.div(\"AnimBox\")\n            .a({ \"data-id\": this.props[\"id\"] })\n            .s({\n            \"background\": \"rgba(0,0,0,\" + (0.5 + ((time % 10) / 10)) + \")\",\n            \"border-radius\": (time % 10) + \"px\",\n        });\n    };\n    return class_4;\n}(Component)));\nvar Anim = statefulComponent(/** @class */ (function (_super) {\n    tslib_1.__extends(class_5, _super);\n    function class_5() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    class_5.prototype.render = function () {\n        return h.div(\"Anim\").c(map(this.props[\"items\"], function (item) { return AnimBox(item).k(item[\"id\"]); }));\n    };\n    return class_5;\n}(Component)));\nvar TreeLeaf = statefulComponent(/** @class */ (function (_super) {\n    tslib_1.__extends(class_6, _super);\n    function class_6() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    class_6.prototype.render = function () {\n        return h.li(\"TreeLeaf\").c(this.props[\"id\"]);\n    };\n    return class_6;\n}(Component)));\nvar TreeNode = statefulComponent(/** @class */ (function (_super) {\n    tslib_1.__extends(class_7, _super);\n    function class_7() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    class_7.prototype.render = function () {\n        return h.ul(\"TreeNode\").c(map(this.props[\"children\"], function (n) { return (n[\"container\"] ? TreeNode(n) : TreeLeaf(n)).k(n[\"id\"]); }));\n    };\n    return class_7;\n}(Component)));\nvar Tree = statefulComponent(/** @class */ (function (_super) {\n    tslib_1.__extends(class_8, _super);\n    function class_8() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    class_8.prototype.render = function () {\n        return h.div(\"Tree\")\n            .c(TreeNode(this.props[\"root\"]));\n    };\n    return class_8;\n}(Component)));\nfunction route(state) {\n    switch (state[\"location\"]) {\n        case \"table\":\n            return Table(state[\"table\"]);\n        case \"anim\":\n            return Anim(state[\"anim\"]);\n    }\n    return Tree(state[\"tree\"]);\n}\nvar Main = statefulComponent(/** @class */ (function (_super) {\n    tslib_1.__extends(class_9, _super);\n    function class_9() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    class_9.prototype.render = function () {\n        var state = this.props;\n        return h.div(\"Main\").c(state ? route(state) : null);\n    };\n    return class_9;\n}(Component)));\nuibench.init(\"ivi\", \"0.10.0\");\ndocument.addEventListener(\"DOMContentLoaded\", function (e) {\n    var container = document.querySelector(\"#App\");\n    render(Main(), container);\n    uibench.run(function (state) { return render(Main(state), container); }, function (samples) { return render(h.pre().c(JSON.stringify(samples, undefined, 2)), container); });\n});\n"],"sourceRoot":""}