{"version":3,"file":"bundle.js","sources":["../src/index.ts","../../../../ivi/packages/ivi/dist/index.js","../../../../ivi/packages/ivi/dist/root.js"],"sourcesContent":[null,"// # Implementation Details\n//\n// ## Type Casting\n//\n// The current code base contains a lot of type casting. In idiomatic typescript\n// it should be implemented with type guards, and if javascript toolchains\n// supported inlining in some reliable way instead of relying on their\n// heuristics, the code would be way much cleaner with type guard functions.\n//\n// ## `var` vs `let`\n//\n// In some places variables are declared with `var` instead of `let`, it is a\n// micro optimization that propably won't have any significant impact on\n// performance, especially when the JIT kicks in.\n//\n//     function __var(i) {\n//       var j = i;\n//       return function _var() {\n//         return j;\n//       }\n//     }\n//\n//     function __let(i) {\n//       let j = i;\n//       return function _let() {\n//         return j;\n//       };\n//     }\n//\n// In the example above, `_var` function will have the following bytecode in V8:\n//\n//     LdaImmutableCurrentContextSlot [2]\n//     Return\n//\n// And `_let` function:\n//\n//     LdaImmutableCurrentContextSlot [2]\n//     ThrowReferenceErrorIfHole[0];\n//     Return\n//\n// ## `if (a === true) {}` vs `if (a) {}`\n//\n// In a lot of places there are explicit strict equality checks to avoid\n// `toBool()` coercion. Sometimes we can avoid explicit checks when JIT compiler\n// is going to inline functions and will be able to eliminate `toBool()`\n// coercion. For example, `_isArray()` calls doesn't use strict equality checks.\n//\n// `(a === true)`\n//\n// 0x738b024    24  488b5518             REX.W movq rdx, [rbp + 0x18];\n// 0x738b028    28  493995b0000000       REX.W cmpq[r13 + 0xb0](root(true_value)), rdx;\n// 0x738b02f    2f  0f8424000000         jz 0x738b059 < +0x59 >\n// 0x738b035    35  48b80000000014000000 REX.W movq rax, 0x1400000000;\n// 0x738b03f    3f  488b4de8             REX.W movq rcx, [rbp - 0x18];\n// 0x738b043    43  488be5               REX.W movq rsp, rbp;\n// 0x738b046    46  5d                   pop rbp;\n// 0x738b047    47  4883f902             REX.W cmpq rcx, 0x2;\n// 0x738b04b    4b  7f03                 jg 0x738b050 < +0x50 >\n// 0x738b04d    4d  c21000               ret 0x10;\n//\n// `(a)`, inlines `toBool()`\n//\n// 0x618b024    24  488b5518             REX.W movq rdx, [rbp + 0x18];\n// 0x618b028    28  f6c201               testb rdx, 0x1;\n// 0x618b02b    2b  0f84a7000000         jz 0x618b0d8 < +0xd8 >\n// 0x618b031    31  493995b8000000       REX.W cmpq[r13 + 0xb8](root(false_value)), rdx;\n// 0x618b038    38  0f8459000000         jz 0x618b097 < +0x97 >\n// 0x618b03e    3e  493995c0000000       REX.W cmpq[r13 + 0xc0](root(empty_string)), rdx;\n// 0x618b045    45  0f844c000000         jz 0x618b097 < +0x97 >\n// 0x618b04b    4b  488b4aff             REX.W movq rcx, [rdx - 0x1];\n// 0x618b04f    4f  f6410d10             testb[rcx + 0xd], 0x10;\n// 0x618b053    53  0f853e000000         jnz 0x618b097 < +0x97 >\n// 0x618b059    59  49398d38010000       REX.W cmpq[r13 + 0x138](root(heap_number_map)), rcx;\n// 0x618b060    60  0f8484000000         jz 0x618b0ea < +0xea >\n// 0x618b066    66  49398db8010000       REX.W cmpq[r13 + 0x1b8](root(bigint_map)), rcx;\n// 0x618b06d    6d  0f846c000000         jz 0x618b0df < +0xdf >\n// 0x618b073    73  48b8000000000a000000 REX.W movq rax, 0xa00000000;\n// 0x618b07d    7d  488b4de8             REX.W movq rcx, [rbp - 0x18];\n// 0x618b081    81  488be5               REX.W movq rsp, rbp;\n// 0x618b084    84  5d                   pop rbp;\n// 0x618b085    85  4883f902             REX.W cmpq rcx, 0x2;\n// 0x618b089    89  7f03                 jg 0x618b08e < +0x8e >\n// 0x618b08b    8b  c21000               ret 0x10;\n//\n// ## Additional Resources\n//\n// - https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html\n// - https://benediktmeurer.de/2017/06/29/javascript-optimization-patterns-part2/\n//\n// Store global variables in a local scope as const variables so that JIT\n// compiler could easily inline functions and eliminate checks in case global\n// variables are overriden.\nconst _Object = Object;\nconst _Array = Array;\nconst _isArray = _Array.isArray;\nconst _Map = Map;\nconst _Int32Array = Int32Array;\nconst nodeProto = Node.prototype;\nconst elementProto = Element.prototype;\nconst doc = document;\n// Template containers are used to create static templates from HTML strings\n// via `innerHTML`.\nconst HTM_TEMPLATE = /**@__PURE__*/ doc.createElement(\"template\");\nconst HTM_TEMPLATE_CONTENT = HTM_TEMPLATE.content;\nconst _SVG_TEMPLATE = /**@__PURE__*/ doc.createElement(\"template\");\nconst SVG_TEMPLATE = /**@__PURE__*/ doc.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n/**@__PURE__*/ _SVG_TEMPLATE.content.appendChild(SVG_TEMPLATE);\nconst SVG_TEMPLATE_CONTENT = _SVG_TEMPLATE.content.firstChild;\n// Store Node/Element methods to avoid going through a long prototype chain and\n// avoid megamorphic call-sites when accessing DOM nodes.\n/** `Node.prototype.insertBefore` */\nconst nodeInsertBefore = nodeProto.insertBefore;\n/** `Node.prototype.removeChild`. */\nconst nodeRemoveChild = nodeProto.removeChild;\n/** `Node.prototype.cloneNode`. */\nconst nodeCloneNode = nodeProto.cloneNode;\n/** `Element.prototype.setAttribute` */\nconst elementSetAttribute = elementProto.setAttribute;\n/** `Element.prototype.removeAttribute` */\nconst elementRemoveAttribute = elementProto.removeAttribute;\n/** `EventTarget.prototype.addEventListener` */\nconst elementAddEventListener = elementProto.addEventListener;\n/** `EventTarget.prototype.removeEventListener` */\nconst elementRemoveEventListener = elementProto.removeEventListener;\n/** `Object.getOwnPropertyDescriptor(o, p)` */\nconst getDescriptor = (o, p) => _Object.getOwnPropertyDescriptor(o, p);\n/** `Node.prototype.getFirstChild` */\nconst nodeGetFirstChild = /*@__PURE__*/ getDescriptor(nodeProto, \"firstChild\").get;\n/** `Node.prototype.getNextSibling` */\nconst nodeGetNextSibling = /*@__PURE__*/ getDescriptor(nodeProto, \"nextSibling\").get;\n/** `Node.prototype.setTextContent` */\nconst nodeSetTextContent = /*@__PURE__*/ getDescriptor(nodeProto, \"textContent\").set;\n/** `Element.prototype.className` */\nconst elementSetClassName = /*@__PURE__*/ getDescriptor(elementProto, \"className\").set;\n/** `HTMLElement.prototype.style`. */\nconst htmlElementGetStyle = /*@__PURE__*/ getDescriptor(HTMLElement.prototype, \"style\").get;\n/** `SVGElement.prototype.style` */\nconst svgElementGetStyle = /*@__PURE__*/ getDescriptor(SVGElement.prototype, \"style\").get;\n// When object is sealed and stored in a const variable, JIT compiler can\n// eliminate object map(shape) checks when accessing its properties.\n/**\n * Global Render Context.\n */\nexport const RENDER_CONTEXT = _Object.seal({\n    p: null,\n    n: null,\n    si: 0,\n});\n/**\n * Creates a Stateful Node instance.\n *\n * @param v VNode.\n * @returns {@link SNode} instance.\n */\nexport const createSNode = (f, v, c, s, p) => ({ f, v, c, s, p });\nconst _updateTemplateProperties = (currentElement, opCodes, strings, state, prevProps, nextProps, svg) => {\n    for (let i = 0; i < opCodes.length; i++) {\n        let style;\n        const op = opCodes[i];\n        const type = op & 7 /* PropOpCode.TypeMask */;\n        const dataIndex = (op >> 3 /* PropOpCode.DataShift */) & 1023 /* PropOpCode.Mask10 */;\n        if (type === 0 /* PropOpCode.SetNode */) {\n            currentElement = state[dataIndex];\n            style = void 0;\n        }\n        else {\n            let prev;\n            const propsIndex = op >> 13 /* PropOpCode.InputShift */;\n            if (prevProps !== null) {\n                prev = prevProps[propsIndex];\n            }\n            const next = nextProps[propsIndex];\n            if (prev !== next || type === 4 /* PropOpCode.DiffDOMProperty */) {\n                if (type === 1 /* PropOpCode.Common */) {\n                    if (dataIndex === 0 /* CommonPropType.ClassName */) {\n                        elementSetClassName.call(currentElement, next);\n                    }\n                    else { // CommonPropType.TextContent\n                        if (prev === void 0) {\n                            nodeSetTextContent.call(currentElement, next);\n                        }\n                        else {\n                            nodeGetFirstChild.call(currentElement).nodeValue = next;\n                        }\n                    }\n                }\n                else if (type === 7 /* PropOpCode.Directive */) {\n                    next(currentElement);\n                }\n                else {\n                    const key = strings[dataIndex];\n                    if (type === 2 /* PropOpCode.Attribute */) {\n                        if (next !== void 0) {\n                            elementSetAttribute.call(currentElement, key, next);\n                        }\n                        else {\n                            elementRemoveAttribute.call(currentElement, key);\n                        }\n                    }\n                    else if (type === 3 /* PropOpCode.Property */) {\n                        currentElement[key] = next;\n                    }\n                    else if (type === 4 /* PropOpCode.DiffDOMProperty */) {\n                        if (currentElement[key] !== next) {\n                            currentElement[key] = next;\n                        }\n                    }\n                    else if (type === 5 /* PropOpCode.Style */) {\n                        if (style === void 0) {\n                            style = (svg === false)\n                                ? htmlElementGetStyle.call(currentElement)\n                                : svgElementGetStyle.call(currentElement);\n                        }\n                        style.setProperty(key, next);\n                    }\n                    else { // PropOpCode.Event\n                        if (prev !== void 0) {\n                            elementRemoveEventListener.call(currentElement, key, prev);\n                        }\n                        elementAddEventListener.call(currentElement, key, next);\n                    }\n                }\n            }\n        }\n    }\n};\nconst _assignTemplateSlots = (currentNode, opCodes, offset, endOffset, state) => {\n    const ctx = RENDER_CONTEXT;\n    while (offset < endOffset) {\n        const op = opCodes[offset++];\n        if (op & 4 /* StateOpCode.Save */) {\n            state[++ctx.si] = currentNode;\n        }\n        if (op & 2 /* StateOpCode.EnterOrRemove */) {\n            const enterOffset = op >> 3 /* StateOpCode.OffsetShift */;\n            // Enter offset is used to disambiguate between enter and remove\n            // operations. Remove operations will always have a 0 enterOffset.\n            if (enterOffset) { // Enter\n                _assignTemplateSlots(nodeGetFirstChild.call(currentNode), opCodes, offset, offset += enterOffset, state);\n            }\n            else { // Remove\n                // Remove operation implies that current node is always a comment node\n                // followed by a text node.\n                const commentNode = currentNode;\n                state[++ctx.si] = currentNode = nodeGetNextSibling.call(currentNode);\n                commentNode.remove();\n            }\n        }\n        else { // Next\n            currentNode = nodeGetNextSibling.call(currentNode);\n        }\n    }\n};\nconst _mountTemplate = (parentSNode, vNode) => {\n    const ctx = RENDER_CONTEXT;\n    const descriptor = vNode.d;\n    const props = vNode.p;\n    const tplData = descriptor.p1;\n    const rootNode = descriptor.p2();\n    const stateOpCodes = tplData.s;\n    const flags = tplData.f;\n    const state = _Array(flags & 1023 /* TemplateFlags.Mask10 */);\n    state[0] = rootNode;\n    if (stateOpCodes.length > 0) {\n        ctx.si = 0;\n        _assignTemplateSlots(nodeGetFirstChild.call(rootNode), stateOpCodes, 0, stateOpCodes.length, state);\n    }\n    _updateTemplateProperties(rootNode, tplData.p, tplData.d, state, null, props, !!(tplData.f & 1048576 /* TemplateFlags.Svg */));\n    const parentElement = ctx.p;\n    const nextNode = ctx.n;\n    const stateNode = createSNode(1 /* Flags.Template */, vNode, null, state, parentSNode);\n    const childrenSize = flags >> 10 /* TemplateFlags.ChildrenSizeShift */;\n    if (childrenSize > 0) {\n        const childOpCodes = tplData.c;\n        const children = _Array(childrenSize);\n        stateNode.c = children;\n        ctx.p = rootNode;\n        ctx.n = null;\n        let childrenIndex = 0;\n        for (let i = 0; i < childOpCodes.length; i++) {\n            const childOpCode = childOpCodes[i];\n            const type = childOpCode & 3 /* ChildOpCode.Type */;\n            const value = childOpCode >> 2 /* ChildOpCode.ValueShift */;\n            if (type === 0 /* ChildOpCode.Child */) {\n                children[childrenIndex++] = mount(stateNode, props[value]);\n            }\n            else if (type === 1 /* ChildOpCode.SetNext */) {\n                ctx.n = state[value];\n            }\n            else { // ChildOpCode.SetParent\n                ctx.p = state[value];\n                ctx.n = null;\n            }\n        }\n        ctx.p = parentElement;\n    }\n    ctx.n = rootNode;\n    nodeInsertBefore.call(parentElement, rootNode, nextNode);\n    return stateNode;\n};\nconst _updateTemplate = (sNode, next, updateFlags) => {\n    const ctx = RENDER_CONTEXT;\n    const parentElement = ctx.p;\n    const children = sNode.c;\n    const prevProps = sNode.v.p;\n    const state = sNode.s;\n    const nextProps = next.p;\n    const tplData = next.d.p1;\n    const rootDOMNode = state[0];\n    const childrenOpCodes = tplData.c;\n    if (updateFlags & 512 /* Flags.DisplaceNode */) {\n        updateFlags ^= 512 /* Flags.DisplaceNode */;\n        nodeInsertBefore.call(parentElement, rootDOMNode, ctx.n);\n    }\n    _updateTemplateProperties(rootDOMNode, tplData.p, tplData.d, state, prevProps, nextProps, !!(tplData.f & 1048576 /* TemplateFlags.Svg */));\n    ctx.p = rootDOMNode;\n    ctx.n = null;\n    let childrenIndex = 0;\n    for (let i = 0; i < childrenOpCodes.length; i++) {\n        const childOpCode = childrenOpCodes[i];\n        const type = childOpCode & 3 /* ChildOpCode.Type */;\n        const value = childOpCode >> 2 /* ChildOpCode.ValueShift */;\n        if (type === 0 /* ChildOpCode.Child */) {\n            children[childrenIndex] =\n                update(sNode, children[childrenIndex++], nextProps[value], updateFlags);\n        }\n        else if (type === 1 /* ChildOpCode.SetNext */) {\n            ctx.n = state[value];\n        }\n        else { // ChildOpCode.SetParent\n            ctx.p = state[value];\n            ctx.n = null;\n        }\n    }\n    ctx.p = parentElement;\n    ctx.n = rootDOMNode;\n};\nconst _mountList = (parentState, flags, children, vNode) => {\n    let i = children.length;\n    const sChildren = _Array(i);\n    const sNode = createSNode(flags, vNode, sChildren, null, parentState);\n    while (i > 0) {\n        sChildren[--i] = mount(sNode, children[i]);\n    }\n    return sNode;\n};\nconst _updateText = (parentSNode, sNode, next, updateFlags) => {\n    const ctx = RENDER_CONTEXT;\n    const s = sNode.s;\n    if (typeof next !== \"object\") {\n        const prev = sNode.v;\n        // Reassign to reduce memory consumption even if next value is strictly\n        // equal the prev value.\n        sNode.v = next;\n        if (prev !== next) {\n            s.nodeValue = next;\n        }\n        if (updateFlags & 512 /* Flags.DisplaceNode */) {\n            nodeInsertBefore.call(ctx.p, s, ctx.n);\n        }\n        return sNode;\n    }\n    nodeRemoveChild.call(ctx.p, s);\n    return mount(parentSNode, next);\n};\nconst _updateComponent = (sNode, next, updateFlags) => {\n    const child = sNode.c;\n    const prevProps = sNode.v.p;\n    const descriptor = next.d;\n    const nextProps = next.p;\n    if (((sNode.f | updateFlags) & (64 /* Flags.Dirty */ | 256 /* Flags.ForceUpdate */)) || ((prevProps !== nextProps) &&\n        (descriptor.p2 === void 0 || descriptor.p2(prevProps, nextProps) !== true))) {\n        sNode.c = update(sNode, child, sNode.s.r(nextProps), updateFlags);\n    }\n    else if (child !== null) {\n        dirtyCheck(child, updateFlags);\n    }\n};\nconst _updateArray = (parentSNode, sNode, next, updateFlags) => {\n    if (!_isArray(next)) {\n        unmount(sNode, true);\n        return mount(parentSNode, next);\n    }\n    let nextLength = next.length;\n    if ((nextLength = next.length) === 0) {\n        unmount(sNode, true);\n    }\n    else {\n        const sChildren = sNode.c;\n        let prevLength = sChildren.length;\n        if (nextLength !== prevLength) {\n            const newSChildren = _Array(nextLength);\n            sNode.c = newSChildren;\n            while (prevLength > nextLength) {\n                const sChild = sChildren[--prevLength];\n                if (sChild !== null) {\n                    unmount(sChild, true);\n                }\n            }\n            while (nextLength > prevLength) {\n                newSChildren[--nextLength] = mount(sNode, next[nextLength]);\n            }\n        }\n        while (nextLength > 0) {\n            sChildren[--nextLength] = update(sNode, sChildren[nextLength], next[nextLength], updateFlags);\n        }\n    }\n    sNode.f = 8 /* Flags.Array */;\n    return sNode;\n};\n/**\n * Update children list with track by key algorithm.\n *\n * High-level overview of the algorithm that is implemented in this function:\n *\n * This algorithm finds a minimum number of DOM operations. It works in\n * several steps:\n *\n * 1. Common prefix and suffix optimization.\n *\n * Look for nodes with identical keys by simultaneously iterating through nodes\n * in the old children list `A` and new children list `B` from both sides.\n *\n *     A: -> [a b c d] <-\n *     B: -> [a b d] <-\n *\n * Skip nodes \"a\" and \"b\" at the start, and node \"d\" at the end.\n *\n *     A: -> [c] <-\n *     B: -> [] <-\n *\n * 2. Zero length optimizations.\n *\n * Check if the size of one of the list is equal to zero. When length of the\n * old children list is zero, insert remaining nodes from the new list. When\n * length of the new children list is zero, remove remaining nodes from the old\n * list.\n *\n *     A: -> [a b c g] <-\n *     B: -> [a g] <-\n *\n * Skip nodes \"a\" and \"g\" (prefix and suffix optimization).\n *\n *     A: [b c]\n *     B: []\n *\n * Remove nodes \"b\" and \"c\".\n *\n * 3. Index and unmount removed nodes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *     P: [. . . . .] // . == -1\n *\n * Create array `P` (`sources`) with the length of the new children list and\n * fills it with `NewNodeMark` values. This mark indicates that node at this\n * position should be mounted. Later we will assign node positions in the old\n * children list to this array.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *     P: [. . . . .] // . == -1\n *     I: {\n *       c: 0, // B[0] == c\n *       b: 1, // B[1] == b\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     last = 0\n *\n * Create reverse index `I` that maps keys to node positions in the new\n * children list.\n *\n *     A: [b c d e f]\n *         ^\n *     B: [c b h f e]\n *     P: [. 0 . . .] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1, <-\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     last = 1\n *\n * Assign original positions of the nodes from the old children list to the\n * array `P`.\n *\n * Iterate through nodes in the old children list and gets their new positions\n * from the index `I`. Assign old node position to the array `P`. When index\n * `I` doesn't have a key for the old node, it means that it should be\n * unmounted.\n *\n * When we assigning positions to the array `P`, we also store position of the\n * last seen node in the new children list `pos`, if the last seen position is\n * greater than the current position of the node at the new list, then we are\n * switching `rearrangeNodes` flag to `true` (`pos === RearrangeNodes`).\n *\n *     A: [b c d e f]\n *           ^\n *     B: [c b h f e]\n *     P: [1 0 . . .] // . == -1\n *     I: {\n *       c: 0, <-\n *       b: 1,\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     last = 1 // last > 0; rearrangeNodes = true\n *\n * The last position `1` is greater than the current position of the node at the\n * new list `0`, switch `rearrangeNodes` flag to `true`.\n *\n *     A: [b c d e f]\n *             ^\n *     B: [c b h f e]\n *     P: [1 0 . . .] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1,\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     rearrangeNodes = true\n *\n * Node with key \"d\" doesn't exist in the index `I`, unmounts node `d`.\n *\n *     A: [b c d e f]\n *               ^\n *     B: [c b h f e]\n *     P: [1 0 . . 3] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1,\n *       h: 2,\n *       f: 3,\n *       e: 4, <-\n *     }\n *     rearrangeNodes = true\n *\n * Assign position `3` for `e` node.\n *\n *     A: [b c d e f]\n *                 ^\n *     B: [c b h f e]\n *     P: [1 0 . 4 3] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1,\n *       h: 2,\n *       f: 3, <-\n *       e: 4,\n *     }\n *     rearrangeNodes = true\n *\n * Assign position `4` for 'f' node.\n *\n * 4. Find minimum number of moves when `rearrangeNodes` flag is on and mount\n *    new nodes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *     P: [1 * . 4 *] // . == -1  * == -2\n *\n * When `rearrangeNodes` is on, mark all nodes in the array `P` that belong to\n * the [longest increasing subsequence](http://en.wikipedia.org/wiki/Longest_increasing_subsequence)\n * and move all nodes that doesn't belong to this subsequence.\n *\n * Iterate over the new children list and the `P` array simultaneously. When\n * value from `P` array is equal to `NewNodeMark`, mount a new node. When it\n * isn't equal to `LisMark`, move it to a new position.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *                 ^  // new_pos == 4\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *                 ^\n *\n * Node \"e\" has `LisMark` value in the array `P`, nothing changes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *               ^    // new_pos == 3\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *               ^\n *\n * Node \"f\" has `4` value in the array `P`, move it before the next node \"e\".\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *             ^      // new_pos == 2\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *             ^\n *\n * Node \"h\" has `NewNodeMark` value in the array `P`, mount new node \"h\".\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *           ^        // new_pos == 1\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *           ^\n *\n * Node \"b\" has `LisMark` value in the array `P`, nothing changes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *         ^          // new_pos == 0\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *\n * Node \"c\" has `1` value in the array `P`, move it before the next node \"b\".\n *\n * When `rearrangeNodes` flag is off, skip LIS algorithm and mount nodes that\n * have `NewNodeMark` value in the array `P`.\n *\n * NOTE: There are many variations of this algorithm that are used by many UI\n * libraries and many implementations are still using an old optimization\n * technique that were removed several years ago from this implementation. This\n * optimization were used to improve performance of simple moves/swaps. E.g.\n *\n *     A: -> [a b c] <-\n *     B: -> [c b a] <-\n *\n * Move \"a\" and \"c\" nodes to the other edge.\n *\n *     A: -> [b] <-\n *     B: -> [b] <-\n *\n * Skip node \"b\".\n *\n * This optimization were removed because it breaks invariant that insert and\n * remove operations shouldn't trigger a move operation. E.g.\n *\n *     A: -> [a b]\n *     B:    [c a] <-\n *\n * Move node \"a\" to the end.\n *\n *     A: [b]\n *     B: [c]\n *\n * Remove node \"b\" and insert node \"c\".\n *\n * In this use case, this optimization performs one unnecessary operation.\n * Instead of removing node \"b\" and inserting node \"c\", it also moves node \"a\".\n *\n * @param sNode {@link SList} node.\n * @param a Previous {@link ListProps}.\n * @param b Next {@link ListProps}.\n * @param updateFlags Update flags.\n * @noinline\n * @__NOINLINE__\n */\nconst _updateList = (sNode, a, b, updateFlags) => {\n    const aKeys = a.k;\n    const bKeys = b.k;\n    const bVNodes = b.v;\n    let bLength = bKeys.length;\n    let aLength = aKeys.length;\n    const result = _Array(bLength);\n    if (bLength === 0) { // New children list is empty.\n        if (aLength > 0) { // Unmount nodes from the old children list.\n            unmount(sNode, true);\n        }\n    }\n    else if (aLength === 0) { // Old children list is empty.\n        while (bLength > 0) { // Mount nodes from the new children list.\n            result[--bLength] = mount(sNode, bVNodes[bLength]);\n        }\n    }\n    else {\n        const sChildren = sNode.c;\n        let aEnd = aLength - 1;\n        let bEnd = bLength - 1;\n        let start = 0;\n        let key = bKeys[bEnd];\n        // Step 1\n        outer: while (true) {\n            // Update nodes with the same key at the end.\n            while (aKeys[aEnd] === key) {\n                result[bEnd] = update(sNode, sChildren[aEnd--], bVNodes[bEnd], updateFlags);\n                if (start > --bEnd || start > aEnd) {\n                    break outer;\n                }\n                key = bKeys[bEnd];\n            }\n            // Update nodes with the same key at the beginning.\n            while (aKeys[start] === bKeys[start] && ++start <= aEnd && start <= bEnd) {\n                // delayed update (all updates should be performed from right-to-left).\n            }\n            break;\n        }\n        // Step 2\n        if (start > aEnd) {\n            // All nodes from `a` are updated, insert the rest from `b`.\n            while (bEnd >= start) {\n                result[bEnd] = mount(sNode, bVNodes[bEnd--]);\n            }\n        }\n        else if (start > bEnd) {\n            // All nodes from `b` are updated, remove the rest from `a`.\n            bLength = start;\n            do {\n                const sChild = sChildren[bLength++];\n                if (sChild !== null) {\n                    unmount(sChild, true);\n                }\n            } while (bLength <= aEnd);\n        }\n        else { // Step 3\n            let bLength = bEnd - start + 1;\n            const sources = new _Int32Array(bLength); // Maps positions in the new children list to positions in the old list.\n            const keyIndex = new _Map(); // Maps keys to their positions in the new children list.\n            for (let i = 0; i < bLength; i++) {\n                // `NewNodeMark` value indicates that node doesn't exist in the old children list.\n                sources[i] = -1 /* MagicValues.NewNodeMark */;\n                const j = start + i;\n                keyIndex.set(bKeys[j], j);\n            }\n            // When `nodePosition === RearrangeNodes`, it means that one of the nodes is in the wrong position and we should\n            // rearrange nodes with LIS-based algorithm `markLIS()`.\n            let nodePosition = 0;\n            for (let i = start; i <= aEnd; i++) {\n                const sChild = sChildren[i];\n                const nextPosition = keyIndex.get(aKeys[i]);\n                if (nextPosition !== void 0) {\n                    nodePosition = (nodePosition < nextPosition)\n                        ? nextPosition\n                        : 1073741823 /* MagicValues.RearrangeNodes */;\n                    sources[nextPosition - start] = i;\n                    result[nextPosition] = sChild;\n                }\n                else if (sChild !== null) {\n                    unmount(sChild, true);\n                }\n            }\n            // Step 4\n            // Mark LIS nodes only when this node weren't moved `moveNode === false` and we've detected that one of the\n            // children nodes were moved `pos === MagicValues.MovedChildren`.\n            if (!(updateFlags & 512 /* Flags.DisplaceNode */) && nodePosition === 1073741823 /* MagicValues.RearrangeNodes */) {\n                markLIS(sources);\n            }\n            while (bLength-- > 0) {\n                bEnd = bLength + start;\n                const node = bVNodes[bEnd];\n                const lisValue = sources[bLength];\n                result[bEnd] = (lisValue === -1)\n                    ? mount(sNode, node)\n                    : update(sNode, result[bEnd], node, updateFlags |\n                        ((nodePosition === 1073741823 /* MagicValues.RearrangeNodes */ && lisValue !== -2 /* MagicValues.LISMark */)\n                            ? 512 /* Flags.DisplaceNode */\n                            : 0));\n            }\n        }\n        // Delayed update for nodes from Step 1 (prefix only). Reconciliation algorithm always updates nodes from right to\n        // left.\n        while (start > 0) {\n            result[--start] = update(sNode, sChildren[start], bVNodes[start], updateFlags);\n        }\n    }\n    sNode.c = result;\n};\n/**\n * Modified Longest Increased Subsequence algorithm.\n *\n * Mutates input array `a` and replaces all values that are part of LIS with -2 value.\n *\n * Constraints:\n * - Doesn't work with negative numbers. -1 values are ignored.\n * - Input array `a` should contain at least one value that is greater than -1.\n *\n * {@link http://en.wikipedia.org/wiki/Longest_increasing_subsequence}\n *\n * @example\n *\n *     const A = Int32Array.from([-1, 0, 2, 1]);\n *     markLIS(A);\n *     // A => [-1, -2, 2, -2]\n *\n * @param a Array of numbers.\n * @noinline\n * @__NOINLINE__\n */\nconst markLIS = (a) => {\n    const length = a.length;\n    const parent = new _Int32Array(length);\n    const index = new _Int32Array(length);\n    let indexLength = 0;\n    let i = 0;\n    let j;\n    let k;\n    let lo;\n    let hi;\n    // Skip -1 values at the start of the input array `a`.\n    for (; a[i] === -1 /* MagicValues.NewNodeMark */; i++) { /**/ }\n    index[0] = i++;\n    for (; i < length; i++) {\n        k = a[i];\n        if (k !== -1 /* MagicValues.NewNodeMark */) { // Ignore -1 values.\n            j = index[indexLength];\n            if (a[j] < k) {\n                parent[i] = j;\n                index[++indexLength] = i;\n            }\n            else {\n                lo = 0;\n                hi = indexLength;\n                while (lo < hi) {\n                    j = (lo + hi) >> 1;\n                    if (a[index[j]] < k) {\n                        lo = j + 1;\n                    }\n                    else {\n                        hi = j;\n                    }\n                }\n                if (k < a[index[lo]]) {\n                    if (lo > 0) {\n                        parent[i] = index[lo - 1];\n                    }\n                    index[lo] = i;\n                }\n            }\n        }\n    }\n    ;\n    // Mutate input array `a` and assign -2 value to all nodes that are part of LIS.\n    j = index[indexLength];\n    while (indexLength-- >= 0) {\n        a[j] = -2 /* MagicValues.LISMark */;\n        j = parent[j];\n    }\n};\n/**\n * Creates a HTML Template cloning factory.\n */\nexport const _h = (t) => (() => {\n    if (typeof t === \"string\") {\n        HTM_TEMPLATE.innerHTML = t;\n        t = HTM_TEMPLATE_CONTENT.firstChild;\n    }\n    return nodeCloneNode.call(t, true);\n});\n/**\n * Creates a HTML Template factory.\n */\nexport const _hN = (t) => (() => (HTM_TEMPLATE.innerHTML = t,\n    HTM_TEMPLATE_CONTENT.firstChild));\n/**\n * Creates a HTML Element factory.\n */\nexport const _hE = (t) => (() => doc.createElement(t));\n/**\n * Creates a SVG Template cloning factory.\n */\nexport const _s = (t) => (() => {\n    if (typeof t === \"string\") {\n        SVG_TEMPLATE.innerHTML = t;\n        t = SVG_TEMPLATE_CONTENT.firstChild;\n    }\n    return nodeCloneNode.call(t, true);\n});\n/**\n * Creates a SVG Template factory.\n */\nexport const _sN = (t) => (() => (SVG_TEMPLATE.innerHTML = t,\n    SVG_TEMPLATE_CONTENT.firstChild));\n/**\n * Creates a SVG Element factory.\n */\nexport const _sE = (t) => (() => doc.createElementNS(\"http://www.w3.org/2000/svg\", t));\n/**\n * Creates a template descriptor.\n */\nexport const _T = (p2, f, p, c, s, d) => ({\n    f: 1 /* Flags.Template */,\n    p1: { f, p, c, s, d },\n    p2,\n});\nexport const _t = (d, p) => ({ d, p });\n/**\n * Creates a factory that produces component nodes.\n *\n * @typeparam P Property type.\n * @param p1 Function that creates stateful render functions.\n * @param p2 Function that checks `props` for equality.\n * @returns Factory that produces component nodes.\n */\nexport const component = (p1, p2) => (p1 = { f: 2 /* Flags.Component */, p1, p2 },\n    (p) => ({ d: p1, p }));\n/**\n * Adds an unmount hook.\n *\n * @example\n *\n *     const Example = component((c) => {\n *       useUnmount(c, () => { console.log(\"unmounted\"); });\n *\n *       return () => null;\n *     });\n *\n * @param component Component instance.\n * @param hook Unmount hook.\n */\nexport const useUnmount = (component, hook) => {\n    const s = component.s;\n    const hooks = s.u;\n    s.u = (hooks === null)\n        ? hook\n        : (typeof hooks === \"function\")\n            ? [hooks, hook]\n            : (hooks.push(hook), hooks);\n};\n/**\n * Invalidates a component.\n *\n * @param c Component instance.\n */\nexport const invalidate = (c) => {\n    if (!(c.f & 64 /* Flags.Dirty */)) {\n        c.f |= 64 /* Flags.Dirty */;\n        let parent = c.p;\n        while (parent !== null) {\n            if (parent.f & 128 /* Flags.DirtySubtree */) {\n                return;\n            }\n            parent.f |= 128 /* Flags.DirtySubtree */;\n            c = parent;\n            parent = parent.p;\n        }\n        c.v.d.p1(c);\n    }\n};\n/**\n * VDescriptor for List nodes.\n */\nconst LIST = { f: 4 /* Flags.List */, p1: null, p2: null };\n/**\n * Creates a dynamic list.\n *\n * @typeparam E Entry type.\n * @typeparam K Key type.\n * @param entries Entries.\n * @param getKey Get key from entry function.\n * @param render Render entry function.\n * @returns Dynamic list.\n */\nexport const List = (entries, getKey, render) => ({\n    d: LIST,\n    p: {\n        k: entries.map(getKey),\n        v: entries.map(render),\n    },\n});\n/**\n * Performs a Dirty Checking in a Stateful Node Subtree.\n *\n * @param sNode Stateful Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n */\nexport const dirtyCheck = (sNode, updateFlags) => {\n    const ctx = RENDER_CONTEXT;\n    const children = sNode.c;\n    const flags = sNode.f;\n    if (flags & 1 /* Flags.Template */) {\n        const rootDOMNode = sNode.s[0];\n        if (updateFlags & 512 /* Flags.DisplaceNode */) {\n            updateFlags ^= 512 /* Flags.DisplaceNode */;\n            nodeInsertBefore.call(ctx.p, rootDOMNode, ctx.n);\n        }\n        if (flags & 128 /* Flags.DirtySubtree */) {\n            ctx.p = rootDOMNode;\n            ctx.n = null;\n            const parentDOMElement = ctx.p;\n            const state = sNode.s;\n            const childOpCodes = sNode.v.d.p1.c;\n            let childrenIndex = 0;\n            for (let i = 0; i < childOpCodes.length; i++) {\n                const op = childOpCodes[i];\n                const type = op & 3 /* ChildOpCode.Type */;\n                const value = op >> 2 /* ChildOpCode.ValueShift */;\n                if (type === 0 /* ChildOpCode.Child */) {\n                    const sChild = children[childrenIndex++];\n                    if (sChild !== null) {\n                        dirtyCheck(sChild, updateFlags);\n                    }\n                }\n                else if (type === 1 /* ChildOpCode.SetNext */) {\n                    ctx.n = state[value];\n                }\n                else { // ChildOpCode.SetParent\n                    ctx.p = state[value];\n                    ctx.n = null;\n                }\n            }\n            ctx.p = parentDOMElement;\n        }\n        ctx.n = rootDOMNode;\n    }\n    else if (flags & 16 /* Flags.Text */) {\n        if (updateFlags & 512 /* Flags.DisplaceNode */) {\n            nodeInsertBefore.call(ctx.p, sNode.s, ctx.n);\n        }\n        ctx.n = sNode.s;\n    }\n    else if (flags & 2 /* Flags.Component */) {\n        if ((flags | updateFlags) & (64 /* Flags.Dirty */ | 256 /* Flags.ForceUpdate */)) {\n            sNode.c = update(sNode, children, sNode.s.r(sNode.v.p), updateFlags);\n        }\n        else if (children !== null) {\n            dirtyCheck(children, updateFlags);\n        }\n    }\n    else { // Array || List\n        let i = children.length;\n        while (--i >= 0) {\n            const sChild = children[i];\n            if (sChild !== null) {\n                dirtyCheck(sChild, updateFlags);\n            }\n        }\n    }\n    sNode.f &= 63 /* Flags.TypeMask */;\n};\n/**\n * Updates a Stateful Node with a new Stateless Node.\n *\n * @param parentSNode Parent Stateul Node.\n * @param sNode Stateful Node to update.\n * @param next New Stateless Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n * @returns Stateful Node.\n */\nexport const update = (parentSNode, sNode, next, updateFlags) => {\n    if (sNode === null) {\n        return mount(parentSNode, next);\n    }\n    if (next === null) {\n        unmount(sNode, true);\n        return null;\n    }\n    const flags = sNode.f & 63 /* Flags.TypeMask */;\n    if (flags === 16 /* Flags.Text */) {\n        return _updateText(parentSNode, sNode, next, updateFlags);\n    }\n    const prev = sNode.v;\n    sNode.v = next;\n    if (prev === next) {\n        dirtyCheck(sNode, updateFlags);\n        return sNode;\n    }\n    if (flags === 8 /* Flags.Array */) {\n        return _updateArray(parentSNode, sNode, next, updateFlags);\n    }\n    // Text and Array should be checked before Component, Template and List\n    // because their stateless nodes are represented with basic string and array\n    // types.\n    if (prev.d !== next.d) {\n        unmount(sNode, true);\n        return mount(parentSNode, next);\n    }\n    if (flags === 2 /* Flags.Component */) {\n        _updateComponent(sNode, next, updateFlags);\n    }\n    else if (flags === 1 /* Flags.Template */) {\n        _updateTemplate(sNode, next, updateFlags);\n    }\n    else {\n        _updateList(sNode, prev.p, next.p, updateFlags);\n    }\n    sNode.f &= 63 /* Flags.TypeMask */;\n    return sNode;\n};\n/**\n * Mounts Stateless Node.\n *\n * @param parentSNode Parent Stateful Node.\n * @param v Stateless Node.\n * @returns Mounted Stateful Node.\n */\nexport const mount = (parentSNode, v) => {\n    if (v !== null) {\n        if (typeof v === \"object\") {\n            if (_isArray(v)) {\n                return _mountList(parentSNode, 8 /* Flags.Array */, v, v);\n            }\n            else {\n                const descriptor = v.d;\n                const type = descriptor.f & (1 /* Flags.Template */ | 2 /* Flags.Component */);\n                if (type === 1 /* Flags.Template */) {\n                    return _mountTemplate(parentSNode, v);\n                }\n                else if (type === 2 /* Flags.Component */) {\n                    const componentState = { r: null, u: null };\n                    const sNode = createSNode(2 /* Flags.Component */, v, null, componentState, parentSNode);\n                    const renderFn = descriptor.p1(sNode);\n                    componentState.r = renderFn;\n                    sNode.c = mount(sNode, renderFn(v.p));\n                    return sNode;\n                }\n                // List\n                return _mountList(parentSNode, 4 /* Flags.List */, v.p.v, v);\n            }\n        }\n        else {\n            const ctx = RENDER_CONTEXT;\n            const e = doc.createTextNode(v);\n            nodeInsertBefore.call(ctx.p, e, ctx.n);\n            ctx.n = e;\n            return createSNode(16 /* Flags.Text */, v, null, e, parentSNode);\n        }\n    }\n    return null;\n};\n/**\n * Unmounts Stateful Node.\n *\n * @param sNode Stateful Node.\n * @param detach Detach root DOM nodes from the DOM.\n */\nexport const unmount = (sNode, detach) => {\n    const flags = sNode.f;\n    if (detach === true && (flags & (1 /* Flags.Template */ | 16 /* Flags.Text */))) {\n        detach = false;\n        nodeRemoveChild.call(RENDER_CONTEXT.p, (flags & 1 /* Flags.Template */)\n            ? sNode.s[0]\n            : sNode.s);\n    }\n    const sChildren = sNode.c;\n    if (sChildren !== null) {\n        if (_isArray(sChildren)) {\n            for (let i = 0; i < sChildren.length; i++) {\n                const sChild = sChildren[i];\n                if (sChild !== null) {\n                    unmount(sChild, detach);\n                }\n            }\n        }\n        else {\n            unmount(sChildren, detach);\n        }\n    }\n    if (flags & 2 /* Flags.Component */) {\n        const unmountHooks = sNode.s.u;\n        if (unmountHooks !== null) {\n            if (typeof unmountHooks === \"function\") {\n                unmountHooks();\n            }\n            else {\n                for (let i = 0; i < unmountHooks.length; i++) {\n                    unmountHooks[i]();\n                }\n            }\n        }\n    }\n};\n//# sourceMappingURL=index.js.map","import { RENDER_CONTEXT, createSNode, dirtyCheck, update, unmount, } from \"./index.js\";\nconst _queueMicrotask = queueMicrotask;\nconst ROOT_DESCRIPTOR = {\n    // Root Descriptor should always have a `Flags.Root` flag.\n    f: 32 /* Flags.Root */,\n    // OnRootInvalidated hook\n    p1: (root) => {\n        _queueMicrotask(() => {\n            // Retrieves DOM slot from VNode object.\n            const domSlot = root.v.p;\n            // Assign parent element and next node to the render context.\n            RENDER_CONTEXT.p = domSlot.p;\n            RENDER_CONTEXT.n = domSlot.n;\n            // Updates invalidated components.\n            dirtyCheck(root.c, 0);\n            // Flags should always be reassigned to clear dirty flags.\n            root.f = 32 /* Flags.Root */;\n        });\n    },\n    // p2 should always be initialized with `null` value. This propery is\n    // initialized so that all `Descriptor` objects will have the same object\n    // shape and all call-sites that access Descriptor objects will be in a\n    // monorphic state.\n    p2: null,\n};\n/**\n * Creates a new root.\n *\n * @param p Parent DOM Element.\n * @param n Next DOM Element.\n * @returns Root Node.\n */\nexport const createRoot = (p, n = null) => (createSNode(32 /* Flags.Root */, \n// VNode object.\n{\n    // VNode descriptor should be initialized with `RootDescriptor`\n    d: ROOT_DESCRIPTOR,\n    // VNode props object contains the location in the DOM tree where subtree\n    // should be rendered.\n    p: {\n        // Parent DOM Element.\n        p,\n        // Next DOM Node.\n        n,\n    },\n}, \n// Children should always be initialized with `null` value.\nnull, \n// State `SRoot<State>` that can be used to store any value.\nnull, \n// Parent SNode should always have a `null` value.\nnull));\n/**\n * Updates a root subtree.\n *\n * @param root Root Node.\n * @param v Stateless Node.\n * @param forceUpdate Force update for all components.\n */\nexport const updateRoot = (root, v, forceUpdate = false) => {\n    // Retrieves DOM slot from VNode object.\n    const domSlot = root.v.p;\n    // Assign parent element and next node to the render context.\n    RENDER_CONTEXT.p = domSlot.p;\n    RENDER_CONTEXT.n = domSlot.n;\n    root.c = update(\n    // Parent SNode should always be a root node.\n    root, \n    // Previous UI state.\n    root.c, \n    // UI Representation.\n    v, \n    // Force update.\n    forceUpdate === true\n        ? 256 /* Flags.ForceUpdate */\n        : 0);\n    // Flags should always be reassigned on update to clear dirty flags.\n    root.f = 32 /* Flags.Root */;\n};\n/**\n * Force update for all components in a root subtree.\n *\n * @param root Root Node.\n */\nexport const forceUpdateRoot = (root) => {\n    // Checks if a Root Node has any children.\n    if (root.c !== null) {\n        update(\n        // Parent SNode should always be a root node.\n        root, \n        // Previous Stateful Node\n        root.c, \n        // Previous Stateless Node.\n        root.c.v, 256 /* Flags.ForceUpdate */);\n        // Flags should always be reassigned on update to clear dirty flags.\n        root.f = 32 /* Flags.Root */;\n    }\n};\n/**\n * Disposes a root subtree and triggers all unmount hooks.\n *\n * @param root Root Node.\n * @param detach Detach root nodes from the DOM.\n */\nexport const disposeRoot = (root, detach) => {\n    if (root.c !== null) {\n        // Clear dirty flags.\n        root.f = 32 /* Flags.Root */;\n        // Assign parent element to the render context.\n        RENDER_CONTEXT.p = root.v.p.p;\n        // Unmounts a root subtree.\n        unmount(\n        // Previous UI state.\n        root.c, \n        // Detach root nodes.\n        detach);\n    }\n};\n//# sourceMappingURL=root.js.map"],"names":["_Object","Object","_Array","Array","_isArray","isArray","_Map","Map","_Int32Array","Int32Array","nodeProto","Node","prototype","elementProto","Element","doc","document","HTM_TEMPLATE","createElement","HTM_TEMPLATE_CONTENT","content","_SVG_TEMPLATE","firstChild","nodeInsertBefore","insertBefore","nodeRemoveChild","removeChild","nodeCloneNode","cloneNode","elementSetAttribute","setAttribute","elementRemoveAttribute","removeAttribute","elementAddEventListener","addEventListener","elementRemoveEventListener","removeEventListener","getDescriptor","o","p","getOwnPropertyDescriptor","nodeGetFirstChild","get","nodeGetNextSibling","nodeSetTextContent","set","elementSetClassName","htmlElementGetStyle","HTMLElement","svgElementGetStyle","SVGElement","RENDER_CONTEXT","seal","n","si","createSNode","f","v","c","s","_updateTemplateProperties","currentElement","opCodes","strings","state","prevProps","nextProps","svg","i","length","style","op","type","dataIndex","prev","propsIndex","next","call","nodeValue","key","setProperty","_assignTemplateSlots","currentNode","offset","endOffset","ctx","enterOffset","commentNode","remove","_mountTemplate","parentSNode","vNode","descriptor","d","props","tplData","p1","rootNode","p2","stateOpCodes","flags","parentElement","nextNode","stateNode","childrenSize","childOpCodes","children","childrenIndex","childOpCode","value","mount","_updateTemplate","sNode","updateFlags","rootDOMNode","childrenOpCodes","update","_mountList","parentState","sChildren","_updateText","_updateComponent","child","r","dirtyCheck","_updateArray","unmount","nextLength","prevLength","newSChildren","sChild","_updateList","a","b","aKeys","k","bKeys","bVNodes","bLength","aLength","result","aEnd","bEnd","start","outer","sources","keyIndex","j","nodePosition","nextPosition","markLIS","node","lisValue","parent","index","indexLength","lo","hi","_h","t","innerHTML","_hE","_T","_t","component","LIST","List","entries","getKey","render","map","parentDOMElement","componentState","u","renderFn","e","createTextNode","detach","unmountHooks","_queueMicrotask","queueMicrotask","ROOT_DESCRIPTOR","root","domSlot","createRoot","updateRoot","forceUpdate","tableCellId","_","tableRowId","row","id","animId","item","treeNodeId","_tpl_","_OP","_TPL_DATA","TableCell","click","console","log","_tpl_2","TableRow","active","_tpl_3","Table","items","_tpl_4","AnimBox","time","_tpl_5","_OP2","Anim","_tpl_6","TreeLeaf","subtree","container","TreeNode","_tpl_7","_tpl_8","Tree","_tpl_9","Main","location","table","anim","tree","uibench","init","getElementById","run","samples","JSON","stringify"],"mappings":";;UA6CG,CAAA;AC7CH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA,MAAMA,OAAO,GAAGC,MAAM;AACtB,MAAMC,MAAM,GAAGC,KAAK;AACpB,MAAMC,QAAQ,GAAkCF,MAAM,CAACG,OAAO;AAC9D,MAAMC,IAAI,GAAGC,GAAG;AAChB,MAAMC,WAAW,GAAGC,UAAU;AAE9B,MAAMC,SAAS,GAAGC,IAAI,CAACC,SAAS;AAChC,MAAMC,YAAY,GAAGC,OAAO,CAACF,SAAS;AACtC,MAAMG,GAAG,GAAGC,QAAQ;AAEpB;AACA;AACA,MAAMC,YAAY,iBAAiBF,GAAG,CAACG,aAAa,CAAC,UAAU,CAAC;AAChE,MAAMC,oBAAoB,GAAGF,YAAY,CAACG,OAAO;AACjD,MAAMC,aAAa,iBAAiBN,GAAG,CAACG,aAAa,CAAC,UAAU,CAAC;AAGpCG,aAAa,CAACD,OAAO,CAACE,UAAqB;AAExE;AACA;AAEA;AACA,MAAMC,gBAAgB,GAAGb,SAAS,CAACc,YAAY;AAC/C;AACA,MAAMC,eAAe,GAAGf,SAAS,CAACgB,WAAW;AAC7C;AACA,MAAMC,aAAa,GAAGjB,SAAS,CAACkB,SAAS;AACzC;AACA,MAAMC,mBAAmB,GAAGhB,YAAY,CAACiB,YAAY;AACrD;AACA,MAAMC,sBAAsB,GAAGlB,YAAY,CAACmB,eAAe;AAC3D;AACA,MAAMC,uBAAuB,GAAGpB,YAAY,CAACqB,gBAAgB;AAC7D;AACA,MAAMC,0BAA0B,GAAGtB,YAAY,CAACuB,mBAAmB;AAEnE;AACA,MAAMC,aAAa,GAAGA,CAACC,CAAM,EAAEC,CAA2B,KAAKvC,OAAO,CAACwC,wBAAwB,CAACF,CAAC,EAAEC,CAAC,CAAC;AAErG;AACA,MAAME,iBAAiB,GAAgBJ,aAAa,CAAC3B,SAAS,EAAE,YAAY,CAAE,CAACgC,GAAI;AACnF;AACA,MAAMC,kBAAkB,GAAgBN,aAAa,CAAC3B,SAAS,EAAE,aAAa,CAAE,CAACgC,GAAI;AACrF;AACA,MAAME,kBAAkB,GAAgBP,aAAa,CAAC3B,SAAS,EAAE,aAAa,CAAE,CAACmC,GAAI;AACrF;AACA,MAAMC,mBAAmB,GAAgBT,aAAa,CAACxB,YAAY,EAAE,WAAW,CAAE,CAACgC,GAAI;AACvF;AACA,MAAME,mBAAmB,GAAgBV,aAAa,CAACW,WAAW,CAACpC,SAAS,EAAE,OAAO,CAAE,CAAC8B,GAAI;AAC5F;AACA,MAAMO,kBAAkB,GAAgBZ,aAAa,CAACa,UAAU,CAACtC,SAAS,EAAE,OAAO,CAAE,CAAC8B,GAAI;AAc1F;AACA;AACA;;;AAGO,MAAMS,cAAc,GAAkBnD,OAAO,CAACoD,IAAI,CAAC;EACxDb,CAAC,EAAE,IAAK;EACRc,CAAC,EAAE,IAAI;EACPC,EAAE,EAAE;CACL,CAAC;AAiEF;;;;;;AAMO,MAAMC,WAAW,GAAGA,CACzBC,CAAQ,EACRC,CAAI,EACJC,CAAqC,EACrCC,CAAI,EACJpB,CAAe,MACE;EAAEiB,CAAC;EAAEC,CAAC;EAAEC,CAAC;EAAEC,CAAC;EAAEpB;AAAC,CAAE,CAAC;AAwIrC,MAAMqB,yBAAyB,GAAGA,CAChCC,cAAuB,EACvBC,OAAqB,EACrBC,OAAiB,EACjBC,KAAa,EACbC,SAAuB,EACvBC,SAAgB,EAChBC,GAAY,KACV;EACF,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,OAAO,CAACO,MAAM,EAAED,CAAC,EAAE,EAAE;IACvC,IAAIE,KAAsC;IAC1C,MAAMC,EAAE,GAAGT,OAAO,CAACM,CAAC,CAAC;IACrB,MAAMI,IAAI,GAAGD,EAAE,GAAA,CAAA,CAAA;IACf,MAAME,SAAS,GAAIF,EAAE,IAAyB,CAAA,CAAA,6BAAA,IAAA,CAAA;IAC9C,IAAIC,IAAI,KAAyB,CAAA,CAAA,0BAAA;MAC/BX,cAAc,GAAGG,KAAK,CAACS,SAAS,CAAY;MAC5CH,KAAK,GAAG,KAAK,CAAC;KACf,MAAM;MACL,IAAII,IAAI;MACR,MAAMC,UAAU,GAAGJ,EAAE,IAAA,EAAA,CAAA;MACrB,IAAIN,SAAS,KAAK,IAAI,EAAE;QACtBS,IAAI,GAAGT,SAAS,CAACU,UAAU,CAAC;;MAE9B,MAAMC,IAAI,GAAGV,SAAS,CAACS,UAAU,CAAC;MAClC,IAAID,IAAI,KAAKE,IAAI,IAAIJ,IAAI,KAAiC,CAAA,CAAA,kCAAA;QACxD,IAAIA,IAAI,KAAwB,CAAA,CAAA,yBAAA;UAC9B,IAAIC,SAAS,KAA+B,CAAA,CAAA,gCAAA;YAC1C3B,mBAAmB,CAAC+B,IAAI,CAAChB,cAAc,EAAEe,IAAI,CAAC;WAC/C,MAAM;YAAE;YACP,IAAIF,IAAI,KAAK,KAAK,CAAC,EAAE;cACnB9B,kBAAkB,CAACiC,IAAI,CAAChB,cAAc,EAAEe,IAAI,CAAC;aAC9C,MAAM;cACLnC,iBAAiB,CAACoC,IAAI,CAAChB,cAAc,CAAC,CAACiB,SAAS,GAAGF,IAAI;;;SAG5D,MAAM,IAAIJ,IAAI,KAA2B,CAAA,CAAA,4BAAA;UACvCI,IAAyB,CAACf,cAAc,CAAC;SAC3C,MAAM;UACL,MAAMkB,GAAG,GAAGhB,OAAO,CAACU,SAAS,CAAC;UAC9B,IAAID,IAAI,KAA2B,CAAA,CAAA,4BAAA;YACjC,IAAII,IAAI,KAAK,KAAK,CAAC,EAAE;cACnB/C,mBAAmB,CAACgD,IAAI,CAAChB,cAAc,EAAEkB,GAAG,EAAEH,IAAc,CAAC;aAC9D,MAAM;cACL7C,sBAAsB,CAAC8C,IAAI,CAAChB,cAAc,EAAEkB,GAAG,CAAC;;WAEnD,MAAM,IAAIP,IAAI,KAA0B,CAAA,CAAA,2BAAA;YACtCX,cAAsC,CAACkB,GAAG,CAAC,GAAGH,IAAI;WACpD,MAAM,IAAIJ,IAAI,KAAiC,CAAA,CAAA,kCAAA;YAC9C,IAAKX,cAAsC,CAACkB,GAAG,CAAC,KAAKH,IAAI,EAAE;cACxDf,cAAsC,CAACkB,GAAG,CAAC,GAAGH,IAAI;;WAEtD,MAAM,IAAIJ,IAAI,KAAuB,CAAA,CAAA,wBAAA;YACpC,IAAIF,KAAK,KAAK,KAAK,CAAC,EAAE;cACpBA,KAAK,GAAIH,GAAG,KAAK,KAAK,GAClBpB,mBAAmB,CAAC8B,IAAI,CAAChB,cAA6B,CAAC,GACvDZ,kBAAkB,CAAC4B,IAAI,CAAChB,cAA4B,CAAC;;YAE3DS,KAAM,CAACU,WAAW,CAACD,GAAG,EAAEH,IAAc,CAAC;WACxC,MAAM;YAAE;YACP,IAAIF,IAAI,KAAK,KAAK,CAAC,EAAE;cACnBvC,0BAA0B,CAAC0C,IAAI,CAAChB,cAAc,EAAEkB,GAAG,EAAEL,IAAI,CAAC;;YAE5DzC,uBAAuB,CAAC4C,IAAI,CAAChB,cAAc,EAAEkB,GAAG,EAAEH,IAAI,CAAC;;;;;;AAMnE,CAAC;AAED,MAAMK,oBAAoB,GAAGA,CAC3BC,WAAiB,EACjBpB,OAAsB,EACtBqB,MAAc,EACdC,SAAiB,EACjBpB,KAAa,KACX;EACF,MAAMqB,GAAG,GAAGlC,cAAc;EAC1B,OAAOgC,MAAM,GAAGC,SAAS,EAAE;IACzB,MAAMb,EAAE,GAAGT,OAAO,CAACqB,MAAM,EAAE,CAAC;IAC5B,IAAIZ,EAAE,GAAqB,CAAA,CAAA,wBAAA;MACzBP,KAAK,CAAC,EAAEqB,GAAG,CAAC/B,EAAE,CAAC,GAAG4B,WAAW;;IAE/B,IAAIX,EAAE,GAA8B,CAAA,CAAA,iCAAA;MAClC,MAAMe,WAAW,GAAGf,EAAE,IAAA,CAAA,CAAA;MACtB;MACA;MACA,IAAIe,WAAW,EAAE;QAAE;QACjBL,oBAAoB,CAClBxC,iBAAiB,CAACoC,IAAI,CAACK,WAAW,CAAC,EACnCpB,OAAO,EACPqB,MAAM,EACNA,MAAM,IAAIG,WAAW,EACrBtB,KAAK,CACN;OACF,MAAM;QAAE;QACP;QACA;QACA,MAAMuB,WAAW,GAAGL,WAAsB;QAC1ClB,KAAK,CAAC,EAAEqB,GAAG,CAAC/B,EAAE,CAAC,GAAG4B,WAAW,GAAGvC,kBAAkB,CAACkC,IAAI,CAACK,WAAW,CAAC;QACpEK,WAAW,CAACC,MAAM,EAAE;;KAEvB,MAAM;MAAE;MACPN,WAAW,GAAGvC,kBAAkB,CAACkC,IAAI,CAACK,WAAW,CAAC;;;AAGxD,CAAC;AAED,MAAMO,cAAc,GAAGA,CAACC,WAAkB,EAAEC,KAAgB,KAAI;EAC9D,MAAMN,GAAG,GAAGlC,cAAc;EAC1B,MAAMyC,UAAU,GAAGD,KAAK,CAACE,CAAC;EAC1B,MAAMC,KAAK,GAAGH,KAAK,CAACpD,CAAC;EACrB,MAAMwD,OAAO,GAAGH,UAAU,CAACI,EAAE;EAC7B,MAAMC,QAAQ,GAAGL,UAAU,CAACM,EAAE,EAAE;EAChC,MAAMC,YAAY,GAAGJ,OAAO,CAACpC,CAAC;EAC9B,MAAMyC,KAAK,GAAGL,OAAO,CAACvC,CAAC;EACvB,MAAMQ,KAAK,GAAG9D,MAAM,CAAOkG,KAAK,GAAwB,IAAA,CAAA,2BAAA;EACxDpC,KAAK,CAAC,CAAC,CAAC,GAAGiC,QAAQ;EAEnB,IAAIE,YAAY,CAAC9B,MAAM,GAAG,CAAC,EAAE;IAC3BgB,GAAG,CAAC/B,EAAE,GAAG,CAAC;IACV2B,oBAAoB,CAClBxC,iBAAiB,CAACoC,IAAI,CAACoB,QAAQ,CAAC,EAChCE,YAAY,EACZ,CAAC,EACDA,YAAY,CAAC9B,MAAM,EACnBL,KAAK,CACN;;EAEHJ,yBAAyB,CACvBqC,QAAQ,EACRF,OAAO,CAACxD,CAAC,EACTwD,OAAO,CAACF,CAAC,EACT7B,KAAK,EACL,IAAI,EACJ8B,KAAK,EACL,CAAC,EAAEC,OAAO,CAACvC,CAAC,GAAA,OAAA,CAAqB,wBAAA,CAClC;EAED,MAAM6C,aAAa,GAAGhB,GAAG,CAAC9C,CAAC;EAC3B,MAAM+D,QAAQ,GAAGjB,GAAG,CAAChC,CAAC;EACtB,MAAMkD,SAAS,GAAGhD,WAAW,CAAiBoC,CAAAA,CAAAA,sBAAAA,KAAK,EAAE,IAAI,EAAE3B,KAAK,EAAE0B,WAAW,CAAC;EAC9E,MAAMc,YAAY,GAAGJ,KAAK,IAAA,EAAA,CAAA;EAC1B,IAAII,YAAY,GAAG,CAAC,EAAE;IACpB,MAAMC,YAAY,GAAGV,OAAO,CAACrC,CAAC;IAC9B,MAAMgD,QAAQ,GAAGxG,MAAM,CAACsG,YAAY,CAAC;IACrCD,SAAS,CAAC7C,CAAC,GAAGgD,QAAQ;IACtBrB,GAAG,CAAC9C,CAAC,GAAG0D,QAAQ;IAChBZ,GAAG,CAAChC,CAAC,GAAG,IAAI;IACZ,IAAIsD,aAAa,GAAG,CAAC;IACrB,KAAK,IAAIvC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqC,YAAY,CAACpC,MAAM,EAAED,CAAC,EAAE,EAAE;MAC5C,MAAMwC,WAAW,GAAGH,YAAY,CAACrC,CAAC,CAAC;MACnC,MAAMI,IAAI,GAAGoC,WAAW,GAAA,CAAA,CAAA;MACxB,MAAMC,KAAK,GAAGD,WAAW,IAAA,CAAA,CAAA;MACzB,IAAIpC,IAAI,KAAwB,CAAA,CAAA,yBAAA;QAC9BkC,QAAQ,CAACC,aAAa,EAAE,CAAC,GAAGG,KAAK,CAACP,SAAS,EAAET,KAAK,CAACe,KAAK,CAAC,CAAC;OAC3D,MAAM,IAAIrC,IAAI,KAA0B,CAAA,CAAA,2BAAA;QACvCa,GAAG,CAAChC,CAAC,GAAGW,KAAK,CAAC6C,KAAK,CAAC;OACrB,MAAM;QAAE;QACPxB,GAAG,CAAC9C,CAAC,GAAGyB,KAAK,CAAC6C,KAAK,CAAY;QAC/BxB,GAAG,CAAChC,CAAC,GAAG,IAAI;;;IAGhBgC,GAAG,CAAC9C,CAAC,GAAG8D,aAAa;;EAEvBhB,GAAG,CAAChC,CAAC,GAAG4C,QAAQ;EAEhB1E,gBAAiB,CAACsD,IAAI,CAACwB,aAAa,EAAEJ,QAAQ,EAAEK,QAAQ,CAAC;EACzD,OAAOC,SAAS;AAClB,CAAC;AAED,MAAMQ,eAAe,GAAGA,CACtBC,KAAgB,EAChBpC,IAAe,EACfqC,WAAkB,KAChB;EACF,MAAM5B,GAAG,GAAGlC,cAAc;EAC1B,MAAMkD,aAAa,GAAGhB,GAAG,CAAC9C,CAAC;EAC3B,MAAMmE,QAAQ,GAAGM,KAAK,CAACtD,CAAC;EACxB,MAAMO,SAAS,GAAG+C,KAAK,CAACvD,CAAC,CAAClB,CAAC;EAC3B,MAAMyB,KAAK,GAAGgD,KAAK,CAACrD,CAAC;EACrB,MAAMO,SAAS,GAAGU,IAAI,CAACrC,CAAC;EACxB,MAAMwD,OAAO,GAAGnB,IAAI,CAACiB,CAAC,CAACG,EAAE;EACzB,MAAMkB,WAAW,GAAGlD,KAAK,CAAC,CAAC,CAAY;EACvC,MAAMmD,eAAe,GAAGpB,OAAO,CAACrC,CAAC;EAEjC,IAAIuD,WAAW,GAAuB,GAAA,CAAA,0BAAA;IACpCA,WAAW,IAAA,GAAA,CAAA;IACX1F,gBAAiB,CAACsD,IAAI,CAACwB,aAAa,EAAEa,WAAW,EAAE7B,GAAG,CAAChC,CAAC,CAAC;;EAG3DO,yBAAyB,CACvBsD,WAAW,EACXnB,OAAO,CAACxD,CAAC,EACTwD,OAAO,CAACF,CAAC,EACT7B,KAAe,EACfC,SAAS,EACTC,SAAS,EACT,CAAC,EAAE6B,OAAO,CAACvC,CAAC,GAAA,OAAA,CAAqB,wBAAA,CAClC;EAED6B,GAAG,CAAC9C,CAAC,GAAG2E,WAAW;EACnB7B,GAAG,CAAChC,CAAC,GAAG,IAAI;EAEZ,IAAIsD,aAAa,GAAG,CAAC;EACrB,KAAK,IAAIvC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+C,eAAe,CAAC9C,MAAM,EAAED,CAAC,EAAE,EAAE;IAC/C,MAAMwC,WAAW,GAAGO,eAAe,CAAC/C,CAAC,CAAC;IACtC,MAAMI,IAAI,GAAGoC,WAAW,GAAA,CAAA,CAAA;IACxB,MAAMC,KAAK,GAAGD,WAAW,IAAA,CAAA,CAAA;IACzB,IAAIpC,IAAI,KAAwB,CAAA,CAAA,yBAAA;MAC7BkC,QAA6B,CAACC,aAAa,CAAC,GAC3CS,MAAM,CACJJ,KAAK,EACJN,QAA6B,CAACC,aAAa,EAAE,CAAC,EAC/CzC,SAAS,CAAC2C,KAAK,CAAC,EAChBI,WAAW,CACZ;KACJ,MAAM,IAAIzC,IAAI,KAA0B,CAAA,CAAA,2BAAA;MACvCa,GAAG,CAAChC,CAAC,GAAGW,KAAK,CAAC6C,KAAK,CAAC;KACrB,MAAM;MAAE;MACPxB,GAAG,CAAC9C,CAAC,GAAGyB,KAAK,CAAC6C,KAAK,CAAY;MAC/BxB,GAAG,CAAChC,CAAC,GAAG,IAAI;;;EAIhBgC,GAAG,CAAC9C,CAAC,GAAG8D,aAAa;EACrBhB,GAAG,CAAChC,CAAC,GAAG6D,WAAW;AACrB,CAAC;AAED,MAAMG,UAAU,GAAGA,CACjBC,WAAkB,EAClBlB,KAAY,EACZM,QAAgB,EAChBf,KAAW,KACF;EACT,IAAIvB,CAAC,GAAGsC,QAAQ,CAACrC,MAAM;EACvB,MAAMkD,SAAS,GAAGrH,MAAM,CAACkE,CAAC,CAAC;EAC3B,MAAM4C,KAAK,GAAGzD,WAAW,CAAC6C,KAAK,EAAET,KAAK,EAAE4B,SAAS,EAAE,IAAI,EAAED,WAAW,CAAC;EACrE,OAAOlD,CAAC,GAAG,CAAC,EAAE;IACZmD,SAAS,CAAC,EAAEnD,CAAC,CAAC,GAAG0C,KAAK,CAACE,KAAK,EAAEN,QAAQ,CAACtC,CAAC,CAAC,CAAC;;EAE5C,OAAO4C,KAAK;AACd,CAAC;AAED,MAAMQ,WAAW,GAAGA,CAClB9B,WAAkB,EAClBsB,KAAY,EACZpC,IAAY,EACZqC,WAAkB,KACT;EACT,MAAM5B,GAAG,GAAGlC,cAAc;EAC1B,MAAMQ,CAAC,GAAGqD,KAAK,CAACrD,CAAC;EACjB,IAAI,OAAOiB,IAAI,KAAK,QAAQ,EAAE;IAC5B,MAAMF,IAAI,GAAGsC,KAAK,CAACvD,CAAC;IACpB;IACA;IACAuD,KAAK,CAACvD,CAAC,GAAGmB,IAAI;IACd,IAAIF,IAAI,KAAKE,IAAI,EAAE;MAChBjB,CAAU,CAACmB,SAAS,GAAGF,IAAc;;IAExC,IAAIqC,WAAW,GAAuB,GAAA,CAAA,0BAAA;MACpC1F,gBAAiB,CAACsD,IAAI,CAACQ,GAAG,CAAC9C,CAAC,EAAEoB,CAAC,EAAE0B,GAAG,CAAChC,CAAC,CAAC;;IAEzC,OAAO2D,KAAK;;EAEdvF,eAAgB,CAACoD,IAAI,CAACQ,GAAG,CAAC9C,CAAC,EAAEoB,CAAC,CAAC;EAC/B,OAAOmD,KAAK,CAACpB,WAAW,EAAEd,IAAI,CAAE;AAClC,CAAC;AAED,MAAM6C,gBAAgB,GAAGA,CACvBT,KAAiB,EACjBpC,IAAgB,EAChBqC,WAAkB,KAChB;EACF,MAAMS,KAAK,GAAGV,KAAK,CAACtD,CAAC;EACrB,MAAMO,SAAS,GAAG+C,KAAK,CAACvD,CAAC,CAAClB,CAAC;EAC3B,MAAMqD,UAAU,GAAGhB,IAAI,CAACiB,CAAC;EACzB,MAAM3B,SAAS,GAAGU,IAAI,CAACrC,CAAC;EACxB,IACG,CAACyE,KAAK,CAACxD,CAAC,GAAGyD,WAAW,KAAK,EAAA,qBAAA,GAAA,CAAA,wBAAgC,IACzDhD,SAAS,KAAKC,SAAS,KACvB0B,UAAU,CAACM,EAAE,KAAK,KAAK,CAAC,IAAIN,UAAU,CAACM,EAAE,CAACjC,SAAS,EAAEC,SAAS,CAAC,KAAK,IAAI,CAC1E,EACD;IACA8C,KAAK,CAACtD,CAAC,GAAG0D,MAAM,CACdJ,KAAK,EACLU,KAAc,EACdV,KAAK,CAACrD,CAAC,CAACgE,CAAE,CAACzD,SAAS,CAAC,EACrB+C,WAAW,CACZ;EACF,CAAA,MAAM,IAAIS,KAAK,KAAK,IAAI,EAAE;IACzBE,UAAU,CAACF,KAAc,EAAET,WAAW,CAAC;;AAE3C,CAAC;AAED,MAAMY,YAAY,GAAGA,CACnBnC,WAAkB,EAClBsB,KAAY,EACZpC,IAAU,EACVqC,WAAkB,KACF;EAChB,IAAI,CAAC7G,QAAQ,CAACwE,IAAI,CAAC,EAAE;IACnBkD,OAAO,CAACd,KAAK,EAAE,IAAI,CAAC;IACpB,OAAOF,KAAK,CAACpB,WAAW,EAAEd,IAAI,CAAC;;EAEjC,IAAImD,UAAU,GAAGnD,IAAI,CAACP,MAAM;EAC5B,IAAI,CAAC0D,UAAU,GAAGnD,IAAI,CAACP,MAAM,MAAM,CAAC,EAAE;IACpCyD,OAAO,CAACd,KAAK,EAAE,IAAI,CAAC;GACrB,MAAM;IACL,MAAMO,SAAS,GAAGP,KAAK,CAACtD,CAA2B;IACnD,IAAIsE,UAAU,GAAGT,SAAS,CAAClD,MAAM;IACjC,IAAI0D,UAAU,KAAKC,UAAU,EAAE;MAC7B,MAAMC,YAAY,GAAG/H,MAAM,CAAC6H,UAAU,CAAC;MACvCf,KAAK,CAACtD,CAAC,GAAGuE,YAAY;MACtB,OAAOD,UAAU,GAAGD,UAAU,EAAE;QAC9B,MAAMG,MAAM,GAAIX,SAAiC,CAAC,EAAES,UAAU,CAAC;QAC/D,IAAIE,MAAM,KAAK,IAAI,EAAE;UACnBJ,OAAO,CAACI,MAAM,EAAE,IAAI,CAAC;;;MAGzB,OAAOH,UAAU,GAAGC,UAAU,EAAE;QAC9BC,YAAY,CAAC,EAAEF,UAAU,CAAC,GAAGjB,KAAK,CAACE,KAAK,EAAEpC,IAAI,CAACmD,UAAU,CAAC,CAAC;;;IAG/D,OAAOA,UAAU,GAAG,CAAC,EAAE;MACrBR,SAAS,CAAC,EAAEQ,UAAU,CAAC,GAAGX,MAAM,CAC9BJ,KAAK,EACJO,SAAiC,CAACQ,UAAU,CAAC,EAC9CnD,IAAI,CAACmD,UAAU,CAAC,EAChBd,WAAW,CACZ;;;EAGLD,KAAK,CAACxD,CAAC,GAAA,CAAA,CAAA;EACP,OAAOwD,KAAK;AACd,CAAC;AAiBD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsPA,MAAMmB,WAAW,GAAGA,CAClBnB,KAAY,EACZoB,CAAiB,EACjBC,CAAiB,EACjBpB,WAAkB,KACV;EACR,MAAMqB,KAAK,GAAGF,CAAC,CAACG,CAAC;EACjB,MAAMC,KAAK,GAAGH,CAAC,CAACE,CAAC;EACjB,MAAME,OAAO,GAAGJ,CAAC,CAAC5E,CAAC;EACnB,IAAIiF,OAAO,GAAGF,KAAK,CAACnE,MAAM;EAC1B,IAAIsE,OAAO,GAAuBL,KAAK,CAACjE,MAAM;EAC9C,MAAMuE,MAAM,GAAG1I,MAAM,CAACwI,OAAO,CAAC;EAE9B,IAAIA,OAAO,KAAK,CAAC,EAAE;IAAE;IACnB,IAAIC,OAAO,GAAG,CAAC,EAAE;MAAE;MACjBb,OAAO,CAACd,KAAK,EAAE,IAAI,CAAC;;EAEvB,CAAA,MAAM,IAAI2B,OAAO,KAAK,CAAC,EAAE;IAAE;IAC1B,OAAOD,OAAO,GAAG,CAAC,EAAE;MAAE;MACpBE,MAAM,CAAC,EAAEF,OAAO,CAAC,GAAG5B,KAAK,CAACE,KAAK,EAAEyB,OAAO,CAACC,OAAO,CAAC,CAAC;;GAErD,MAAM;IACL,MAAMnB,SAAS,GAAGP,KAAK,CAACtD,CAAwB;IAChD,IAAImF,IAAI,GAAGF,OAAO,GAAG,CAAC;IACtB,IAAIG,IAAI,GAAGJ,OAAO,GAAG,CAAC;IACtB,IAAIK,KAAK,GAAG,CAAC;IACb,IAAIhE,GAAG,GAAGyD,KAAK,CAACM,IAAI,CAAC;IAErB;IACAE,KAAK,EAAE,OAAO,IAAI,EAAE;MAClB;MACA,OAAOV,KAAK,CAACO,IAAI,CAAC,KAAK9D,GAAG,EAAE;QAC1B6D,MAAM,CAACE,IAAI,CAAC,GAAG1B,MAAM,CACnBJ,KAAK,EACLO,SAAS,CAACsB,IAAI,EAAE,CAAC,EACjBJ,OAAO,CAACK,IAAI,CAAC,EACb7B,WAAW,CACZ;QACD,IAAI8B,KAAK,GAAG,EAAED,IAAI,IAAIC,KAAK,GAAGF,IAAI,EAAE;UAClC,MAAMG,KAAK;;QAEbjE,GAAG,GAAGyD,KAAK,CAACM,IAAI,CAAC;;MAGnB;MACA,OAAOR,KAAK,CAACS,KAAK,CAAC,KAAKP,KAAK,CAACO,KAAK,CAAC,IAAI,EAAEA,KAAK,IAAIF,IAAI,IAAIE,KAAK,IAAID,IAAI,EAAE;QACxE;MAAA;MAGF;;IAGF;IACA,IAAIC,KAAK,GAAGF,IAAI,EAAE;MAChB;MACA,OAAOC,IAAI,IAAIC,KAAK,EAAE;QACpBH,MAAM,CAACE,IAAI,CAAC,GAAGhC,KAAK,CAACE,KAAK,EAAEyB,OAAO,CAACK,IAAI,EAAE,CAAC,CAAC;;IAE/C,CAAA,MAAM,IAAIC,KAAK,GAAGD,IAAI,EAAE;MACvB;MACAJ,OAAO,GAAGK,KAAK;MACf,GAAG;QACD,MAAMb,MAAM,GAAGX,SAAS,CAACmB,OAAO,EAAE,CAAC;QACnC,IAAIR,MAAM,KAAK,IAAI,EAAE;UACnBJ,OAAO,CAACI,MAAM,EAAE,IAAI,CAAC;;OAExB,QAAQQ,OAAO,IAAIG,IAAI;KACzB,MAAM;MAAE;MACP,IAAIH,OAAO,GAAGI,IAAI,GAAGC,KAAK,GAAG,CAAC;MAC9B,MAAME,OAAO,GAAG,IAAIzI,WAAW,CAACkI,OAAO,CAAC,CAAC,CAAA;MACzC,MAAMQ,QAAQ,GAAG,IAAI5I,IAAI,EAAe,CAAC,CAAA;MACzC,KAAK,IAAI8D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsE,OAAO,EAAEtE,CAAC,EAAE,EAAE;QAChC;QACA6E,OAAO,CAAC7E,CAAC,CAAC,GAAA,CAAA,CAAA,CAAA;QACV,MAAM+E,CAAC,GAAGJ,KAAK,GAAG3E,CAAC;QACnB8E,QAAQ,CAACrG,GAAG,CAAC2F,KAAK,CAACW,CAAC,CAAC,EAAEA,CAAC,CAAC;;MAG3B;MACA;MACA,IAAIC,YAAY,GAAG,CAAC;MACpB,KAAK,IAAIhF,CAAC,GAAG2E,KAAK,EAAE3E,CAAC,IAAIyE,IAAI,EAAEzE,CAAC,EAAE,EAAE;QAClC,MAAM8D,MAAM,GAAGX,SAAS,CAACnD,CAAC,CAAC;QAC3B,MAAMiF,YAAY,GAAGH,QAAQ,CAACxG,GAAG,CAAC4F,KAAK,CAAClE,CAAC,CAAC,CAAC;QAC3C,IAAIiF,YAAY,KAAK,KAAK,CAAC,EAAE;UAC3BD,YAAY,GAAIA,YAAY,GAAGC,YAAY,GACvCA,YAAY,GACb,UAAA,CAAA;UACHJ,OAAO,CAACI,YAAY,GAAGN,KAAK,CAAC,GAAG3E,CAAC;UACjCwE,MAAM,CAACS,YAAY,CAAC,GAAGnB,MAAM;QAC9B,CAAA,MAAM,IAAIA,MAAM,KAAK,IAAI,EAAE;UAC1BJ,OAAO,CAACI,MAAM,EAAE,IAAI,CAAC;;;MAIzB;MAEA;MACA;MACA,IAAI,EAAEjB,WAAW,GAAsB,GAAA,0BAAA,IAAImC,YAAY,KAAiC,UAAA,CAAA,kCAAA;QACtFE,OAAO,CAACL,OAAO,CAAC;;MAElB,OAAOP,OAAO,EAAE,GAAG,CAAC,EAAE;QACpBI,IAAI,GAAGJ,OAAO,GAAGK,KAAK;QACtB,MAAMQ,IAAI,GAAGd,OAAO,CAACK,IAAI,CAAC;QAC1B,MAAMU,QAAQ,GAAGP,OAAO,CAACP,OAAO,CAAC;QACjCE,MAAM,CAACE,IAAI,CAAC,GAAIU,QAAQ,KAAK,CAAC,CAAC,GAC3B1C,KAAK,CAACE,KAAK,EAAEuC,IAAI,CAAC,GAClBnC,MAAM,CACNJ,KAAK,EACL4B,MAAM,CAACE,IAAI,CAAC,EACZS,IAAI,EACJtC,WAAW,IACTmC,YAAY,oDAAmCI,QAAQ,KAAA,CAAA,CAAA,CACtD,4BAAA,GACC,4BAAA,CAAC,CAAC,CACP;;;IAIP;IACA;IACA,OAAOT,KAAK,GAAG,CAAC,EAAE;MAChBH,MAAM,CAAC,EAAEG,KAAK,CAAC,GAAG3B,MAAM,CACtBJ,KAAK,EACLO,SAAS,CAACwB,KAAK,CAAC,EAChBN,OAAO,CAACM,KAAK,CAAC,EACd9B,WAAW,CACZ;;;EAGLD,KAAK,CAACtD,CAAC,GAAGkF,MAAM;AAClB,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;AAqBA,MAAMU,OAAO,GAAIlB,CAAa,IAAU;EACtC,MAAM/D,MAAM,GAAG+D,CAAC,CAAC/D,MAAM;EACvB,MAAMoF,MAAM,GAAG,IAAIjJ,WAAW,CAAC6D,MAAM,CAAC;EACtC,MAAMqF,KAAK,GAAG,IAAIlJ,WAAW,CAAC6D,MAAM,CAAC;EACrC,IAAIsF,WAAW,GAAG,CAAC;EACnB,IAAIvF,CAAC,GAAG,CAAC;EACT,IAAI+E,CAAS;EACb,IAAIZ,CAAS;EACb,IAAIqB,EAAU;EACd,IAAIC,EAAU;EAEd;EACA,OAAOzB,CAAC,CAAChE,CAAC,CAAC,QAA8BA,+BAAAA,CAAC,EAAE,EAAE,CAAE;EAEhDsF,KAAK,CAAC,CAAC,CAAC,GAAGtF,CAAC,EAAE;EACd,OAAOA,CAAC,GAAGC,MAAM,EAAED,CAAC,EAAE,EAAE;IACtBmE,CAAC,GAAGH,CAAC,CAAChE,CAAC,CAAC;IACR,IAAImE,CAAC,KAA8B,CAAA,CAAA,CAAA,+BAAA;MAAE;MACnCY,CAAC,GAAGO,KAAK,CAACC,WAAW,CAAC;MACtB,IAAIvB,CAAC,CAACe,CAAC,CAAC,GAAGZ,CAAC,EAAE;QACZkB,MAAM,CAACrF,CAAC,CAAC,GAAG+E,CAAC;QACbO,KAAK,CAAC,EAAEC,WAAW,CAAC,GAAGvF,CAAC;OACzB,MAAM;QACLwF,EAAE,GAAG,CAAC;QACNC,EAAE,GAAGF,WAAW;QAEhB,OAAOC,EAAE,GAAGC,EAAE,EAAE;UACdV,CAAC,GAAIS,EAAE,GAAGC,EAAE,IAAK,CAAC;UAClB,IAAIzB,CAAC,CAACsB,KAAK,CAACP,CAAC,CAAC,CAAC,GAAGZ,CAAC,EAAE;YACnBqB,EAAE,GAAGT,CAAC,GAAG,CAAC;WACX,MAAM;YACLU,EAAE,GAAGV,CAAC;;;QAIV,IAAIZ,CAAC,GAAGH,CAAC,CAACsB,KAAK,CAACE,EAAE,CAAC,CAAC,EAAE;UACpB,IAAIA,EAAE,GAAG,CAAC,EAAE;YACVH,MAAM,CAACrF,CAAC,CAAC,GAAGsF,KAAK,CAACE,EAAE,GAAG,CAAC,CAAC;;UAE3BF,KAAK,CAACE,EAAE,CAAC,GAAGxF,CAAC;;;;;EAMrB;EACA+E,CAAC,GAAGO,KAAK,CAACC,WAAW,CAAC;EACtB,OAAOA,WAAW,EAAE,IAAI,CAAC,EAAE;IACzBvB,CAAC,CAACe,CAAC,CAAC,GAAA,CAAA,CAAA,CAAA;IACJA,CAAC,GAAGM,MAAM,CAACN,CAAC,CAAC;;AAEjB,CAAC;AAED;;;AAGO,MAAMW,EAAE,GAAIC,CAAgB,IACjC,MAAK;EACH,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE;IACzB9I,YAAY,CAAC+I,SAAS,GAAGD,CAAC;IAC1BA,CAAC,GAAG5I,oBAAoB,CAACG,UAAW;;EAEtC,OAAOK,aAAa,CAACkD,IAAI,CAACkF,CAAC,EAAE,IAAI,CAAY;AAC/C,CACD;AAYD;;;AAGO,MAAME,GAAG,GAAIF,CAAS,IAC3B,MAAMhJ,GAAG,CAACG,aAAa,CAAC6I,CAAC,CAC1B;AAgCD;;;AAGO,MAAMG,EAAE,GAAGA,CAChBhE,EAAiB,EACjB1C,CAAS,EACTjB,CAAe,EACfmB,CAAgB,EAChBC,CAAgB,EAChBkC,CAAQ,MACgB;EACxBrC,CAAC,EAAA,CAAA,CAAA;EACDwC,EAAE,EAAE;IAAExC,CAAC;IAAEjB,CAAC;IAAEmB,CAAC;IAAEC,CAAC;IAAEkC;EAAG,CAAA;EACrBK;CACD,CAAC;AAEK,MAAMiE,EAAE,GAAGA,CAACtE,CAAqB,EAAEtD,CAAQ,MAAiB;EAAEsD,CAAC;EAAEtD;AAAC,CAAE,CAAC;AAE5E;;;;;;;;AAQO,MAAM6H,SAAS,GAAGA,CACvBpE,EAEwC,EACxCE,EAAkC,MAKhCF,EAAE,GAAG;EAAExC,CAAC,EAAA,CAAA,CAAA;EAAmBwC,EAAE;EAAEE;AAAE,CAAuC,EACvE3D,CAAI,KAAM;EAAEsD,CAAC,EAAEG,EAAE;EAAEzD;AAAC,CAAE,CAAC,CAC3B;AA+CD;;;AAGA,MAAM8H,IAAI,GAAmB;EAAE7G,CAAC,EAAA,CAAA,CAAA;EAAcwC,EAAE,EAAE,IAAI;EAAEE,EAAE,EAAE;AAAI,CAAE;AAElE;;;;;;;;;;AAUO,MAAMoE,IAAI,GAAGA,CAClBC,OAAY,EACZC,MAAsC,EACtCC,MAA0B,MACf;EACX5E,CAAC,EAAEwE,IAAI;EACP9H,CAAC,EAAE;IACDgG,CAAC,EAAEgC,OAAO,CAACG,GAAG,CAACF,MAAM,CAAC;IACtB/G,CAAC,EAAE8G,OAAO,CAACG,GAAG,CAACD,MAAM;;CAExB,CAAC;AAEF;;;;;;AAMO,MAAM7C,UAAU,GAAGA,CAACZ,KAAY,EAAEC,WAAmB,KAAU;EACpE,MAAM5B,GAAG,GAAGlC,cAAc;EAC1B,MAAMuD,QAAQ,GAAGM,KAAK,CAACtD,CAAC;EACxB,MAAM0C,KAAK,GAAGY,KAAK,CAACxD,CAAC;EACrB,IAAI4C,KAAK,GAAmB,CAAA,CAAA,sBAAA;IAC1B,MAAMc,WAAW,GAAGF,KAAK,CAACrD,CAAC,CAAC,CAAC,CAAC;IAC9B,IAAIsD,WAAW,GAAuB,GAAA,CAAA,0BAAA;MACpCA,WAAW,IAAA,GAAA,CAAA;MACX1F,gBAAgB,CAACsD,IAAI,CAACQ,GAAG,CAAC9C,CAAC,EAAE2E,WAAW,EAAE7B,GAAG,CAAChC,CAAC,CAAC;;IAElD,IAAI+C,KAAK,GAAuB,GAAA,CAAA,0BAAA;MAC9Bf,GAAG,CAAC9C,CAAC,GAAG2E,WAAW;MACnB7B,GAAG,CAAChC,CAAC,GAAG,IAAI;MACZ,MAAMsH,gBAAgB,GAAGtF,GAAG,CAAC9C,CAAC;MAC9B,MAAMyB,KAAK,GAAIgD,KAAmB,CAACrD,CAAC;MACpC,MAAM8C,YAAY,GAAIO,KAAmB,CAACvD,CAAC,CAACoC,CAAC,CAACG,EAAE,CAACtC,CAAC;MAClD,IAAIiD,aAAa,GAAG,CAAC;MACrB,KAAK,IAAIvC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqC,YAAY,CAACpC,MAAM,EAAED,CAAC,EAAE,EAAE;QAC5C,MAAMG,EAAE,GAAGkC,YAAY,CAACrC,CAAC,CAAC;QAC1B,MAAMI,IAAI,GAAGD,EAAE,GAAA,CAAA,CAAA;QACf,MAAMsC,KAAK,GAAGtC,EAAE,IAAA,CAAA,CAAA;QAChB,IAAIC,IAAI,KAAwB,CAAA,CAAA,yBAAA;UAC9B,MAAM0D,MAAM,GAAIxB,QAA6B,CAACC,aAAa,EAAE,CAAC;UAC9D,IAAIuB,MAAM,KAAK,IAAI,EAAE;YACnBN,UAAU,CAACM,MAAM,EAAEjB,WAAW,CAAC;;SAElC,MAAM,IAAIzC,IAAI,KAA0B,CAAA,CAAA,2BAAA;UACvCa,GAAG,CAAChC,CAAC,GAAIW,KAAgB,CAAC6C,KAAK,CAAC;SACjC,MAAM;UAAE;UACPxB,GAAG,CAAC9C,CAAC,GAAGyB,KAAK,CAAC6C,KAAK,CAAY;UAC/BxB,GAAG,CAAChC,CAAC,GAAG,IAAI;;;MAGhBgC,GAAG,CAAC9C,CAAC,GAAGoI,gBAAgB;;IAE1BtF,GAAG,CAAChC,CAAC,GAAG6D,WAAW;GACpB,MAAM,IAAId,KAAK,GAAe,EAAA,CAAA,kBAAA;IAC7B,IAAIa,WAAW,GAAuB,GAAA,CAAA,0BAAA;MACpC1F,gBAAgB,CAACsD,IAAI,CAACQ,GAAG,CAAC9C,CAAC,EAAEyE,KAAK,CAACrD,CAAC,EAAE0B,GAAG,CAAChC,CAAC,CAAC;;IAE9CgC,GAAG,CAAChC,CAAC,GAAG2D,KAAK,CAACrD,CAAC;GAChB,MAAM,IAAIyC,KAAK,GAAoB,CAAA,CAAA,uBAAA;IAClC,IAAI,CAACA,KAAK,GAAGa,WAAW,KAAK,mDAAgC,EAAE;MAC7DD,KAAK,CAACtD,CAAC,GAAG0D,MAAM,CACdJ,KAAK,EACLN,QAAiB,EAChBM,KAAmB,CAACrD,CAAC,CAACgE,CAAE,CAAEX,KAAmB,CAACvD,CAAC,CAAClB,CAAC,CAAC,EACnD0E,WAAW,CACZ;IACF,CAAA,MAAM,IAAIP,QAAQ,KAAK,IAAI,EAAE;MAC5BkB,UAAU,CAAClB,QAAiB,EAAEO,WAAW,CAAC;;GAE7C,MAAM;IAAE;IACP,IAAI7C,CAAC,GAAIsC,QAAgC,CAACrC,MAAM;IAChD,OAAO,EAAED,CAAC,IAAI,CAAC,EAAE;MACf,MAAM8D,MAAM,GAAIxB,QAAgC,CAACtC,CAAC,CAAC;MACnD,IAAI8D,MAAM,KAAK,IAAI,EAAE;QACnBN,UAAU,CAACM,MAAM,EAAEjB,WAAW,CAAC;;;;EAIrCD,KAAK,CAACxD,CAAC,IAAA,EAAA,CAAA;AACT,CAAC;AAED;;;;;;;;;AASO,MAAM4D,MAAM,GAAGA,CACpB1B,WAAkB,EAClBsB,KAAmB,EACnBpC,IAAU,EACVqC,WAAmB,KACH;EAChB,IAAID,KAAK,KAAK,IAAI,EAAE;IAClB,OAAOF,KAAK,CAACpB,WAAW,EAAEd,IAAI,CAAC;;EAEjC,IAAIA,IAAI,KAAK,IAAI,EAAE;IACjBkD,OAAO,CAACd,KAAK,EAAE,IAAI,CAAC;IACpB,OAAO,IAAI;;EAGb,MAAMZ,KAAK,GAAGY,KAAK,CAACxD,CAAC,GAAA,EAAA,CAAA;EAErB,IAAI4C,KAAK,KAAiB,EAAA,CAAA,kBAAA;IACxB,OAAOoB,WAAW,CAAC9B,WAAW,EAAEsB,KAAc,EAAEpC,IAAc,EAAEqC,WAAW,CAAC;;EAE9E,MAAMvC,IAAI,GAAGsC,KAAK,CAACvD,CAAC;EACpBuD,KAAK,CAACvD,CAAC,GAAGmB,IAAI;EACd,IAAIF,IAAI,KAAKE,IAAI,EAAE;IACjBgD,UAAU,CAACZ,KAAK,EAAEC,WAAW,CAAC;IAC9B,OAAOD,KAAK;;EAEd,IAAIZ,KAAK,KAAkB,CAAA,CAAA,mBAAA;IACzB,OAAOyB,YAAY,CAACnC,WAAW,EAAEsB,KAAK,EAAEpC,IAAI,EAAEqC,WAAW,CAAC;;EAG5D;EACA;EACA;EACA,IAAKvC,IAAc,CAACmB,CAAC,KAAMjB,IAAc,CAACiB,CAAC,EAAE;IAC3CiC,OAAO,CAACd,KAAK,EAAE,IAAI,CAAC;IACpB,OAAOF,KAAK,CAACpB,WAAW,EAAEd,IAAI,CAAC;;EAGjC,IAAIwB,KAAK,KAAsB,CAAA,CAAA,uBAAA;IAC7BqB,gBAAgB,CAACT,KAAkB,EAAEpC,IAAkB,EAAEqC,WAAW,CAAC;GACtE,MAAM,IAAIb,KAAK,KAAqB,CAAA,CAAA,sBAAA;IACnCW,eAAe,CAACC,KAAkB,EAAEpC,IAAiB,EAAEqC,WAAW,CAAC;GACpE,MAAM;IACLkB,WAAW,CAACnB,KAAK,EAAGtC,IAAc,CAACnC,CAAC,EAAGqC,IAAc,CAACrC,CAAC,EAAE0E,WAAW,CAAC;;EAGvED,KAAK,CAACxD,CAAC,IAAA,EAAA,CAAA;EACP,OAAOwD,KAAK;AACd,CAAC;AAED;;;;;;;AAOO,MAAMF,KAAK,GAAGA,CAACpB,WAAkB,EAAEjC,CAAO,KAAkB;EACjE,IAAIA,CAAC,KAAK,IAAI,EAAE;IACd,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE;MACzB,IAAIrD,QAAQ,CAACqD,CAAC,CAAC,EAAE;QACf,OAAO4D,UAAU,CAAC3B,WAAW,uBAAejC,CAAC,EAAEA,CAAC,CAAC;OAClD,MAAM;QACL,MAAMmC,UAAU,GAAGnC,CAAC,CAACoC,CAAC;QACtB,MAAMrB,IAAI,GAAGoB,UAAU,CAACpC,CAAC,IAAI,CAAiC,CAAA,uBAAA,CAAA,CAAA,sBAAA;QAC9D,IAAIgB,IAAI,KAAqB,CAAA,CAAA,sBAAA;UAC3B,OAAOiB,cAAc,CAACC,WAAW,EAAEjC,CAAc,CAAC;SACnD,MAAM,IAAIe,IAAI,KAAsB,CAAA,CAAA,uBAAA;UACnC,MAAMoG,cAAc,GAAmB;YAAEjD,CAAC,EAAE,IAAI;YAAEkD,CAAC,EAAE;WAAM;UAC3D,MAAM7D,KAAK,GAAczD,WAAW,CAElCE,CAAAA,CAAAA,uBAAAA,CAAe,EACf,IAAI,EACJmH,cAAc,EACdlF,WAAW,CACZ;UACD,MAAMoF,QAAQ,GAAIlF,UAAkC,CAACI,EAAE,CAACgB,KAAK,CAAC;UAC9D4D,cAAc,CAACjD,CAAC,GAAGmD,QAAQ;UAC3B9D,KAAK,CAACtD,CAAC,GAAGoD,KAAK,CAACE,KAAK,EAAE8D,QAAQ,CAAErH,CAAgB,CAAClB,CAAC,CAAC,CAAC;UACrD,OAAOyE,KAAK;;QAEd;QACA,OAAOK,UAAU,CAAC3B,WAAW,EAAejC,CAAAA,CAAAA,kBAAAA,CAAW,CAAClB,CAAC,CAACkB,CAAC,EAAEA,CAAC,CAAC;;KAElE,MAAM;MACL,MAAM4B,GAAG,GAAGlC,cAAc;MAC1B,MAAM4H,CAAC,GAAGhK,GAAG,CAACiK,cAAc,CAACvH,CAAW,CAAC;MACzClC,gBAAgB,CAACsD,IAAI,CAACQ,GAAG,CAAC9C,CAAC,EAAEwI,CAAC,EAAE1F,GAAG,CAAChC,CAAC,CAAC;MACtCgC,GAAG,CAAChC,CAAC,GAAG0H,CAAC;MACT,OAAOxH,WAAW,IAAaE,kBAAAA,CAAC,EAAE,IAAI,EAAEsH,CAAC,EAAErF,WAAW,CAAC;;;EAG3D,OAAO,IAAI;AACb,CAAC;AAED;;;;;;AAMO,MAAMoC,OAAO,GAAGA,CAACd,KAAY,EAAEiE,MAAe,KAAU;EAC7D,MAAM7E,KAAK,GAAGY,KAAK,CAACxD,CAAC;EAErB,IAAIyH,MAAM,KAAK,IAAI,IAAK7E,KAAK,IAAI,6CAA6B,EAAE;IAC9D6E,MAAM,GAAG,KAAK;IACdxJ,eAAe,CAACoD,IAAI,CAClB1B,cAAc,CAACZ,CAAC,EACf6D,KAAK,GAAA,CAAA,wBACDY,KAAmB,CAACrD,CAAC,CAAC,CAAC,CAAC,GACxBqD,KAAe,CAACrD,CAAC,CACvB;;EAEH,MAAM4D,SAAS,GAAGP,KAAK,CAACtD,CAAC;EACzB,IAAI6D,SAAS,KAAK,IAAI,EAAE;IACtB,IAAInH,QAAQ,CAACmH,SAAS,CAAC,EAAE;MACvB,KAAK,IAAInD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmD,SAAS,CAAClD,MAAM,EAAED,CAAC,EAAE,EAAE;QACzC,MAAM8D,MAAM,GAAGX,SAAS,CAACnD,CAAC,CAAC;QAC3B,IAAI8D,MAAM,KAAK,IAAI,EAAE;UACnBJ,OAAO,CAACI,MAAM,EAAE+C,MAAM,CAAC;;;KAG5B,MAAM;MACLnD,OAAO,CAACP,SAAkB,EAAE0D,MAAM,CAAC;;;EAGvC,IAAI7E,KAAK,GAAoB,CAAA,CAAA,uBAAA;IAC3B,MAAM8E,YAAY,GAAIlE,KAAoB,CAACrD,CAAC,CAACkH,CAAC;IAC9C,IAAIK,YAAY,KAAK,IAAI,EAAE;MACzB,IAAI,OAAOA,YAAY,KAAK,UAAU,EAAE;QACtCA,YAAY,EAAE;OACf,MAAM;QACL,KAAK,IAAI9G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8G,YAAY,CAAC7G,MAAM,EAAED,CAAC,EAAE,EAAE;UAC5C8G,YAAY,CAAC9G,CAAC,CAAC,EAAE;;;;;AAK3B,CAAC;AC/hDD,MAAM+G,eAAe,GAAGC,cAAc;AAEtC,MAAMC,eAAe,GAAmB;EACtC;EACA7H,CAAC,EAAA,EAAA,CAAA;;EACD;EACAwC,EAAE,EAAGsF,IAAW,IAAI;IAClBH,eAAe,CAAC,MAAK;MACnB;MACA,MAAMI,OAAO,GAAGD,IAAI,CAAC7H,CAAC,CAAClB,CAAC;MACxB;MACAY,cAAc,CAACZ,CAAC,GAAGgJ,OAAO,CAAChJ,CAAC;MAC5BY,cAAc,CAACE,CAAC,GAAGkI,OAAO,CAAClI,CAAC;MAC5B;MACAuE,UAAU,CAAC0D,IAAI,CAAC5H,CAAU,EAAE,CAAC,CAAC;MAC9B;MACA4H,IAAI,CAAC9H,CAAC,GAAA,EAAA,CAAA;IACR,CAAC,CAAC;EACH,CAAA;;EACD;EACA;EACA;EACA;EACA0C,EAAE,EAAE;AACL,CAAA;AAED;;;;;;;AAOO,MAAMsF,UAAU,GAAGA,CAACjJ,CAAU,EAAEc,CAAA,GAAiB,IAAI,KAC1DE,WAAW,CAAA,EAAA,CAAA;AAGT;AACA;EACE;EACAsC,CAAC,EAAEwF,eAAe;EAClB;EACA;EACA9I,CAAC,EAAE;IACD;IACAA,CAAC;IACD;IACAc;;AAEH,CAAA;AACD;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI,CAEP;AAED;;;;;;;AAOO,MAAMoI,UAAU,GAAGA,CACxBH,IAAiB,EACjB7H,CAAO,EACPiI,WAAA,GAAuB,KAAK,KACpB;EACR;EACA,MAAMH,OAAO,GAAGD,IAAI,CAAC7H,CAAC,CAAClB,CAAC;EACxB;EACAY,cAAc,CAACZ,CAAC,GAAGgJ,OAAO,CAAChJ,CAAC;EAC5BY,cAAc,CAACE,CAAC,GAAGkI,OAAO,CAAClI,CAAC;EAC5BiI,IAAI,CAAC5H,CAAC,GAAG0D,MAAM;EACb;EACAkE,IAAI;EACJ;EACAA,IAAI,CAAC5H,CAAU;EACf;EACAD,CAAC;EACD;EACAiI,WAAW,KAAK,IAAI,GACjB,GAAA,CACC,0BAAA,CAAC,CACN;EACD;EACAJ,IAAI,CAAC9H,CAAC,GAAA,EAAA,CAAA;AACR,CAAC;;AFhGD,MAAMmI,WAAW,GAAGA,CAACC,CAAM,EAAElC,KAAa,KAAKA,KAAK;AACpD,MAAMmC,UAAU,GAAIC,GAAmB,IAAKA,GAAG,CAACC,EAAE;AAClD,MAAMC,MAAM,GAAIC,IAAkB,IAAKA,IAAI,CAACF,EAAE;AAC9C,MAAMG,UAAU,GAAI3C,IAAmB,IAAKA,IAAI,CAACwC,EAAE;AAAC,MAAAI,KAAA,GAAAjC,0BAAAA,EAAA,CAAAJ,EAAA,CAAA,+BAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,EAAA,IAAA,CAAA,EAAAsC,GAAA,EAAAA,GAAA,EAAAC,SAAA,CAAA;AAEpD,MAAMC,SAAS,GAAGlC,SAAS,CAAC,MAAK;EAC/B,MAAMmC,KAAK,GAAGA,CAAAA;IAAQC,OAAO,CAACC,GAAG,CAAC,OAAO,CAAC;GAAG;EAC7C,OAAQ1C,CAAS,IAAAI,EAAA,CAAAgC,KAAA,EAEJI,CAAAA,KAAK,EACXxC,CAAC,CACP,CAAA;AACH,CAAC,CAAC;AAAC,MAAA2C,MAAA,GAAA,0BAAAxC,EAAA,CAAAD,GAAA,CAAA,IAAA,CAAA,EAAA,IAAA,EAAA,CAAA,CAAA,EAAA,IAAA,CAAA,EAAA,CAAA,EAAA,EAAA,CAAA,CAAA,EAAAmC,GAAA,EAAAC,SAAA,CAAA;AAEH,MAAMM,QAAQ,GAAGvC,SAAS,CAAC,MAAOpG,KAAqB,IAAI;EACzD,IAAI+H,EAAE,GAAG/H,KAAK,CAAC+H,EAAE;EAEjB,OAAA5B,EAAA,CAAAuC,MAAA,EAAA,CACM1I,KAAK,CAAC4I,MAAM,GAAG,iBAAiB,GAAG,UAAU,EACpCb,EAAE,EACXO,SAAS,CAAC,GAAG,GAAGP,EAAE,CAAC,EACnBzB,IAAI,CAACtG,KAAK,CAAC8B,KAAK,EAAE6F,WAAW,EAAEW,SAAS,CAAC,CAAA,CAAA;AAEjD,CAAC,CAAC;AAAC,MAAAO,MAAA,GAAA3C,0BAAAA,EAAA,CAAAJ,EAAA,CAAA,gDAAA,CAAA,EAAA,IAAA,EAAAsC,GAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAAC,SAAA,CAAA;AAEH,MAAMS,KAAK,GAAG1C,SAAS,CAAC,MAAOpG,KAAiB,IAAAmG,EAAA,CAAA0C,MAAA,EAAA,CAItCvC,IAAI,CAACtG,KAAK,CAAC+I,KAAK,EAAElB,UAAU,EAAEc,QAAQ,CAAC,CAAA,CAEhD,CAAC;AAAC,MAAAK,MAAA,GAAA,0BAAA9C,EAAA,CAAAJ,EAAA,CAAA,+BAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,EAAA,IAAA,EAAA,KAAA,CAAA,EAAAsC,GAAA,EAAAA,GAAA,EAAAC,SAAA,CAAA;AAEH,MAAMY,OAAO,GAAG7C,SAAS,CAAC,MAAOpG,KAAmB,IAAI;EACtD,MAAMkJ,IAAI,GAAGlJ,KAAK,CAACkJ,IAAI,GAAG,EAAE;EAC5B,OAAA/C,EAAA,CAAA6C,MAAA,EAAA,CAEehJ,KAAK,CAAC+H,EAAE,EACL,aAAa,IAAI,GAAG,GAAImB,IAAI,GAAG,EAAG,CAAC,GAAG,GAAG,EACtCA,IAAI,GAAG,IAAI,CAAA,CAAA;AAElC,CAAC,CAAC;AAAC,MAAAC,MAAA,6BAAAjD,EAAA,CAAAJ,EAAA,CAAA,4BAAA,CAAA,EAAA,IAAA,EAAAsC,GAAA,EAAAgB,IAAA,EAAAhB,GAAA,EAAAC,SAAA,CAAA;AAEH,MAAMgB,IAAI,GAAGjD,SAAS,CAAC,MAAOpG,KAAgB,IAAAmG,EAAA,CAAAgD,MAAA,EAAA,CAC7B7C,IAAI,CAACtG,KAAK,CAAC+I,KAAK,EAAEf,MAAM,EAAEiB,OAAO,CAAC,CAAA,CAClD,CAAC;AAAC,MAAAK,MAAA,6BAAApD,EAAA,CAAAJ,EAAA,CAAA,8BAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAAsC,GAAA,EAAAA,GAAA,EAAAC,SAAA,CAAA;AAEH,MAAMkB,QAAQ,GAAGnD,SAAS,CAAC,MAAOpG,KAAoB,IAAAmG,EAAA,CAAAmD,MAAA,EACjCtJ,CAAAA,KAAK,CAAC+H,EAAE,EAC5B,CAAC;AAEF,MAAMyB,OAAO,GAAIxJ,KAAoB,IACnCA,KAAK,CAACyJ,SAAS,KAAK,IAAI,GACtBC,QAAQ,CAAC1J,KAAK,CAAC,GACbuJ,QAAQ,CAACvJ,KAAK,CACnB;AAAC,MAAA2J,MAAA,6BAAAzD,EAAA,CAAAJ,EAAA,CAAA,8BAAA,CAAA,EAAA,IAAA,EAAAsC,GAAA,EAAAgB,IAAA,EAAAhB,GAAA,EAAAC,SAAA,CAAA;AAEF,MAAMqB,QAAQ,GAAGtD,SAAS,CAAC,MAAOpG,KAAoB,IAAAmG,EAAA,CAAAwD,MAAA,EAAA,CAClCrD,IAAI,CAACtG,KAAK,CAAC0C,QAAQ,EAAEwF,UAAU,EAAEsB,OAAO,CAAC,CAAA,CAC5D,CAAC;AAAC,MAAAI,MAAA,6BAAA1D,EAAA,CAAAJ,EAAA,CAAA,4BAAA,CAAA,EAAA,IAAA,EAAAsC,GAAA,EAAAgB,IAAA,EAAAhB,GAAA,EAAAC,SAAA,CAAA;AAEH,MAAMwB,IAAI,GAAGzD,SAAS,CAAC,MAAOkB,IAAmB,IAAAnB,EAAA,CAAAyD,MAAA,GAChCF,QAAQ,CAACpC,IAAI,CAAC,EAC9B,CAAC;AAAC,MAAAwC,MAAA,6BAAA5D,EAAA,CAAAJ,EAAA,CAAA,4BAAA,CAAA,EAAA,IAAA,EAAAsC,GAAA,EAAAgB,IAAA,EAAAhB,GAAA,EAAAC,SAAA,CAAA;AAEH,SAAS0B,IAAIA,CAAC/J,KAAe,EAAA;EAC3B,IAAIgK,QAAQ,GAAGhK,KAAK,CAACgK,QAAQ;EAC7B,OAAA7D,EAAA,CAAA2D,MAAA,EAEME,CAAAA,QAAQ,KAAK,OAAO,GACpBlB,KAAK,CAAC9I,KAAK,CAACiK,KAAK,CAAC,GAClBD,QAAQ,KAAK,MAAM,GACjBX,IAAI,CAACrJ,KAAK,CAACkK,IAAI,CAAC,GAChBF,QAAQ,KAAK,MAAM,GACjBH,IAAI,CAAC7J,KAAK,CAACmK,IAAI,CAAC7C,IAAI,CAAC,GACrB,IAAI,CAAA,CAAA;AAEhB;AAEA8C,OAAO,CAACC,IAAI,CAAC,KAAK,EAAE,OAAO,CAAC;AAE5BrN,QAAQ,CAACkB,gBAAgB,CAAC,kBAAkB,EAAE,MAAK;EACjD,IAAIuL,SAAS,GAAGzM,QAAQ,CAACsN,cAAc,CAAC,KAAK,CAAE;EAC/C,IAAIhD,IAAI,GAAGE,UAAU,CAACiC,SAAS,EAAE,IAAI,CAAC;EACtChC,UAAU,CAACH,IAAI,EAAE,IAAI,CAAC;EAEtB8C,OAAO,CAACG,GAAG,CACR3J,IAAI;IAAO6G,UAAU,CAACH,IAAI,EAAEyC,IAAI,CAACnJ,IAAI,CAAC,CAAC;EAAG,CAAA,EAC1C4J,OAAO,IAAI;IAAGf,SAAS,CAACzD,SAAS,GAAW,QAAAyE,IAAI,CAACC,SAAS,CAACF,OAAO,EAAE,KAAK,CAAC,EAAE,CAAC,CAAS,QAAA;EAAE,CAAC,CAC3F;AACH,CAAC,CAAC"}