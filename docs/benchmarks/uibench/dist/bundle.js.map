{"version":3,"file":"bundle.js","sources":["../src/index.ts","../../../../ivi/packages/ivi/dist/index.js","../../../../ivi/packages/ivi/dist/root.js"],"sourcesContent":[null,"const _Object = Object;\nconst _Array = Array;\nconst _isArray = _Array.isArray;\nconst _Map = Map;\nconst _Int32Array = Int32Array;\nconst nodeProto = Node.prototype;\nconst elementProto = Element.prototype;\nconst doc = document;\nconst HTM_TEMPLATE = /**@__PURE__*/ doc.createElement(\"template\");\nconst HTM_TEMPLATE_CONTENT = HTM_TEMPLATE.content;\nconst _SVG_TEMPLATE = /**@__PURE__*/ doc.createElement(\"template\");\nconst SVG_TEMPLATE = /**@__PURE__*/ doc.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n/**@__PURE__*/ _SVG_TEMPLATE.appendChild(SVG_TEMPLATE);\nconst SVG_TEMPLATE_CONTENT = _SVG_TEMPLATE.content.firstChild;\n/** `Node.prototype.insertBefore` */\nconst nodeInsertBefore = nodeProto.insertBefore;\n/** `Node.prototype.removeChild`. */\nconst nodeRemoveChild = nodeProto.removeChild;\n/** `Node.prototype.cloneNode`. */\nconst nodeCloneNode = nodeProto.cloneNode;\n/** `Element.prototype.setAttribute` */\nconst elementSetAttribute = elementProto.setAttribute;\n/** `Element.prototype.removeAttribute` */\nconst elementRemoveAttribute = elementProto.removeAttribute;\n/** `EventTarget.prototype.addEventListener` */\nconst elementAddEventListener = elementProto.addEventListener;\n/** `EventTarget.prototype.removeEventListener` */\nconst elementRemoveEventListener = elementProto.removeEventListener;\n/** `Object.getOwnPropertyDescriptor(o, p)` */\nconst getDescriptor = (o, p) => _Object.getOwnPropertyDescriptor(o, p);\n/** `Node.prototype.getFirstChild` */\nconst nodeGetFirstChild = /*@__PURE__*/ getDescriptor(nodeProto, \"firstChild\").get;\n/** `Node.prototype.getNextSibling` */\nconst nodeGetNextSibling = /*@__PURE__*/ getDescriptor(nodeProto, \"nextSibling\").get;\n/** `Node.prototype.setTextContent` */\nconst nodeSetTextContent = /*@__PURE__*/ getDescriptor(nodeProto, \"textContent\").set;\n/** `Element.prototype.className` */\nconst elementSetClassName = /*@__PURE__*/ getDescriptor(elementProto, \"className\").set;\n/** `HTMLElement.prototype.style`. */\nconst htmlElementGetStyle = /*@__PURE__*/ getDescriptor(HTMLElement.prototype, \"style\").get;\n/** `SVGElement.prototype.style` */\nconst svgElementGetStyle = /*@__PURE__*/ getDescriptor(SVGElement.prototype, \"style\").get;\nexport const RENDER_CONTEXT = _Object.seal({\n    p: null,\n    n: null,\n    si: 0,\n});\n/**\n * Creates a Stateful Node instance.\n *\n * @param v VNode.\n * @returns {@link SNode} instance.\n */\nexport const createSNode = (f, v, c, s, p) => ({ f, v, c, s, p });\nconst _unmount = (sNode) => {\n    var c, i;\n    if (sNode !== null) {\n        if (_isArray(sNode)) {\n            for (i = 0; i < sNode.length; i++) {\n                if ((c = sNode[i]) !== null) {\n                    unmount(c, true);\n                }\n            }\n        }\n        else {\n            unmount(sNode, true);\n        }\n    }\n};\nconst _updateTemplateProperties = (currentElement, opCodes, strings, state, prevProps, nextProps, svg) => {\n    var style;\n    var key;\n    var type;\n    var propsIndex;\n    var dataIndex;\n    var op;\n    var prev;\n    var next;\n    var i = 0;\n    for (; i < opCodes.length; i++) {\n        op = opCodes[i];\n        type = op & 7 /* PropOpCode.TypeMask */;\n        dataIndex = (op >> 3 /* PropOpCode.DataShift */) & 1023 /* PropOpCode.Mask10 */;\n        if (type === 0 /* PropOpCode.SetNode */) {\n            currentElement = state[dataIndex];\n            style = void 0;\n        }\n        else {\n            propsIndex = op >> 13 /* PropOpCode.InputShift */;\n            if (prevProps !== null) {\n                prev = prevProps[propsIndex];\n            }\n            next = nextProps[propsIndex];\n            if (prev !== next || type === 4 /* PropOpCode.DiffDOMProperty */) {\n                if (type === 1 /* PropOpCode.Common */) {\n                    if (dataIndex === 0 /* CommonPropType.ClassName */) {\n                        elementSetClassName.call(currentElement, next);\n                    }\n                    else { // CommonPropType.TextContent\n                        if (prev === void 0) {\n                            nodeSetTextContent.call(currentElement, next);\n                        }\n                        else {\n                            nodeGetFirstChild.call(currentElement).nodeValue = next;\n                        }\n                    }\n                }\n                else if (type === 7 /* PropOpCode.Directive */) {\n                    next(currentElement);\n                }\n                else {\n                    key = strings[dataIndex];\n                    if (type === 2 /* PropOpCode.Attribute */) {\n                        if (next !== void 0) {\n                            elementSetAttribute.call(currentElement, key, next);\n                        }\n                        else {\n                            elementRemoveAttribute.call(currentElement, key);\n                        }\n                    }\n                    else if (type === 3 /* PropOpCode.Property */) {\n                        currentElement[key] = next;\n                    }\n                    else if (type === 4 /* PropOpCode.DiffDOMProperty */) {\n                        if (currentElement[key] !== next) {\n                            currentElement[key] = next;\n                        }\n                    }\n                    else if (type === 5 /* PropOpCode.Style */) {\n                        if (style === void 0) {\n                            style = (svg === false)\n                                ? htmlElementGetStyle.call(currentElement)\n                                : svgElementGetStyle.call(currentElement);\n                        }\n                        style.setProperty(key, next);\n                    }\n                    else { // PropOpCode.Event\n                        if (prev !== void 0) {\n                            elementRemoveEventListener.call(currentElement, key, prev);\n                        }\n                        elementAddEventListener.call(currentElement, key, next);\n                    }\n                }\n            }\n        }\n    }\n};\nconst _assignTemplateSlots = (currentNode, opCodes, offset, endOffset, state) => {\n    var tmp;\n    var op;\n    var ctx = RENDER_CONTEXT;\n    while (offset < endOffset) {\n        op = opCodes[offset++];\n        if (op & 4 /* StateOpCode.Save */) {\n            state[++ctx.si] = currentNode;\n        }\n        if (op & 2 /* StateOpCode.EnterOrRemove */) {\n            if (tmp = op >> 3 /* StateOpCode.OffsetShift */) { // Enter\n                _assignTemplateSlots(nodeGetFirstChild.call(currentNode), opCodes, offset, offset += tmp, state);\n            }\n            else { // Remove\n                tmp = currentNode;\n                state[++ctx.si] = currentNode = nodeGetNextSibling.call(currentNode);\n                tmp.remove();\n            }\n        }\n        else { // Next\n            currentNode = nodeGetNextSibling.call(currentNode);\n        }\n    }\n};\nconst _mountTemplate = (parentSNode, vNode) => {\n    var stateNode;\n    var childIndex;\n    var value;\n    var j;\n    var type;\n    var children = null;\n    var ctx = RENDER_CONTEXT;\n    var parentElement = ctx.p;\n    var nextNode = ctx.n;\n    var d = vNode.d;\n    var props = vNode.p;\n    var tpl = d.p1;\n    var rootNode = d.p2();\n    var opCodes = tpl.s;\n    var i = tpl.f;\n    var state = _Array(i & 1023 /* TemplateFlags.Mask10 */);\n    state[0] = rootNode;\n    ctx.n = null;\n    if (opCodes.length > 0) {\n        ctx.si = 0;\n        _assignTemplateSlots(nodeGetFirstChild.call(rootNode), opCodes, 0, opCodes.length, state);\n    }\n    _updateTemplateProperties(rootNode, tpl.p, tpl.d, state, null, props, !!(tpl.f & 1048576 /* TemplateFlags.Svg */));\n    childIndex = 0;\n    j = i >> 10;\n    stateNode = createSNode(1 /* Flags.Template */, vNode, children, state, parentSNode);\n    if (j > 0) {\n        ctx.p = rootNode;\n        stateNode.c = children = _Array(j);\n        opCodes = tpl.c;\n        for (i = 0; i < opCodes.length; i++) {\n            j = opCodes[i];\n            type = j & 3 /* ChildOpCode.Type */;\n            value = j >> 2 /* ChildOpCode.ValueShift */;\n            if (type === 0 /* ChildOpCode.Child */) {\n                children[childIndex++] = mount(stateNode, props[value]);\n            }\n            else if (type === 1 /* ChildOpCode.SetNext */) {\n                ctx.n = state[value];\n            }\n            else { // ChildOpCode.SetParent\n                ctx.p = state[value];\n                ctx.n = null;\n            }\n        }\n    }\n    nodeInsertBefore.call(parentElement, rootNode, nextNode);\n    ctx.p = parentElement;\n    ctx.n = rootNode;\n    return stateNode;\n};\nconst _updateTemplate = (sNode, next, updateFlags) => {\n    var v;\n    var c;\n    var k;\n    var j;\n    var i;\n    var ctx = RENDER_CONTEXT;\n    var parentElement = ctx.p;\n    var children = sNode.c;\n    var prevProps = sNode.v.p;\n    var state = sNode.s;\n    var nextProps = next.p;\n    var d = next.d;\n    var tpl = d.p1;\n    var rootNode = state[0];\n    var opCodes = tpl.c;\n    if (updateFlags & 512 /* Flags.DisplaceNode */) {\n        updateFlags ^= 512 /* Flags.DisplaceNode */;\n        nodeInsertBefore.call(parentElement, rootNode, ctx.n);\n    }\n    _updateTemplateProperties(rootNode, tpl.p, tpl.d, state, prevProps, nextProps, !!(tpl.f & 1048576 /* TemplateFlags.Svg */));\n    ctx.p = rootNode;\n    ctx.n = null;\n    j = 0;\n    for (i = 0; i < opCodes.length; i++) {\n        c = opCodes[i];\n        k = c & 3 /* ChildOpCode.Type */;\n        v = c >> 2 /* ChildOpCode.ValueShift */;\n        if (k === 0 /* ChildOpCode.Child */) {\n            children[j] =\n                update(sNode, children[j++], nextProps[v], updateFlags);\n        }\n        else if (k === 1 /* ChildOpCode.SetNext */) {\n            ctx.n = state[v];\n        }\n        else { // ChildOpCode.SetParent\n            ctx.p = state[v];\n            ctx.n = null;\n        }\n    }\n    ctx.p = parentElement;\n    ctx.n = rootNode;\n};\nconst _mountList = (parentState, f, arr, o) => {\n    var i = arr.length;\n    var c = _Array(i);\n    var s = createSNode(f, o, c, null, parentState);\n    while (i > 0) {\n        c[--i] = mount(s, arr[i]);\n    }\n    return s;\n};\nconst _updateText = (parentSNode, sNode, next, updateFlags) => {\n    var o;\n    var ctx = RENDER_CONTEXT;\n    var s = sNode.s;\n    if (typeof next !== \"object\") {\n        o = sNode.v;\n        // Reassign to reduce memory consumption even if next value is strictly\n        // equal the prev value.\n        sNode.v = next;\n        if (o !== next) {\n            s.nodeValue = next;\n        }\n        if (updateFlags & 512 /* Flags.DisplaceNode */) {\n            nodeInsertBefore.call(ctx.p, s, ctx.n);\n        }\n        return sNode;\n    }\n    nodeRemoveChild.call(ctx.p, s);\n    return mount(parentSNode, next);\n};\nconst _updateComponent = (sNode, next, updateFlags) => {\n    var child = sNode.c;\n    var prevProps = sNode.v.p;\n    var descriptor = next.d;\n    var nextProps = next.p;\n    if (((sNode.f | updateFlags) & (64 /* Flags.Dirty */ | 256 /* Flags.ForceUpdate */)) || ((prevProps !== nextProps) &&\n        (descriptor.p2 === void 0 || descriptor.p2(prevProps, nextProps) !== true))) {\n        sNode.c = update(sNode, child, sNode.s.r(nextProps), updateFlags);\n    }\n    else if (child !== null) {\n        dirtyCheck(child, updateFlags);\n    }\n};\nconst _updateArray = (sNode, children, updateFlags) => {\n    var result;\n    var childState;\n    var sChildren;\n    var j;\n    var i = children.length;\n    if (i === 0) {\n        _unmount(sNode);\n    }\n    else {\n        sChildren = sNode.c;\n        j = sChildren.length;\n        if (i !== j) {\n            sNode.c = (result = _Array(i));\n            while (j > i) {\n                if ((childState = sChildren[--j]) !== null) {\n                    _unmount(childState);\n                }\n            }\n            while (i > j) {\n                result[--i] = mount(sNode, children[i]);\n            }\n        }\n        while (i > 0) {\n            sChildren[--i] = update(sNode, sChildren[i], children[i], updateFlags);\n        }\n    }\n};\n/**\n * Update children list with track by key algorithm.\n *\n * @param sNode {@link SList} node.\n * @param a Previous {@link ListProps}.\n * @param b Next {@link ListProps}.\n * @param updateFlags Update flags.\n * @noinline\n * @__NOINLINE__\n */\nconst _updateList = (sNode, a, b, updateFlags) => {\n    var aKeys = a.k;\n    var bKeys = b.k;\n    var bOps = b.v;\n    var i = bKeys.length;\n    var j = aKeys.length;\n    var result = Array(i);\n    if (i === 0) { // New children list is empty.\n        if (j > 0) { // Unmount nodes from the old children list.\n            _unmount(sNode);\n        }\n    }\n    else if (j === 0) { // Old children list is empty.\n        while (i > 0) { // Mount nodes from the new children list.\n            result[--i] = mount(sNode, bOps[i]);\n        }\n    }\n    else {\n        var sChildren = sNode.c;\n        var aEnd = j - 1; // a.length - 1\n        var bEnd = i - 1; // b.length - 1\n        var start = 0;\n        var node = bKeys[bEnd];\n        // Step 1\n        outer: while (true) {\n            // Update nodes with the same key at the end.\n            while (aKeys[aEnd] === node) {\n                result[bEnd] = update(sNode, sChildren[aEnd--], bOps[bEnd], updateFlags);\n                if (start > --bEnd || start > aEnd) {\n                    break outer;\n                }\n                node = bKeys[bEnd];\n            }\n            // Update nodes with the same key at the beginning.\n            while (aKeys[start] === bKeys[start] && ++start <= aEnd && start <= bEnd) {\n                // delayed update (all updates should be performed from right-to-left).\n            }\n            break;\n        }\n        // Step 2\n        if (start > aEnd) {\n            // All nodes from `a` are updated, insert the rest from `b`.\n            while (bEnd >= start) {\n                result[bEnd] = mount(sNode, bOps[bEnd--]);\n            }\n        }\n        else if (start > bEnd) {\n            // All nodes from `b` are updated, remove the rest from `a`.\n            i = start;\n            do {\n                _unmount(sChildren[i++]);\n            } while (i <= aEnd);\n        }\n        else { // Step 3\n            // When `pos === RearrangeNodes`, it means that one of the nodes is in the wrong position and we should rearrange\n            // nodes with LIS-based algorithm `markLIS()`.\n            var pos = 0;\n            var bLength = bEnd - start + 1;\n            var sources = new _Int32Array(bLength); // Maps positions in the new children list to positions in the old list.\n            var keyIndex = new _Map(); // Maps keys to their positions in the new children list.\n            for (i = 0; i < bLength; ++i) {\n                // `NewNodeMark` value indicates that node doesn't exist in the old children list.\n                sources[i] = -1 /* MagicValues.NewNodeMark */;\n                j = i + start;\n                keyIndex.set(bKeys[j], j);\n            }\n            for (i = start; i <= aEnd; ++i) {\n                node = sChildren[i];\n                if ((j = keyIndex.get(aKeys[i])) !== void 0) {\n                    pos = (pos < j) ? j : 1073741823 /* MagicValues.RearrangeNodes */;\n                    sources[j - start] = i;\n                    result[j] = node;\n                }\n                else {\n                    _unmount(node);\n                }\n            }\n            // Step 4\n            // Mark LIS nodes only when this node weren't moved `moveNode === false` and we've detected that one of the\n            // children nodes were moved `pos === MagicValues.MovedChildren`.\n            if (!(updateFlags & 512 /* Flags.DisplaceNode */) && pos === 1073741823 /* MagicValues.RearrangeNodes */) {\n                markLIS(sources);\n            }\n            while (bLength-- > 0) {\n                bEnd = bLength + start;\n                node = bOps[bEnd];\n                j = sources[bLength];\n                result[bEnd] = (j === -1)\n                    ? mount(sNode, node)\n                    : update(sNode, result[bEnd], node, updateFlags |\n                        ((pos === 1073741823 /* MagicValues.RearrangeNodes */ && j !== -2 /* MagicValues.LISMark */)\n                            ? 512 /* Flags.DisplaceNode */\n                            : 0));\n            }\n        }\n        // Delayed update for nodes from Step 1 (prefix only). Reconciliation algorithm always updates nodes from right to\n        // left.\n        while (start > 0) {\n            result[--start] = update(sNode, sChildren[start], bOps[start], updateFlags);\n        }\n    }\n    sNode.c = result;\n};\n/**\n * Modified Longest Increased Subsequence algorithm.\n *\n * Mutates input array `a` and replaces all values that are part of LIS with -2 value.\n *\n * Constraints:\n * - Doesn't work with negative numbers. -1 values are ignored.\n * - Input array `a` should contain at least one value that is greater than -1.\n *\n * {@link http://en.wikipedia.org/wiki/Longest_increasing_subsequence}\n *\n * @example\n *\n *     const A = Int32Array.from([-1, 0, 2, 1]);\n *     markLIS(A);\n *     // A => [-1, -2, 2, -2]\n *\n * @param a Array of numbers.\n * @noinline\n * @__NOINLINE__\n */\nconst markLIS = (a) => {\n    var length = a.length;\n    var parent = new _Int32Array(length);\n    var index = new _Int32Array(length);\n    var indexLength = 0;\n    var i = 0;\n    var j;\n    var k;\n    var lo;\n    var hi;\n    // Skip -1 values at the start of the input array `a`.\n    for (; a[i] === -1 /* MagicValues.NewNodeMark */; i++) { /**/ }\n    index[0] = i++;\n    for (; i < length; i++) {\n        k = a[i];\n        if (k !== -1 /* MagicValues.NewNodeMark */) { // Ignore -1 values.\n            j = index[indexLength];\n            if (a[j] < k) {\n                parent[i] = j;\n                index[++indexLength] = i;\n            }\n            else {\n                lo = 0;\n                hi = indexLength;\n                while (lo < hi) {\n                    j = (lo + hi) >> 1;\n                    if (a[index[j]] < k) {\n                        lo = j + 1;\n                    }\n                    else {\n                        hi = j;\n                    }\n                }\n                if (k < a[index[lo]]) {\n                    if (lo > 0) {\n                        parent[i] = index[lo - 1];\n                    }\n                    index[lo] = i;\n                }\n            }\n        }\n    }\n    ;\n    // Mutate input array `a` and assign -2 value to all nodes that are part of LIS.\n    j = index[indexLength];\n    while (indexLength-- >= 0) {\n        a[j] = -2 /* MagicValues.LISMark */;\n        j = parent[j];\n    }\n};\n/**\n * Creates a HTML Template cloning factory.\n */\nexport const _h = (t) => (() => {\n    if (typeof t === \"string\") {\n        HTM_TEMPLATE.innerHTML = t;\n        t = HTM_TEMPLATE_CONTENT.firstChild;\n    }\n    return nodeCloneNode.call(t, true);\n});\n/**\n * Creates a HTML Template factory.\n */\nexport const _hN = (t) => (() => (HTM_TEMPLATE.innerHTML = t,\n    HTM_TEMPLATE_CONTENT.firstChild));\n/**\n * Creates a HTML Element factory.\n */\nexport const _hE = (t) => (() => doc.createElement(t));\n/**\n * Creates a SVG Template cloning factory.\n */\nexport const _s = (t) => (() => {\n    if (typeof t === \"string\") {\n        SVG_TEMPLATE.innerHTML = t;\n        t = SVG_TEMPLATE_CONTENT.firstChild;\n    }\n    return nodeCloneNode.call(t, true);\n});\n/**\n * Creates a SVG Template factory.\n */\nexport const _sN = (t) => (() => (SVG_TEMPLATE.innerHTML = t,\n    SVG_TEMPLATE_CONTENT.firstChild));\n/**\n * Creates a SVG Element factory.\n */\nexport const _sE = (t) => (() => doc.createElementNS(\"http://www.w3.org/2000/svg\", t));\n/**\n * Creates a template descriptor.\n */\nexport const _T = (p2, f, p, c, s, d) => ({\n    f: 1 /* Flags.Template */,\n    p1: { f, p, c, s, d },\n    p2,\n});\nexport const _t = (d, p) => ({ d, p });\n/**\n * Creates a factory that produces component nodes.\n *\n * @typeparam P Property type.\n * @param p1 Function that creates stateful render functions.\n * @param p2 Function that checks `props` for equality.\n * @returns Factory that produces component nodes.\n */\nexport const component = (p1, p2) => (p1 = { f: 2 /* Flags.Component */, p1, p2 },\n    (p) => ({ d: p1, p }));\n/**\n * Adds an unmount hook.\n *\n * @example\n *\n *     const Example = component((c) => {\n *       useUnmount(c, () => { console.log(\"unmounted\"); });\n *\n *       return () => null;\n *     });\n *\n * @param component Component instance.\n * @param hook Unmount hook.\n */\nexport const useUnmount = (component, hook) => {\n    var s = component.s;\n    var hooks = s.u;\n    s.u = (hooks === null)\n        ? hook\n        : (typeof hooks === \"function\")\n            ? [hooks, hook]\n            : (hooks.push(hook), hooks);\n};\n/**\n * Invalidates a component.\n *\n * @param c Component instance.\n */\nexport const invalidate = (c) => {\n    if (!(c.f & 64 /* Flags.Dirty */)) {\n        c.f |= 64 /* Flags.Dirty */;\n        var parent = c.p;\n        while (parent !== null) {\n            if (parent.f & 128 /* Flags.DirtySubtree */) {\n                return;\n            }\n            parent.f |= 128 /* Flags.DirtySubtree */;\n            c = parent;\n            parent = parent.p;\n        }\n        c.v.d.p1(c);\n    }\n};\n/**\n * VDescriptor for List nodes.\n */\nconst LIST = { f: 4 /* Flags.List */, p1: null, p2: null };\n/**\n * Creates a dynamic list.\n *\n * @typeparam E Entry type.\n * @typeparam K Key type.\n * @param entries Entries.\n * @param getKey Get key from entry function.\n * @param render Render entry function.\n * @returns Dynamic list.\n */\nexport const List = (entries, getKey, render) => ({\n    d: LIST,\n    p: {\n        k: entries.map(getKey),\n        v: entries.map(render),\n    },\n});\n/**\n * Performs a Dirty Checking in a Stateful Node Subtree.\n *\n * @param sNode Stateful Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n */\nexport const dirtyCheck = (sNode, updateFlags) => {\n    var state, op, type, value, c, i, j, parentElement, rootNode, childOpCodes, ctx = RENDER_CONTEXT, children = sNode.c, flags = sNode.f;\n    if (flags & 1 /* Flags.Template */) {\n        rootNode = sNode.s[0];\n        if (updateFlags & 512 /* Flags.DisplaceNode */) {\n            updateFlags ^= 512 /* Flags.DisplaceNode */;\n            nodeInsertBefore.call(ctx.p, rootNode, ctx.n);\n        }\n        if (flags & 128 /* Flags.DirtySubtree */) {\n            j = 0;\n            parentElement = ctx.p;\n            ctx.p = rootNode;\n            ctx.n = null;\n            state = sNode.s;\n            childOpCodes = sNode.v.d.p1.c;\n            for (i = 0; i < childOpCodes.length; i++) {\n                op = childOpCodes[i];\n                type = op & 3 /* ChildOpCode.Type */;\n                value = op >> 2 /* ChildOpCode.ValueShift */;\n                if (type === 0 /* ChildOpCode.Child */) {\n                    if ((c = children[j++]) !== null) {\n                        dirtyCheck(c, updateFlags);\n                    }\n                }\n                else if (type === 1 /* ChildOpCode.SetNext */) {\n                    ctx.n = state[value];\n                }\n                else { // ChildOpCode.SetParent\n                    ctx.p = state[value];\n                    ctx.n = null;\n                }\n            }\n            ctx.p = parentElement;\n        }\n        ctx.n = rootNode;\n    }\n    else if (flags & 16 /* Flags.Text */) {\n        if (updateFlags & 512 /* Flags.DisplaceNode */) {\n            nodeInsertBefore.call(ctx.p, sNode.s, ctx.n);\n        }\n        ctx.n = sNode.s;\n    }\n    else if (flags & 2 /* Flags.Component */) {\n        if ((flags | updateFlags) & (64 /* Flags.Dirty */ | 256 /* Flags.ForceUpdate */)) {\n            sNode.c = update(sNode, children, sNode.s.r(sNode.v.p), updateFlags);\n        }\n        else if (children !== null) {\n            dirtyCheck(children, updateFlags);\n        }\n    }\n    else { // Array || List\n        i = children.length;\n        while (--i >= 0) {\n            if ((state = children[i]) !== null) {\n                dirtyCheck(state, updateFlags);\n            }\n        }\n    }\n    sNode.f &= 63 /* Flags.CleanSNodeMask */;\n};\n/**\n * Updates a Stateful Node with a new Stateless Node.\n *\n * @param parentSNode Parent Stateul Node.\n * @param sNode Stateful Node to update.\n * @param next New Stateless Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n * @returns Stateful Node.\n */\nexport const update = (parentSNode, sNode, next, updateFlags) => {\n    var flags, prev;\n    if (next === null) {\n        _unmount(sNode);\n        return null;\n    }\n    if (sNode === null) {\n        return mount(parentSNode, next);\n    }\n    flags = sNode.f;\n    if (flags & 16 /* Flags.Text */) {\n        return _updateText(parentSNode, sNode, next, updateFlags);\n    }\n    prev = sNode.v;\n    if (prev === next) {\n        dirtyCheck(sNode, updateFlags);\n        return sNode;\n    }\n    if (((flags & 8 /* Flags.Array */) && !_isArray(next))\n        || (prev.d !== next.d)) {\n        _unmount(sNode);\n        return mount(parentSNode, next);\n    }\n    flags &= (2 /* Flags.Component */ | 1 /* Flags.Template */ | 8 /* Flags.Array */);\n    if (flags === 2 /* Flags.Component */) {\n        _updateComponent(sNode, next, updateFlags);\n    }\n    else if (flags === 1 /* Flags.Template */) {\n        _updateTemplate(sNode, next, updateFlags);\n    }\n    else if (flags === 8 /* Flags.Array */) {\n        _updateArray(sNode, next, updateFlags);\n    }\n    else {\n        _updateList(sNode, prev.p, next.p, updateFlags);\n    }\n    sNode.f &= 63 /* Flags.CleanSNodeMask */;\n    sNode.v = next;\n    return sNode;\n};\n/**\n * Mounts Stateless Node.\n *\n * @param parentSNode Parent Stateful Node.\n * @param v Stateless Node.\n * @returns Mounted Stateful Node.\n */\nexport const mount = (parentSNode, v) => {\n    var i, c, s, d, e;\n    if (v !== null) {\n        if (typeof v === \"object\") {\n            if (_isArray(v)) {\n                return _mountList(parentSNode, 8 /* Flags.Array */, v, v);\n            }\n            else {\n                d = v.d;\n                i = d.f & (1 /* Flags.Template */ | 2 /* Flags.Component */);\n                if (i === 1 /* Flags.Template */) {\n                    return _mountTemplate(parentSNode, v);\n                }\n                else if (i === 2 /* Flags.Component */) {\n                    e = { r: null, u: null };\n                    s = createSNode(2 /* Flags.Component */, v, null, e, parentSNode);\n                    e.r = c = d.p1(s);\n                    s.c = mount(s, c(v.p));\n                    return s;\n                }\n                // List\n                return _mountList(parentSNode, 4 /* Flags.List */, v.p.v, v);\n            }\n        }\n        else {\n            c = RENDER_CONTEXT;\n            e = doc.createTextNode(v);\n            nodeInsertBefore.call(c.p, e, c.n);\n            c.n = e;\n            return createSNode(16 /* Flags.Text */, v, null, e, parentSNode);\n        }\n    }\n    return null;\n};\n/**\n * Unmounts Stateful Node.\n *\n * @param sNode Stateful Node.\n * @param detach Detach root DOM nodes from the DOM.\n */\nexport const unmount = (sNode, detach) => {\n    var c, i, v, f = sNode.f;\n    if (detach === true && (f & (1 /* Flags.Template */ | 16 /* Flags.Text */))) {\n        detach = false;\n        nodeRemoveChild.call(RENDER_CONTEXT.p, (f & 1 /* Flags.Template */)\n            ? sNode.s[0]\n            : sNode.s);\n    }\n    if ((c = sNode.c) !== null) {\n        if (_isArray(c)) {\n            for (i = 0; i < c.length; i++) {\n                if ((v = c[i]) !== null) {\n                    unmount(v, detach);\n                }\n            }\n        }\n        else {\n            unmount(c, detach);\n        }\n    }\n    if (f & 2 /* Flags.Component */) {\n        if ((c = sNode.s.u) !== null) {\n            if (typeof c === \"function\") {\n                c();\n            }\n            else {\n                for (i = 0; i < c.length; i++) {\n                    c[i]();\n                }\n            }\n        }\n    }\n};\n//# sourceMappingURL=index.js.map","import { RENDER_CONTEXT, createSNode, dirtyCheck, mount, update, unmount, } from \"./index.js\";\nconst _queueMicrotask = queueMicrotask;\nconst ROOT_DESCRIPTOR = {\n    // Root Descriptor should always have a `Flags.Root` flag.\n    f: 32 /* Flags.Root */,\n    // OnRootInvalidated hook\n    p1: (root) => {\n        _queueMicrotask(() => {\n            // Retrieves DOM slot from VNode object.\n            var domSlot = root.v.p;\n            // Assign parent element and next node to the render context.\n            RENDER_CONTEXT.p = domSlot.p;\n            RENDER_CONTEXT.n = domSlot.n;\n            // Updates invalidated components.\n            dirtyCheck(root.c, 0);\n            // Flags should always be reassigned to clear dirty flags.\n            root.f = 32 /* Flags.Root */;\n        });\n    },\n    // p2 should always be initialized with `null` value. This propery is\n    // initialized so that all `Descriptor` objects will have the same object\n    // shape and all call-sites that access Descriptor objects will be in a\n    // monorphic state.\n    p2: null,\n};\n/**\n * Creates a new root.\n *\n * @param p Parent DOM Element.\n * @param n Next DOM Element.\n * @returns Root Node.\n */\nexport const createRoot = (p, n = null) => (createSNode(32 /* Flags.Root */, \n// VNode object.\n{\n    // VNode descriptor should be initialized with `RootDescriptor`\n    d: ROOT_DESCRIPTOR,\n    // VNode props object contains the location in the DOM tree where subtree\n    // should be rendered.\n    p: {\n        // Parent DOM Element.\n        p,\n        // Next DOM Node.\n        n,\n    },\n}, \n// Children should always be initialized with `null` value.\nnull, \n// State `SRoot<State>` that can be used to store any value.\nnull, \n// Parent SNode should always have a `null` value.\nnull));\n/**\n * Updates a root subtree.\n *\n * @param root Root Node.\n * @param v Stateless Node.\n * @param forceUpdate Force update for all components.\n */\nexport const updateRoot = (root, v, forceUpdate = false) => {\n    // Retrieves DOM slot from VNode object.\n    var domSlot = root.v.p;\n    // Assign parent element and next node to the render context.\n    RENDER_CONTEXT.p = domSlot.p;\n    RENDER_CONTEXT.n = domSlot.n;\n    root.c = ((root.c === null)\n        ? mount(\n        // Parent SNode should always be a root node.\n        root, \n        // UI Representation.\n        v)\n        : update(\n        // Parent SNode should always be a root node.\n        root, \n        // Previous UI state.\n        root.c, \n        // UI Representation.\n        v, \n        // Force update.\n        forceUpdate === true\n            ? 256 /* Flags.ForceUpdate */\n            : 0));\n    // Flags should always be reassigned on update to clear dirty flags.\n    root.f = 32 /* Flags.Root */;\n};\n/**\n * Force update for all components in a root subtree.\n *\n * @param root Root Node.\n */\nexport const forceUpdateRoot = (root) => {\n    // Checks if a Root Node has any children.\n    if (root.c !== null) {\n        update(\n        // Parent SNode should always be a root node.\n        root, \n        // Previous Stateful Node\n        root.c, \n        // Previous Stateless Node.\n        root.c.v, 256 /* Flags.ForceUpdate */);\n    }\n};\n/**\n * Disposes a root subtree and triggers all unmount hooks.\n *\n * @param root Root Node.\n * @param detach Detach root nodes from the DOM.\n */\nexport const disposeRoot = (root, detach) => {\n    if (root.c !== null) {\n        // Assign parent element to the render context.\n        RENDER_CONTEXT.p = root.v.p.p;\n        // Unmounts a root subtree.\n        unmount(\n        // Previous UI state.\n        root.c, \n        // Detach root nodes.\n        detach);\n    }\n};\n//# sourceMappingURL=root.js.map"],"names":["_Object","Object","_Array","Array","_isArray","isArray","_Map","Map","_Int32Array","Int32Array","nodeProto","Node","prototype","elementProto","Element","doc","document","HTM_TEMPLATE","createElement","HTM_TEMPLATE_CONTENT","content","firstChild","nodeInsertBefore","insertBefore","nodeRemoveChild","removeChild","nodeCloneNode","cloneNode","elementSetAttribute","setAttribute","elementRemoveAttribute","removeAttribute","elementAddEventListener","addEventListener","elementRemoveEventListener","removeEventListener","getDescriptor","o","p","getOwnPropertyDescriptor","nodeGetFirstChild","get","nodeGetNextSibling","nodeSetTextContent","set","elementSetClassName","htmlElementGetStyle","HTMLElement","svgElementGetStyle","SVGElement","RENDER_CONTEXT","seal","n","si","createSNode","f","v","c","s","_unmount","sNode","i","length","unmount","_updateTemplateProperties","currentElement","opCodes","strings","state","prevProps","nextProps","svg","style","key","type","propsIndex","dataIndex","op","prev","next","call","nodeValue","setProperty","_assignTemplateSlots","currentNode","offset","endOffset","tmp","ctx","remove","_mountTemplate","parentSNode","vNode","stateNode","childIndex","value","j","children","parentElement","nextNode","d","props","tpl","p1","rootNode","p2","mount","_updateTemplate","updateFlags","k","update","_mountList","parentState","arr","_updateText","_updateComponent","child","descriptor","r","dirtyCheck","_updateArray","result","childState","sChildren","_updateList","a","b","aKeys","bKeys","bOps","aEnd","bEnd","start","node","outer","pos","bLength","sources","keyIndex","markLIS","lo","hi","parent","index","indexLength","_h","t","innerHTML","_hE","_T","_t","component","LIST","List","entries","getKey","render","map","childOpCodes","flags","e","u","createTextNode","detach","_queueMicrotask","queueMicrotask","ROOT_DESCRIPTOR","root","domSlot","createRoot","updateRoot","forceUpdate","tableCellId","_","tableRowId","row","id","animId","item","treeNodeId","_tpl_","_OP","_TPL_DATA","TableCell","click","console","log","_tpl_2","TableRow","active","_tpl_3","Table","items","_tpl_4","AnimBox","time","_tpl_5","_OP2","Anim","_tpl_6","TreeLeaf","subtree","container","TreeNode","_tpl_7","_tpl_8","Tree","_tpl_9","Main","location","table","anim","tree","uibench","init","getElementById","run","samples","JSON","stringify"],"mappings":"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"}