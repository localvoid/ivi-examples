{"version":3,"file":"bundle.js","sources":["../../../node_modules/.pnpm/ivi@3.0.0-beta.1/node_modules/ivi/dist/index.js","../../../node_modules/.pnpm/perf-monitor@0.6.0/node_modules/perf-monitor/dist/index.js","../../../node_modules/.pnpm/ivi@3.0.0-beta.1/node_modules/ivi/dist/root.js","../src/index.ts"],"sourcesContent":["// # Implementation Details\n//\n// ## Type Casting\n//\n// The current code base contains a lot of type casting. In idiomatic typescript\n// it should be implemented with type guards, and if javascript toolchains\n// supported inlining in some reliable way instead of relying on their\n// heuristics, the code would be way much cleaner with type guard functions.\n//\n// ## `var` vs `let`\n//\n// In some places variables are declared with `var` instead of `let`, it is a\n// micro optimization that propably won't have any significant impact on\n// performance, especially when the JIT kicks in.\n//\n//     function __var(i) {\n//       var j = i;\n//       return function _var() {\n//         return j;\n//       }\n//     }\n//\n//     function __let(i) {\n//       let j = i;\n//       return function _let() {\n//         return j;\n//       };\n//     }\n//\n// In the example above, `_var` function will have the following bytecode in V8:\n//\n//     LdaImmutableCurrentContextSlot [2]\n//     Return\n//\n// And `_let` function:\n//\n//     LdaImmutableCurrentContextSlot [2]\n//     ThrowReferenceErrorIfHole[0];\n//     Return\n//\n// ## `if (a === true) {}` vs `if (a) {}`\n//\n// In a lot of places there are explicit strict equality checks to avoid\n// `toBool()` coercion. Sometimes we can avoid explicit checks when JIT compiler\n// is going to inline functions and will be able to eliminate `toBool()`\n// coercion. For example, `_isArray()` calls doesn't use strict equality checks.\n//\n// `(a === true)`\n//\n// 0x738b024    24  488b5518             REX.W movq rdx, [rbp + 0x18];\n// 0x738b028    28  493995b0000000       REX.W cmpq[r13 + 0xb0](root(true_value)), rdx;\n// 0x738b02f    2f  0f8424000000         jz 0x738b059 < +0x59 >\n// 0x738b035    35  48b80000000014000000 REX.W movq rax, 0x1400000000;\n// 0x738b03f    3f  488b4de8             REX.W movq rcx, [rbp - 0x18];\n// 0x738b043    43  488be5               REX.W movq rsp, rbp;\n// 0x738b046    46  5d                   pop rbp;\n// 0x738b047    47  4883f902             REX.W cmpq rcx, 0x2;\n// 0x738b04b    4b  7f03                 jg 0x738b050 < +0x50 >\n// 0x738b04d    4d  c21000               ret 0x10;\n//\n// `(a)`, inlines `toBool()`\n//\n// 0x618b024    24  488b5518             REX.W movq rdx, [rbp + 0x18];\n// 0x618b028    28  f6c201               testb rdx, 0x1;\n// 0x618b02b    2b  0f84a7000000         jz 0x618b0d8 < +0xd8 >\n// 0x618b031    31  493995b8000000       REX.W cmpq[r13 + 0xb8](root(false_value)), rdx;\n// 0x618b038    38  0f8459000000         jz 0x618b097 < +0x97 >\n// 0x618b03e    3e  493995c0000000       REX.W cmpq[r13 + 0xc0](root(empty_string)), rdx;\n// 0x618b045    45  0f844c000000         jz 0x618b097 < +0x97 >\n// 0x618b04b    4b  488b4aff             REX.W movq rcx, [rdx - 0x1];\n// 0x618b04f    4f  f6410d10             testb[rcx + 0xd], 0x10;\n// 0x618b053    53  0f853e000000         jnz 0x618b097 < +0x97 >\n// 0x618b059    59  49398d38010000       REX.W cmpq[r13 + 0x138](root(heap_number_map)), rcx;\n// 0x618b060    60  0f8484000000         jz 0x618b0ea < +0xea >\n// 0x618b066    66  49398db8010000       REX.W cmpq[r13 + 0x1b8](root(bigint_map)), rcx;\n// 0x618b06d    6d  0f846c000000         jz 0x618b0df < +0xdf >\n// 0x618b073    73  48b8000000000a000000 REX.W movq rax, 0xa00000000;\n// 0x618b07d    7d  488b4de8             REX.W movq rcx, [rbp - 0x18];\n// 0x618b081    81  488be5               REX.W movq rsp, rbp;\n// 0x618b084    84  5d                   pop rbp;\n// 0x618b085    85  4883f902             REX.W cmpq rcx, 0x2;\n// 0x618b089    89  7f03                 jg 0x618b08e < +0x8e >\n// 0x618b08b    8b  c21000               ret 0x10;\n//\n// ## Additional Resources\n//\n// - https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html\n// - https://benediktmeurer.de/2017/06/29/javascript-optimization-patterns-part2/\n//\n// Store global variables in a local scope as const variables so that JIT\n// compiler could easily inline functions and eliminate checks in case global\n// variables are overriden.\nconst _Object = Object;\nconst _Array = Array;\nconst _isArray = _Array.isArray;\nconst _Map = Map;\nconst _Int32Array = Int32Array;\nconst nodeProto = Node.prototype;\nconst elementProto = Element.prototype;\nconst doc = document;\n// Template containers are used to create static templates from HTML strings\n// via `innerHTML`.\nconst HTM_TEMPLATE = /**@__PURE__*/ doc.createElement(\"template\");\nconst HTM_TEMPLATE_CONTENT = HTM_TEMPLATE.content;\nconst _SVG_TEMPLATE = /**@__PURE__*/ doc.createElement(\"template\");\nconst SVG_TEMPLATE = /**@__PURE__*/ doc.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n/**@__PURE__*/ _SVG_TEMPLATE.content.appendChild(SVG_TEMPLATE);\nconst SVG_TEMPLATE_CONTENT = _SVG_TEMPLATE.content.firstChild;\n// Store Node/Element methods to avoid going through a long prototype chain and\n// avoid megamorphic call-sites when accessing DOM nodes.\n/** `Node.prototype.insertBefore` */\nconst nodeInsertBefore = nodeProto.insertBefore;\n/** `Node.prototype.removeChild`. */\nconst nodeRemoveChild = nodeProto.removeChild;\n/** `Node.prototype.cloneNode`. */\nconst nodeCloneNode = nodeProto.cloneNode;\n/** `Element.prototype.setAttribute` */\nconst elementSetAttribute = elementProto.setAttribute;\n/** `Element.prototype.removeAttribute` */\nconst elementRemoveAttribute = elementProto.removeAttribute;\n/** `EventTarget.prototype.addEventListener` */\nconst elementAddEventListener = elementProto.addEventListener;\n/** `EventTarget.prototype.removeEventListener` */\nconst elementRemoveEventListener = elementProto.removeEventListener;\n/** `Object.getOwnPropertyDescriptor(o, p)` */\nconst getDescriptor = (o, p) => _Object.getOwnPropertyDescriptor(o, p);\n/** `Node.prototype.getFirstChild` */\nconst nodeGetFirstChild = /*@__PURE__*/ getDescriptor(nodeProto, \"firstChild\").get;\n/** `Node.prototype.getNextSibling` */\nconst nodeGetNextSibling = /*@__PURE__*/ getDescriptor(nodeProto, \"nextSibling\").get;\n/** `Node.prototype.setTextContent` */\nconst nodeSetTextContent = /*@__PURE__*/ getDescriptor(nodeProto, \"textContent\").set;\n/** `Element.prototype.className` */\nconst elementSetClassName = /*@__PURE__*/ getDescriptor(elementProto, \"className\").set;\n/** `HTMLElement.prototype.style`. */\nconst htmlElementGetStyle = /*@__PURE__*/ getDescriptor(HTMLElement.prototype, \"style\").get;\n/** `SVGElement.prototype.style` */\nconst svgElementGetStyle = /*@__PURE__*/ getDescriptor(SVGElement.prototype, \"style\").get;\n// When object is sealed and stored in a const variable, JIT compiler can\n// eliminate object map(shape) checks when accessing its properties.\n/**\n * Global Render Context.\n */\nexport const RENDER_CONTEXT = _Object.seal({\n    p: null,\n    n: null,\n    si: 0,\n    e: [],\n});\n/**\n * Creates a Stateful Node instance.\n *\n * @param v VNode.\n * @returns {@link SNode} instance.\n */\nexport const createSNode = (f, v, c, s, p) => ({ f, v, c, s, p });\nconst _flushDOMEffects = () => {\n    const e = RENDER_CONTEXT.e;\n    if (e.length > 0) {\n        RENDER_CONTEXT.e = [];\n        for (let i = 0; i < e.length; i++) {\n            e[i]();\n        }\n    }\n};\nconst _updateTemplateProperties = (currentElement, opCodes, strings, state, prevProps, nextProps, svg) => {\n    for (let i = 0; i < opCodes.length; i++) {\n        let style;\n        const op = opCodes[i];\n        const type = op & 7 /* PropOpCode.TypeMask */;\n        const dataIndex = op >> 9 /* PropOpCode.DataShift */;\n        if (type === 0 /* PropOpCode.SetNode */) {\n            currentElement = state[dataIndex];\n            style = void 0;\n        }\n        else {\n            const propsIndex = (op >> 3 /* PropOpCode.InputShift */) & 63 /* PropOpCode.Mask6 */;\n            const next = nextProps[propsIndex];\n            let prev;\n            if (prevProps !== null) {\n                prev = prevProps[propsIndex];\n            }\n            if (prev !== next || type === 4 /* PropOpCode.DiffDOMProperty */) {\n                if (type === 1 /* PropOpCode.Common */) {\n                    if (dataIndex === 0 /* CommonPropType.ClassName */) {\n                        if (next !== \"\" || prev !== void 0) {\n                            elementSetClassName.call(currentElement, next);\n                        }\n                    }\n                    else { // CommonPropType.TextContent\n                        if (prev === void 0) {\n                            nodeSetTextContent.call(currentElement, next);\n                        }\n                        else {\n                            nodeGetFirstChild.call(currentElement).nodeValue = next;\n                        }\n                    }\n                }\n                else if (type === 7 /* PropOpCode.Directive */) {\n                    next(currentElement);\n                }\n                else {\n                    const key = strings[dataIndex];\n                    if (type === 2 /* PropOpCode.Attribute */) {\n                        if (next !== void 0) {\n                            elementSetAttribute.call(currentElement, key, next);\n                        }\n                        else {\n                            elementRemoveAttribute.call(currentElement, key);\n                        }\n                    }\n                    else if (type === 3 /* PropOpCode.Property */) {\n                        currentElement[key] = next;\n                    }\n                    else if (type === 4 /* PropOpCode.DiffDOMProperty */) {\n                        if (currentElement[key] !== next) {\n                            currentElement[key] = next;\n                        }\n                    }\n                    else if (type === 5 /* PropOpCode.Style */) {\n                        if (style === void 0) {\n                            style = (svg === false)\n                                ? htmlElementGetStyle.call(currentElement)\n                                : svgElementGetStyle.call(currentElement);\n                        }\n                        style.setProperty(key, next);\n                    }\n                    else { // PropOpCode.Event\n                        if (prev !== void 0) {\n                            elementRemoveEventListener.call(currentElement, key, prev);\n                        }\n                        elementAddEventListener.call(currentElement, key, next);\n                    }\n                }\n            }\n        }\n    }\n};\nconst _assignTemplateSlots = (currentNode, opCodes, offset, endOffset, state) => {\n    const ctx = RENDER_CONTEXT;\n    while (true) {\n        const op = opCodes[offset++];\n        if (op & 1 /* StateOpCode.Save */) {\n            state[++ctx.si] = currentNode;\n        }\n        if (op & 2 /* StateOpCode.EnterOrRemove */) {\n            const enterOffset = op >> 2 /* StateOpCode.OffsetShift */;\n            // Enter offset is used to disambiguate between enter and remove\n            // operations. Remove operations will always have a 0 enterOffset.\n            if (enterOffset) { // Enter\n                _assignTemplateSlots(nodeGetFirstChild.call(currentNode), opCodes, offset, offset += enterOffset, state);\n            }\n            else { // Remove\n                // Remove operation implies that current node is always a comment node\n                // followed by a text node.\n                const commentNode = currentNode;\n                state[++ctx.si] = currentNode = nodeGetNextSibling.call(currentNode);\n                commentNode.remove();\n            }\n        }\n        if (offset === endOffset) {\n            return;\n        }\n        currentNode = nodeGetNextSibling.call(currentNode);\n    }\n};\nconst _mountList = (parentState, flags, children, vNode) => {\n    let i = children.length;\n    const sChildren = _Array(i);\n    const sNode = createSNode(flags, vNode, sChildren, null, parentState);\n    while (i > 0) {\n        sChildren[--i] = _mount(sNode, children[i]);\n    }\n    return sNode;\n};\nconst _updateArray = (parentSNode, sNode, next, updateFlags) => {\n    if (!_isArray(next)) {\n        _unmount(sNode, true);\n        return _mount(parentSNode, next);\n    }\n    sNode.f = 8 /* Flags.Array */;\n    const prevSChildren = sNode.c;\n    let nextSChildren = prevSChildren;\n    let prevLength = prevSChildren.length;\n    let nextLength = next.length;\n    if (nextLength !== prevLength) {\n        sNode.c = nextSChildren = _Array(nextLength);\n        while (prevLength > nextLength) {\n            const sChild = prevSChildren[--prevLength];\n            if (sChild !== null) {\n                _unmount(sChild, true);\n            }\n        }\n        while (nextLength > prevLength) {\n            nextSChildren[--nextLength] = _mount(sNode, next[nextLength]);\n        }\n    }\n    while (nextLength > 0) {\n        nextSChildren[--nextLength] = _update(sNode, prevSChildren[nextLength], next[nextLength], updateFlags);\n    }\n    return sNode;\n};\n/**\n * Updates a Stateful Node with a new Stateless Node.\n *\n * @param parentSNode Parent Stateul Node.\n * @param sNode Stateful Node to update.\n * @param next New Stateless Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n * @returns Stateful Node.\n */\nconst _update = (parentSNode, sNode, next, updateFlags) => {\n    if (sNode === null) {\n        return _mount(parentSNode, next);\n    }\n    if (next === false || next == null) {\n        _unmount(sNode, true);\n        return null;\n    }\n    const flags = sNode.f;\n    const type = flags & 63 /* Flags.TypeMask */;\n    if (type === 16 /* Flags.Text */) {\n        const ctx = RENDER_CONTEXT;\n        const textNode = sNode.s;\n        if (typeof next !== \"object\") {\n            const prev = sNode.v;\n            // Reassign to reduce memory consumption even if next value is strictly\n            // equal the prev value.\n            sNode.v = next;\n            if (prev !== next) {\n                textNode.nodeValue = next;\n            }\n            if (updateFlags & 512 /* Flags.DisplaceNode */) {\n                nodeInsertBefore.call(ctx.p, textNode, ctx.n);\n            }\n            return sNode;\n        }\n        nodeRemoveChild.call(ctx.p, textNode);\n        return _mount(parentSNode, next);\n    }\n    const prev = sNode.v;\n    sNode.v = next;\n    if (prev === next) {\n        _dirtyCheck(sNode, updateFlags);\n        return sNode;\n    }\n    if (type === 8 /* Flags.Array */) {\n        return _updateArray(parentSNode, sNode, next, updateFlags);\n    }\n    const descriptor = next.d;\n    // Text and Array should be checked before Component, Template and List\n    // because their stateless nodes are represented with basic string and array\n    // types.\n    if (prev.d !== descriptor) {\n        _unmount(sNode, true);\n        return _mount(parentSNode, next);\n    }\n    const prevProps = prev.p;\n    const nextProps = next.p;\n    sNode.f = type;\n    if (type === 2 /* Flags.Component */) {\n        const child = sNode.c;\n        if (((flags | updateFlags) & (64 /* Flags.Dirty */ | 256 /* Flags.ForceUpdate */)) ||\n            (descriptor.p2 === void 0) ||\n            (descriptor.p2(prevProps, nextProps) !== true)) {\n            sNode.c = _update(sNode, child, sNode.s.r(nextProps), updateFlags);\n        }\n        else if (child !== null) {\n            _dirtyCheck(child, updateFlags);\n        }\n    }\n    else if (type === 1 /* Flags.Template */) {\n        const ctx = RENDER_CONTEXT;\n        const parentElement = ctx.p;\n        const children = sNode.c;\n        const state = sNode.s;\n        const tplData = descriptor.p1;\n        const rootDOMNode = state[0];\n        const childrenOpCodes = tplData.c;\n        if (updateFlags & 512 /* Flags.DisplaceNode */) {\n            updateFlags ^= 512 /* Flags.DisplaceNode */;\n            nodeInsertBefore.call(parentElement, rootDOMNode, ctx.n);\n        }\n        _updateTemplateProperties(rootDOMNode, tplData.p, tplData.d, state, prevProps, nextProps, (tplData.f & 4096 /* TemplateFlags.Svg */) === 4096 /* TemplateFlags.Svg */);\n        if (children !== null) {\n            ctx.p = rootDOMNode;\n            ctx.n = null;\n            let childrenIndex = 0;\n            for (let i = 0; i < childrenOpCodes.length; i++) {\n                const childOpCode = childrenOpCodes[i];\n                const type = childOpCode & 3 /* ChildOpCode.Type */;\n                const value = childOpCode >> 2 /* ChildOpCode.ValueShift */;\n                if (type === 0 /* ChildOpCode.Child */) {\n                    children[childrenIndex] =\n                        _update(sNode, children[childrenIndex++], nextProps[value], updateFlags);\n                }\n                else if (type === 1 /* ChildOpCode.SetNext */) {\n                    ctx.n = state[value];\n                }\n                else { // ChildOpCode.SetParent\n                    ctx.p = state[value];\n                    ctx.n = null;\n                }\n            }\n            ctx.p = parentElement;\n        }\n        ctx.n = rootDOMNode;\n    }\n    else {\n        _updateList(sNode, prevProps, nextProps, updateFlags);\n    }\n    return sNode;\n};\n/**\n * Mounts Stateless Node.\n *\n * @param parentSNode Parent Stateful Node.\n * @param v Stateless Node.\n * @returns Mounted Stateful Node.\n */\nconst _mount = (parentSNode, v) => {\n    if (v !== false && v != null) {\n        if (typeof v === \"object\") {\n            if (_isArray(v)) {\n                return _mountList(parentSNode, 8 /* Flags.Array */, v, v);\n            }\n            else {\n                const descriptor = v.d;\n                const props = v.p;\n                const type = descriptor.f & (1 /* Flags.Template */ | 2 /* Flags.Component */);\n                if (type === 1 /* Flags.Template */) {\n                    const ctx = RENDER_CONTEXT;\n                    const tplData = descriptor.p1;\n                    const rootNode = descriptor.p2();\n                    const stateOpCodes = tplData.s;\n                    const flags = tplData.f;\n                    const state = _Array(flags & 63 /* TemplateFlags.Mask6 */);\n                    state[0] = rootNode;\n                    if (stateOpCodes.length > 0) {\n                        ctx.si = 0;\n                        _assignTemplateSlots(nodeGetFirstChild.call(rootNode), stateOpCodes, 0, stateOpCodes.length, state);\n                    }\n                    _updateTemplateProperties(rootNode, tplData.p, tplData.d, state, null, props, (tplData.f & 4096 /* TemplateFlags.Svg */) === 4096 /* TemplateFlags.Svg */);\n                    const parentElement = ctx.p;\n                    const nextNode = ctx.n;\n                    const stateNode = createSNode(1 /* Flags.Template */, v, null, state, parentSNode);\n                    const childrenSize = (flags >> 6 /* TemplateFlags.ChildrenSizeShift */) & 63 /* TemplateFlags.Mask6 */;\n                    if (childrenSize > 0) {\n                        const childOpCodes = tplData.c;\n                        const children = _Array(childrenSize);\n                        stateNode.c = children;\n                        ctx.p = rootNode;\n                        ctx.n = null;\n                        let childrenIndex = 0;\n                        for (let i = 0; i < childOpCodes.length; i++) {\n                            const childOpCode = childOpCodes[i];\n                            const type = childOpCode & 3 /* ChildOpCode.Type */;\n                            const value = childOpCode >> 2 /* ChildOpCode.ValueShift */;\n                            if (type === 0 /* ChildOpCode.Child */) {\n                                children[childrenIndex++] = _mount(stateNode, props[value]);\n                            }\n                            else if (type === 1 /* ChildOpCode.SetNext */) {\n                                ctx.n = state[value];\n                            }\n                            else { // ChildOpCode.SetParent\n                                ctx.p = state[value];\n                                ctx.n = null;\n                            }\n                        }\n                        ctx.p = parentElement;\n                    }\n                    ctx.n = rootNode;\n                    nodeInsertBefore.call(parentElement, rootNode, nextNode);\n                    return stateNode;\n                }\n                else if (type === 2 /* Flags.Component */) {\n                    const componentState = { r: null, u: null };\n                    const sNode = createSNode(2 /* Flags.Component */, v, null, componentState, parentSNode);\n                    const renderFn = descriptor.p1(sNode);\n                    componentState.r = renderFn;\n                    sNode.c = _mount(sNode, renderFn(props));\n                    return sNode;\n                }\n                // List\n                return _mountList(parentSNode, 4 /* Flags.List */, props.v, v);\n            }\n        }\n        else {\n            const ctx = RENDER_CONTEXT;\n            const e = doc.createTextNode(v);\n            nodeInsertBefore.call(ctx.p, e, ctx.n);\n            ctx.n = e;\n            return createSNode(16 /* Flags.Text */, v, null, e, parentSNode);\n        }\n    }\n    return null;\n};\n/**\n * Performs a Dirty Checking in a Stateful Node Subtree.\n *\n * @param sNode Stateful Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n */\nconst _dirtyCheck = (sNode, updateFlags) => {\n    const ctx = RENDER_CONTEXT;\n    const children = sNode.c;\n    const flags = sNode.f;\n    sNode.f &= 63 /* Flags.TypeMask */;\n    if (flags & 1 /* Flags.Template */) {\n        const rootDOMNode = sNode.s[0];\n        if (updateFlags & 512 /* Flags.DisplaceNode */) {\n            updateFlags ^= 512 /* Flags.DisplaceNode */;\n            nodeInsertBefore.call(ctx.p, rootDOMNode, ctx.n);\n        }\n        if (flags & 128 /* Flags.DirtySubtree */) {\n            ctx.p = rootDOMNode;\n            ctx.n = null;\n            const parentDOMElement = ctx.p;\n            const state = sNode.s;\n            const childOpCodes = sNode.v.d.p1.c;\n            let childrenIndex = 0;\n            for (let i = 0; i < childOpCodes.length; i++) {\n                const op = childOpCodes[i];\n                const type = op & 3 /* ChildOpCode.Type */;\n                const value = op >> 2 /* ChildOpCode.ValueShift */;\n                if (type === 0 /* ChildOpCode.Child */) {\n                    const sChild = children[childrenIndex++];\n                    if (sChild !== null) {\n                        _dirtyCheck(sChild, updateFlags);\n                    }\n                }\n                else if (type === 1 /* ChildOpCode.SetNext */) {\n                    ctx.n = state[value];\n                }\n                else { // ChildOpCode.SetParent\n                    ctx.p = state[value];\n                    ctx.n = null;\n                }\n            }\n            ctx.p = parentDOMElement;\n        }\n        ctx.n = rootDOMNode;\n    }\n    else if (flags & 16 /* Flags.Text */) {\n        if (updateFlags & 512 /* Flags.DisplaceNode */) {\n            nodeInsertBefore.call(ctx.p, sNode.s, ctx.n);\n        }\n        ctx.n = sNode.s;\n    }\n    else if (flags & 2 /* Flags.Component */) {\n        if ((flags | updateFlags) & (64 /* Flags.Dirty */ | 256 /* Flags.ForceUpdate */)) {\n            sNode.c = _update(sNode, children, sNode.s.r(sNode.v.p), updateFlags);\n        }\n        else if (children !== null) {\n            _dirtyCheck(children, updateFlags);\n        }\n    }\n    else { // Array || List\n        let i = children.length;\n        while (--i >= 0) {\n            const sChild = children[i];\n            if (sChild !== null) {\n                _dirtyCheck(sChild, updateFlags);\n            }\n        }\n    }\n};\n/**\n * Unmounts Stateful Node.\n *\n * @param sNode Stateful Node.\n * @param detach Detach root DOM nodes from the DOM.\n */\nconst _unmount = (sNode, detach) => {\n    const flags = sNode.f;\n    if (detach === true && (flags & (1 /* Flags.Template */ | 16 /* Flags.Text */))) {\n        detach = false;\n        nodeRemoveChild.call(RENDER_CONTEXT.p, (flags & 1 /* Flags.Template */)\n            ? sNode.s[0]\n            : sNode.s);\n    }\n    const sChildren = sNode.c;\n    if (sChildren !== null) {\n        if (_isArray(sChildren)) {\n            for (let i = 0; i < sChildren.length; i++) {\n                const sChild = sChildren[i];\n                if (sChild !== null) {\n                    _unmount(sChild, detach);\n                }\n            }\n        }\n        else {\n            _unmount(sChildren, detach);\n        }\n    }\n    if (flags & 2 /* Flags.Component */) {\n        const unmountHooks = sNode.s.u;\n        if (unmountHooks !== null) {\n            if (typeof unmountHooks === \"function\") {\n                unmountHooks();\n            }\n            else {\n                for (let i = 0; i < unmountHooks.length; i++) {\n                    unmountHooks[i]();\n                }\n            }\n        }\n    }\n};\n/**\n * Update children list with track by key algorithm.\n *\n * High-level overview of the algorithm that is implemented in this function:\n *\n * This algorithm finds a minimum number of DOM operations. It works in\n * several steps:\n *\n * 1. Common prefix and suffix optimization.\n *\n * Look for nodes with identical keys by simultaneously iterating through nodes\n * in the old children list `A` and new children list `B` from both sides.\n *\n *     A: -> [a b c d] <-\n *     B: -> [a b d] <-\n *\n * Skip nodes \"a\" and \"b\" at the start, and node \"d\" at the end.\n *\n *     A: -> [c] <-\n *     B: -> [] <-\n *\n * 2. Zero length optimizations.\n *\n * Check if the size of one of the list is equal to zero. When length of the\n * old children list is zero, insert remaining nodes from the new list. When\n * length of the new children list is zero, remove remaining nodes from the old\n * list.\n *\n *     A: -> [a b c g] <-\n *     B: -> [a g] <-\n *\n * Skip nodes \"a\" and \"g\" (prefix and suffix optimization).\n *\n *     A: [b c]\n *     B: []\n *\n * Remove nodes \"b\" and \"c\".\n *\n * 3. Index and unmount removed nodes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *     P: [. . . . .] // . == -1\n *\n * Create array `P` (`sources`) with the length of the new children list and\n * fills it with `NewNodeMark` values. This mark indicates that node at this\n * position should be mounted. Later we will assign node positions in the old\n * children list to this array.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *     P: [. . . . .] // . == -1\n *     I: {\n *       c: 0, // B[0] == c\n *       b: 1, // B[1] == b\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     last = 0\n *\n * Create reverse index `I` that maps keys to node positions in the new\n * children list.\n *\n *     A: [b c d e f]\n *         ^\n *     B: [c b h f e]\n *     P: [. 0 . . .] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1, <-\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     last = 1\n *\n * Assign original positions of the nodes from the old children list to the\n * array `P`.\n *\n * Iterate through nodes in the old children list and gets their new positions\n * from the index `I`. Assign old node position to the array `P`. When index\n * `I` doesn't have a key for the old node, it means that it should be\n * unmounted.\n *\n * When we assigning positions to the array `P`, we also store position of the\n * last seen node in the new children list `pos`, if the last seen position is\n * greater than the current position of the node at the new list, then we are\n * switching `rearrangeNodes` flag to `true` (`pos === RearrangeNodes`).\n *\n *     A: [b c d e f]\n *           ^\n *     B: [c b h f e]\n *     P: [1 0 . . .] // . == -1\n *     I: {\n *       c: 0, <-\n *       b: 1,\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     last = 1 // last > 0; rearrangeNodes = true\n *\n * The last position `1` is greater than the current position of the node at the\n * new list `0`, switch `rearrangeNodes` flag to `true`.\n *\n *     A: [b c d e f]\n *             ^\n *     B: [c b h f e]\n *     P: [1 0 . . .] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1,\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     rearrangeNodes = true\n *\n * Node with key \"d\" doesn't exist in the index `I`, unmounts node `d`.\n *\n *     A: [b c d e f]\n *               ^\n *     B: [c b h f e]\n *     P: [1 0 . . 3] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1,\n *       h: 2,\n *       f: 3,\n *       e: 4, <-\n *     }\n *     rearrangeNodes = true\n *\n * Assign position `3` for `e` node.\n *\n *     A: [b c d e f]\n *                 ^\n *     B: [c b h f e]\n *     P: [1 0 . 4 3] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1,\n *       h: 2,\n *       f: 3, <-\n *       e: 4,\n *     }\n *     rearrangeNodes = true\n *\n * Assign position `4` for 'f' node.\n *\n * 4. Find minimum number of moves when `rearrangeNodes` flag is on and mount\n *    new nodes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *     P: [1 * . 4 *] // . == -1  * == -2\n *\n * When `rearrangeNodes` is on, mark all nodes in the array `P` that belong to\n * the [longest increasing subsequence](http://en.wikipedia.org/wiki/Longest_increasing_subsequence)\n * and move all nodes that doesn't belong to this subsequence.\n *\n * Iterate over the new children list and the `P` array simultaneously. When\n * value from `P` array is equal to `NewNodeMark`, mount a new node. When it\n * isn't equal to `LisMark`, move it to a new position.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *                 ^  // new_pos == 4\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *                 ^\n *\n * Node \"e\" has `LisMark` value in the array `P`, nothing changes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *               ^    // new_pos == 3\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *               ^\n *\n * Node \"f\" has `4` value in the array `P`, move it before the next node \"e\".\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *             ^      // new_pos == 2\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *             ^\n *\n * Node \"h\" has `NewNodeMark` value in the array `P`, mount new node \"h\".\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *           ^        // new_pos == 1\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *           ^\n *\n * Node \"b\" has `LisMark` value in the array `P`, nothing changes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *         ^          // new_pos == 0\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *\n * Node \"c\" has `1` value in the array `P`, move it before the next node \"b\".\n *\n * When `rearrangeNodes` flag is off, skip LIS algorithm and mount nodes that\n * have `NewNodeMark` value in the array `P`.\n *\n * NOTE: There are many variations of this algorithm that are used by many UI\n * libraries and many implementations are still using an old optimization\n * technique that were removed several years ago from this implementation. This\n * optimization were used to improve performance of simple moves/swaps. E.g.\n *\n *     A: -> [a b c] <-\n *     B: -> [c b a] <-\n *\n * Move \"a\" and \"c\" nodes to the other edge.\n *\n *     A: -> [b] <-\n *     B: -> [b] <-\n *\n * Skip node \"b\".\n *\n * This optimization were removed because it breaks invariant that insert and\n * remove operations shouldn't trigger a move operation. E.g.\n *\n *     A: -> [a b]\n *     B:    [c a] <-\n *\n * Move node \"a\" to the end.\n *\n *     A: [b]\n *     B: [c a]\n *\n * Remove node \"b\" and insert node \"c\".\n *\n * In this use case, this optimization performs one unnecessary operation.\n * Instead of removing node \"b\" and inserting node \"c\", it also moves node \"a\".\n *\n * @param sNode {@link SList} node.\n * @param a Previous {@link ListProps}.\n * @param b Next {@link ListProps}.\n * @param updateFlags Update flags.\n * @noinline\n * @__NOINLINE__\n */\nconst _updateList = (sNode, a, b, updateFlags) => {\n    const aKeys = a.k;\n    const bKeys = b.k;\n    const bVNodes = b.v;\n    let bLength = bKeys.length;\n    let aLength = aKeys.length;\n    const result = _Array(bLength);\n    if (bLength === 0) { // New children list is empty.\n        if (aLength > 0) { // Unmount nodes from the old children list.\n            _unmount(sNode, true);\n        }\n    }\n    else if (aLength === 0) { // Old children list is empty.\n        while (bLength > 0) { // Mount nodes from the new children list.\n            result[--bLength] = _mount(sNode, bVNodes[bLength]);\n        }\n    }\n    else {\n        const sChildren = sNode.c;\n        let aEnd = aLength - 1;\n        let bEnd = bLength - 1;\n        let start = 0;\n        let key = bKeys[bEnd];\n        // Step 1\n        outer: while (true) {\n            // Update nodes with the same key at the end.\n            while (aKeys[aEnd] === key) {\n                result[bEnd] = _update(sNode, sChildren[aEnd--], bVNodes[bEnd], updateFlags);\n                if (start > --bEnd || start > aEnd) {\n                    break outer;\n                }\n                key = bKeys[bEnd];\n            }\n            // Update nodes with the same key at the beginning.\n            while (aKeys[start] === bKeys[start] && ++start <= aEnd && start <= bEnd) {\n                // delayed update (all updates should be performed from right-to-left).\n            }\n            break;\n        }\n        // Step 2\n        if (start > aEnd) {\n            // All nodes from `a` are updated, insert the rest from `b`.\n            while (bEnd >= start) {\n                result[bEnd] = _mount(sNode, bVNodes[bEnd--]);\n            }\n        }\n        else if (start > bEnd) {\n            // All nodes from `b` are updated, remove the rest from `a`.\n            bLength = start;\n            do {\n                const sChild = sChildren[bLength++];\n                if (sChild !== null) {\n                    _unmount(sChild, true);\n                }\n            } while (bLength <= aEnd);\n        }\n        else { // Step 3\n            let bLength = bEnd - start + 1;\n            const sources = new _Int32Array(bLength); // Maps positions in the new children list to positions in the old list.\n            const keyIndex = new _Map(); // Maps keys to their positions in the new children list.\n            for (let i = 0; i < bLength; i++) {\n                // `NewNodeMark` value indicates that node doesn't exist in the old children list.\n                sources[i] = -1 /* MagicValues.NewNodeMark */;\n                const j = start + i;\n                keyIndex.set(bKeys[j], j);\n            }\n            // When `nodePosition === RearrangeNodes`, it means that one of the nodes is in the wrong position and we should\n            // rearrange nodes with LIS-based algorithm `markLIS()`.\n            let nodePosition = 0;\n            for (let i = start; i <= aEnd; i++) {\n                const sChild = sChildren[i];\n                const nextPosition = keyIndex.get(aKeys[i]);\n                if (nextPosition !== void 0) {\n                    nodePosition = (nodePosition < nextPosition)\n                        ? nextPosition\n                        : 1073741823 /* MagicValues.RearrangeNodes */;\n                    sources[nextPosition - start] = i;\n                    result[nextPosition] = sChild;\n                }\n                else if (sChild !== null) {\n                    _unmount(sChild, true);\n                }\n            }\n            // Step 4\n            // Mark LIS nodes only when this node weren't moved `moveNode === false` and we've detected that one of the\n            // children nodes were moved `pos === MagicValues.MovedChildren`.\n            if (!(updateFlags & 512 /* Flags.DisplaceNode */) && nodePosition === 1073741823 /* MagicValues.RearrangeNodes */) {\n                markLIS(sources);\n            }\n            while (bLength-- > 0) {\n                bEnd = bLength + start;\n                const node = bVNodes[bEnd];\n                const lisValue = sources[bLength];\n                result[bEnd] = (lisValue === -1)\n                    ? _mount(sNode, node)\n                    : _update(sNode, result[bEnd], node, updateFlags |\n                        ((nodePosition === 1073741823 /* MagicValues.RearrangeNodes */ && lisValue !== -2 /* MagicValues.LISMark */)\n                            ? 512 /* Flags.DisplaceNode */\n                            : 0));\n            }\n        }\n        // Delayed update for nodes from Step 1 (prefix only). Reconciliation algorithm always updates nodes from right to\n        // left.\n        while (start > 0) {\n            result[--start] = _update(sNode, sChildren[start], bVNodes[start], updateFlags);\n        }\n    }\n    sNode.c = result;\n};\n/**\n * Modified Longest Increased Subsequence algorithm.\n *\n * Mutates input array `a` and replaces all values that are part of LIS with -2 value.\n *\n * Constraints:\n * - Doesn't work with negative numbers. -1 values are ignored.\n * - Input array `a` should contain at least one value that is greater than -1.\n *\n * {@link http://en.wikipedia.org/wiki/Longest_increasing_subsequence}\n *\n * @example\n *\n *     const A = Int32Array.from([-1, 0, 2, 1]);\n *     markLIS(A);\n *     // A => [-1, -2, 2, -2]\n *\n * @param a Array of numbers.\n * @noinline\n * @__NOINLINE__\n */\nconst markLIS = (a) => {\n    const length = a.length;\n    const parent = new _Int32Array(length);\n    const index = new _Int32Array(length);\n    let indexLength = 0;\n    let i = 0;\n    let j;\n    let k;\n    let lo;\n    let hi;\n    // Skip -1 values at the start of the input array `a`.\n    for (; a[i] === -1 /* MagicValues.NewNodeMark */; i++) { /**/ }\n    index[0] = i++;\n    for (; i < length; i++) {\n        k = a[i];\n        if (k !== -1 /* MagicValues.NewNodeMark */) { // Ignore -1 values.\n            j = index[indexLength];\n            if (a[j] < k) {\n                parent[i] = j;\n                index[++indexLength] = i;\n            }\n            else {\n                lo = 0;\n                hi = indexLength;\n                while (lo < hi) {\n                    j = (lo + hi) >> 1;\n                    if (a[index[j]] < k) {\n                        lo = j + 1;\n                    }\n                    else {\n                        hi = j;\n                    }\n                }\n                if (k < a[index[lo]]) {\n                    if (lo > 0) {\n                        parent[i] = index[lo - 1];\n                    }\n                    index[lo] = i;\n                }\n            }\n        }\n    }\n    ;\n    // Mutate input array `a` and assign -2 value to all nodes that are part of LIS.\n    j = index[indexLength];\n    while (indexLength-- >= 0) {\n        a[j] = -2 /* MagicValues.LISMark */;\n        j = parent[j];\n    }\n};\n/**\n * Creates a HTML Template cloning factory.\n */\nexport const _h = (t) => (() => {\n    if (typeof t === \"string\") {\n        HTM_TEMPLATE.innerHTML = t;\n        t = HTM_TEMPLATE_CONTENT.firstChild;\n    }\n    return nodeCloneNode.call(t, true);\n});\n/**\n * Creates a HTML Template factory.\n */\nexport const _hN = (t) => (() => (HTM_TEMPLATE.innerHTML = t,\n    HTM_TEMPLATE_CONTENT.firstChild));\n/**\n * Creates a HTML Element factory.\n */\nexport const _hE = (t) => (() => doc.createElement(t));\n/**\n * Creates a SVG Template cloning factory.\n */\nexport const _s = (t) => (() => {\n    if (typeof t === \"string\") {\n        SVG_TEMPLATE.innerHTML = t;\n        t = SVG_TEMPLATE_CONTENT.firstChild;\n    }\n    return nodeCloneNode.call(t, true);\n});\n/**\n * Creates a SVG Template factory.\n */\nexport const _sN = (t) => (() => (SVG_TEMPLATE.innerHTML = t,\n    SVG_TEMPLATE_CONTENT.firstChild));\n/**\n * Creates a SVG Element factory.\n */\nexport const _sE = (t) => (() => doc.createElementNS(\"http://www.w3.org/2000/svg\", t));\n/**\n * Creates a template descriptor.\n */\nexport const _T = (p2, f, p, c, s, d) => ({\n    f: 1 /* Flags.Template */,\n    p1: { f, p, c, s, d },\n    p2,\n});\nexport const _t = (d, p) => ({ d, p });\n/**\n * Creates a factory that produces component nodes.\n *\n * @typeparam P Property type.\n * @param p1 Function that creates stateful render functions.\n * @param p2 Function that checks `props` for equality.\n * @returns Factory that produces component nodes.\n */\nexport const component = (p1, p2) => (p1 = { f: 2 /* Flags.Component */, p1, p2 },\n    (p) => ({ d: p1, p }));\n/**\n * Prevents triggering updates.\n */\nexport const preventUpdates = (p) => true;\n/**\n * Adds an unmount hook.\n *\n * @example\n *\n *     const Example = component((c) => {\n *       useUnmount(c, () => { console.log(\"unmounted\"); });\n *\n *       return () => null;\n *     });\n *\n * @param component Component instance.\n * @param hook Unmount hook.\n */\nexport const useUnmount = (component, hook) => {\n    const s = component.s;\n    const hooks = s.u;\n    s.u = (hooks === null)\n        ? hook\n        : (typeof hooks === \"function\")\n            ? [hooks, hook]\n            : (hooks.push(hook), hooks);\n};\n/**\n * Creates a side effect hook.\n *\n * @example\n *\n *     const Example = component((c) => {\n *       const [count, setCount] = useState(0);\n *       const timer = useEffect(c, shallowEq, ({ interval }) => {\n *         const tid = setInterval(() => { setCount(count() + 1); }, interval);\n *         return () => { clearInterval(tid); };\n *       });\n *\n *       return (interval) => (\n *         timer({ interval }),\n *\n *         htm`span.Counter ${i}`\n *       );\n *     });\n *\n * @typeparam T Hook props type.\n * @param component Component instance.\n * @param hook Side effect function.\n * @param areEqual Function that checks if input value hasn't changed.\n * @returns Side effect hook.\n */\nexport const useEffect = (component, hook, areEqual) => {\n    // var usage is intentional, see `index.js` module for an explanation.\n    var reset;\n    var prev;\n    return (next) => {\n        if (areEqual === void 0 ||\n            prev === void 0 ||\n            areEqual(prev, next) === false) {\n            if (reset !== void 0) {\n                reset();\n            }\n            RENDER_CONTEXT.e.push(() => {\n                reset = hook(next);\n                if (component !== void 0 && reset !== void 0) {\n                    useUnmount(component, () => {\n                        if (reset !== void 0) {\n                            reset();\n                        }\n                    });\n                    component = (void 0);\n                }\n            });\n        }\n        prev = next;\n    };\n};\n/**\n * Invalidates a component.\n *\n * @param c Component instance.\n */\nexport const invalidate = (c) => {\n    if (!(c.f & 64 /* Flags.Dirty */)) {\n        c.f |= 64 /* Flags.Dirty */;\n        let prev = c;\n        let parent = c.p;\n        while (parent !== null) {\n            if (parent.f & 128 /* Flags.DirtySubtree */) {\n                return;\n            }\n            parent.f |= 128 /* Flags.DirtySubtree */;\n            prev = parent;\n            parent = parent.p;\n        }\n        prev.v.d.p1(prev);\n    }\n};\n/**\n * VDescriptor for List nodes.\n */\nexport const LIST_DESCRIPTOR = { f: 4 /* Flags.List */, p1: null, p2: null };\n/**\n * Creates a dynamic list.\n *\n * @typeparam E Entry type.\n * @typeparam K Key type.\n * @param entries Entries.\n * @param getKey Get key from entry function.\n * @param render Render entry function.\n * @returns Dynamic list.\n */\nexport const List = (entries, getKey, render) => ({\n    d: LIST_DESCRIPTOR,\n    p: {\n        k: entries.map(getKey),\n        v: entries.map(render),\n    },\n});\n/**\n * Performs a Dirty Checking in a root subtree.\n *\n * @param root Stateful Root Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n */\nexport const dirtyCheck = (root, updateFlags) => {\n    while (root.f & 128 /* Flags.DirtySubtree */) {\n        root.f = 32 /* Flags.Root */;\n        if (root.c !== null) {\n            const domSlot = root.v.p;\n            RENDER_CONTEXT.p = domSlot.p;\n            RENDER_CONTEXT.n = domSlot.n;\n            _dirtyCheck(root.c, updateFlags);\n            updateFlags = 0;\n            _flushDOMEffects();\n        }\n    }\n};\n/**\n * Updates a root subtree.\n *\n * @param root Stateful Root Node.\n * @param next New Stateless Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n */\nexport const update = (root, next, updateFlags) => {\n    const domSlot = root.v.p;\n    RENDER_CONTEXT.p = domSlot.p;\n    RENDER_CONTEXT.n = domSlot.n;\n    root.f = 32 /* Flags.Root */;\n    root.c = _update(root, root.c, next, updateFlags);\n    _flushDOMEffects();\n    dirtyCheck(root, 0);\n};\n/**\n * Unmounts root node.\n *\n * @param root Stateful Root Node.\n * @param detach Detach root DOM nodes from the DOM.\n */\nexport const unmount = (root, detach) => {\n    if (root.c !== null) {\n        root.f = 32 /* Flags.Root */;\n        RENDER_CONTEXT.p = root.v.p.p;\n        _unmount(root.c, detach);\n    }\n};\n//# sourceMappingURL=index.js.map","/**\n * Creates an exponential moving average bucket.\n *\n * @param alpha Should have a range (0,1).\n * @returns {@link ExponentialMovingAverage} bucket.\n */\nexport const ema = (alpha = 0.016666666666666666 /* DefaultValues.EMAAlpha */) => ({\n    type: \"ema\",\n    alpha,\n    avg: NaN,\n    std: 0.0,\n    var: 0.0,\n    min: 0.0,\n});\nconst isNaN = Number.isNaN;\nconst sqrt = Math.sqrt;\n/**\n * Adds a sample to an exponential moving average bucket.\n *\n * @param bucket {@link ExponentialMovingAverage} bucket.\n * @param value sample.\n */\nexport const emaPush = (bucket, value) => {\n    if (isNaN(bucket.avg)) {\n        bucket.avg = value;\n        bucket.min = value;\n        return;\n    }\n    var alpha = bucket.alpha, beta = 1 - alpha;\n    bucket.var = beta * (bucket.var + (alpha * ((value - bucket.avg) ** 2)));\n    bucket.avg = (beta * bucket.avg) + (alpha * value);\n    bucket.std = sqrt(bucket.var);\n    if (value < bucket.min) {\n        bucket.min = value;\n    }\n};\n//# sourceMappingURL=index.js.map","import { createSNode, dirtyCheck, update, unmount } from \"./index.js\";\nconst _queueMicrotask = queueMicrotask;\nconst ROOT_DESCRIPTOR = {\n    // Root Descriptor should always have a `Flags.Root` flag.\n    f: 32 /* Flags.Root */,\n    // OnRootInvalidated hook\n    p1: (root) => {\n        // Schedules a microtask for dirty checking.\n        _queueMicrotask(() => {\n            dirtyCheck(root, 0);\n        });\n    },\n    // p2 should always be initialized with `null` value. This propery is\n    // initialized so that all `Descriptor` objects will have the same object\n    // shape and all call-sites that access Descriptor objects will be in a\n    // monorphic state.\n    p2: null,\n};\n/**\n * Creates a new root.\n *\n * @param p Parent DOM Element.\n * @param n Next DOM Element.\n * @returns Root Node.\n */\nexport const createRoot = (p, n = null) => (createSNode(32 /* Flags.Root */, \n// VNode object.\n{\n    // VNode descriptor should be initialized with `RootDescriptor`\n    d: ROOT_DESCRIPTOR,\n    // VNode props object contains the location in the DOM tree where subtree\n    // should be rendered.\n    p: {\n        // Parent DOM Element.\n        p,\n        // Next DOM Node.\n        n,\n    },\n}, \n// Children should always be initialized with `null` value.\nnull, \n// State `SRoot<State>` that can be used to store any value.\nnull, \n// Parent SNode should always have a `null` value.\nnull));\n/**\n * Updates a root subtree.\n *\n * @param root Root Node.\n * @param next Stateless Node.\n * @param forceUpdate Force update for all components.\n */\nexport const updateRoot = (root, next, forceUpdate = false) => {\n    update(root, next, forceUpdate === true\n        ? 256 /* Flags.ForceUpdate */\n        : 0);\n};\n/**\n * Force update for all components in a root subtree.\n *\n * @param root Root Node.\n */\nexport const forceUpdateRoot = (root) => {\n    dirtyCheck(root, 256 /* Flags.ForceUpdate */);\n};\n/**\n * Disposes a root subtree and triggers all unmount hooks.\n *\n * @param root Root Node.\n * @param detach Detach root nodes from the DOM.\n */\nexport const disposeRoot = (root, detach) => {\n    unmount(root, detach);\n};\n//# sourceMappingURL=root.js.map",null],"names":["_Object","Object","_Array","Array","_isArray","isArray","_Map","Map","_Int32Array","Int32Array","nodeProto","Node","prototype","elementProto","Element","doc","document","HTM_TEMPLATE","createElement","HTM_TEMPLATE_CONTENT","content","firstChild","nodeInsertBefore","insertBefore","nodeRemoveChild","removeChild","nodeCloneNode","cloneNode","elementSetAttribute","setAttribute","elementRemoveAttribute","removeAttribute","elementAddEventListener","addEventListener","elementRemoveEventListener","removeEventListener","getDescriptor","o","p","getOwnPropertyDescriptor","nodeGetFirstChild","get","nodeGetNextSibling","nodeSetTextContent","set","elementSetClassName","htmlElementGetStyle","HTMLElement","svgElementGetStyle","SVGElement","RENDER_CONTEXT","seal","n","si","e","createSNode","f","v","c","s","_flushDOMEffects","length","i","_updateTemplateProperties","currentElement","opCodes","strings","state","prevProps","nextProps","svg","style","op","type","dataIndex","propsIndex","next","prev","call","nodeValue","key","setProperty","_assignTemplateSlots","currentNode","offset","endOffset","ctx","enterOffset","commentNode","remove","_mountList","parentState","flags","children","vNode","sChildren","sNode","_mount","_updateArray","parentSNode","updateFlags","_unmount","prevSChildren","nextSChildren","prevLength","nextLength","sChild","_update","textNode","_dirtyCheck","descriptor","d","child","p2","r","parentElement","tplData","p1","rootDOMNode","childrenOpCodes","childrenIndex","childOpCode","value","_updateList","props","rootNode","stateOpCodes","nextNode","stateNode","childrenSize","childOpCodes","componentState","u","renderFn","createTextNode","parentDOMElement","detach","unmountHooks","a","b","aKeys","k","bKeys","bVNodes","bLength","aLength","result","aEnd","bEnd","start","outer","sources","keyIndex","j","nodePosition","nextPosition","markLIS","node","lisValue","parent","index","lo","hi","indexLength","_h","t","innerHTML","_T","_t","LIST_DESCRIPTOR","List","entries","getKey","render","map","dirtyCheck","root","domSlot","update","ema","alpha","avg","NaN","std","var","min","isNaN","Number","sqrt","Math","emaPush","bucket","beta","_queueMicrotask","queueMicrotask","ROOT_DESCRIPTOR","createRoot","updateRoot","forceUpdate","mutations","N","updateOptions","opts","location","hash","substring","split","m","parseFloat","parseInt","random","floor","randomQuery","elapsed","query","randomQueries","queries","push","EMPTY_QUERY","sortByElapsed","getTopFiveQueries","qs","slice","sort","_nextId","createDB","name","id","topFive","createState","randomUpdate","entryFormatElapsed","comps","toFixed","padStart","queryClassName","countClassName","count","_tpl_","_TPL_DATA","Cell","_tpl_2","Row","db","getDBKey","_tpl_3","Main","dbs","getElementById","dataUpdateTime","viewUpdateTime","perfMonitor","querySelector","observe","perf","performance","tick","t0","now","requestAnimationFrame"],"mappings":"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","x_google_ignoreList":[0,1,2]}