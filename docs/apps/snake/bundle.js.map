{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/vnode.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/array.ts","webpack:////home/void/w/ts/ivi/packages/ivi-scheduler/src/index.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/repeatable_task_list.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/noop.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/error.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/feature_detection.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/shortcuts.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/dom/namespaces.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/sync_events.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/context.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/sync.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/root.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/scheduler/index.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/accumulate_dispatch_targets.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/dispatch_event.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/synthetic_event.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/synthetic_native_event.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/native_event_dispatcher.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/utils.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/native_events.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/attribute_directive.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/map.ts","webpack:////home/void/w/ts/ivi/packages/ivi-html/src/index.ts","webpack:///./src/state.ts","webpack:///./src/main.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/factories.ts","webpack:////home/void/w/ts/ivi-examples/node_modules/ivi-state/src/box.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","VNode","[object Object]","flags","tag","props","className","style","this","_f","_l","_r","_c","_t","_k","_p","_i","_s","_cs","_e","events","text","children","arguments","first","prev","length","last","content","getDOMNode","vnode","unorderedArrayDeleteByIndex","array","index","pop","unorderedArrayDelete","item","indexOf","rAF","requestAnimationFrame","sMT","fn","Promise","resolve","then","runRepeatableTasks","tasks","NOOP","ERROR_HANDLERS","catchError","apply","e","forEach","h","v","opts","window","addEventListener","KeyboardEvent","MouseEvent","IOS_GESTURE_EVENT","nodeProto","Node","elementProto","Element","nodeInsertBefore","insertBefore","nodeRemoveChild","removeChild","nodeReplaceChild","replaceChild","nodeCloneNode","cloneNode","elementSetAttribute","setAttribute","elementRemoveAttribute","setAttributeNS","removeAttribute","SVG_NAMESPACE","syncEvents","a","b","h1","h2","attachEvents","detachEvents","Array","registerEventHandler","unregisterEventHandler","handler","src","add","remove","_context","setContext","context","tmp","restoreContext","getContext","_remove","parent","_detach","child","hookList","detached","_dirtyCheck","dirtyContext","instance","selector","select","dirty","_sync","update","assign","prevContext","_removeAllChildren","textContent","_instantiate","node","document","createTextNode","svg","createElementNS","createElement","syncAttrs","syncStyle","_render","render","refChild","aFlags","bFlags","aProps","bProps","data","aChild","bChild","_syncChildrenTrackByKeys","textNode","firstChild","nodeValue","descriptor","shouldUpdate","aStartVNode","bStartVNode","aEndVNode","bEndVNode","step1Synced","outer","next","nextNode","aInnerLength","bInnerLength","lastPosition","bInnerArray","explicitKeyIndex","implicitKeyIndex","Map","set","prevPositionsForB","fill","step2Synced","seq","lis","slice","result","u","j","k","bValue","setProperty","removeProperty","syncAttr","element","ROOTS","findRoot","container","find","dirtyCheck","root","current","onclick","run","_flags","_microtasks","_mutationEffects","_domLayoutEffects","_beforeMutations","_afterMutations","_frameStartTime","withSchedulerTick","inner","runMicrotasks","_handleNextFrame","time","performance","now","withNextFrame","requestNextFrame","task","push","requestDirtyCheck","accumulateDispatchTargets","target","match","contains","visitUp","parentNode","visitDown","accumulateDispatchTargetsFromVNode","handlers","count","dispatchEvent","targets","event","bubble","dispatch","dispatchEventToLocalEventHandlers","matchFlags","_dispatch","SyntheticEvent","timestamp","synthetic_native_event_SyntheticNativeEvent","native","super","createNativeEventDispatcher","options","source","listeners","incDependencies","decDependencies","deps","before","after","matchEventSource","ev","syntheticEvent","timeStamp","dispatchToListeners","preventDefault","removeEventListener","cbs","EVENT_DISPATCHER_KEY_DOWN","createNativeEventHandler","capture","state","onKeyDown","ATTRIBUTE_DIRECTIVE_SKIP_UNDEFINED","updateAutofocus","focus","AUTOFOCUS_FALSE","AUTOFOCUS_TRUE","AUTOFOCUS","map","div","attrs","css","LEFT","x","y","RIGHT","UP","DOWN","Snake","startPosition","body","grow","head","splice","Grid","rows","cols","cells","flag","pointToIndex","Math","random","addPoints","mod","cellClasses","GameView","game","keyDown","keyCode","setNewDirection","gameOver","tabIndex","autofocus","width","grid","height","component","CONTAINER","getElementById","GAME","startTime","currentTime","direction","snake","newDirection","mark","createRandomFood","dir","nextPosition","unmark","tail","move","isBodyAt","isFoodAt","tick","updateState","setTimeout"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","import { NOOP } from \"../core/noop\";\nimport { objectHasOwnProperty } from \"../core/shortcuts\";\nimport { CSSStyleProps } from \"../dom/style\";\nimport { isVoidElement } from \"../debug/dom\";\nimport { checkVNodeConstructor, checkUniqueKeys } from \"../debug/vnode\";\nimport { EventHandler } from \"../events/event_handler\";\nimport { ComponentDescriptor, Component } from \"./component\";\n\n/**\n * VNode flags.\n */\nexport const enum VNodeFlags {\n  /**\n   * VNode represents a Text node.\n   */\n  Text = 1,\n  /**\n   * VNode represents an Element node.\n   */\n  Element = 1 << 1,\n  /**\n   * VNode is using an element factory to instantiate an Element node.\n   */\n  ElementFactory = 1 << 2,\n  /**\n   * VNode represents a component.\n   */\n  Component = 1 << 3,\n  /**\n   * VNode contains children nodes.\n   */\n  Children = 1 << 4,\n  /**\n   * VNode contains a text content.\n   */\n  TextContent = 1 << 5,\n  /**\n   * VNode is using an explicit key.\n   */\n  Key = 1 << 6,\n  /**\n   * Keyed list.\n   */\n  KeyedList = 1 << 7,\n  /**\n   * Element contains events.\n   */\n  Events = 1 << 8,\n  /**\n   * VNode is an SVGElement.\n   */\n  SvgElement = 1 << 9,\n  /**\n   * Specialized VNode with an update context behavior.\n   */\n  UpdateContext = 1 << 10,\n\n  ElementIdMask = 255 << 11,\n  ElementIdOffset = 11,\n  /**\n   * Dirty checking should be stopped at this node.\n   *\n   * NOTE: It is important that this flag is `1 << 31 === -1`. It allows to use a simple `flags > 0` check in the hot\n   * path of the dirty checking instead of using two checks.\n   */\n  StopDirtyChecking = 1 << 31,\n\n  /**\n   * Flags that should match to be compatible for syncing.\n   */\n  Syncable = 0\n  | Text\n  | Element\n  | ElementFactory\n  | Component\n  | UpdateContext\n  | TextContent\n  | Key\n  | SvgElement\n  | ElementIdMask,\n}\n\n/**\n * Virtual DOM Node.\n *\n * @example\n *\n *     const vnode = div(\"div-class-name\", { id: \"div-id\" })\n *       .e(onClick((e) => console.log(\"click event\", e)))\n *       .c(\"Hello\");\n *\n * @final\n */\nexport class VNode<P = any, N = Node> {\n  /**\n   * Flags, see {@link VNodeFlags} for details.\n   */\n  _f: VNodeFlags;\n  /**\n   * Circular link to previous sibling node (left).\n   */\n  _l: VNode;\n  /**\n   * Next sibling node (right).\n   */\n  _r: VNode | null;\n  /**\n   * Children.\n   */\n  _c: VNode | string | number | null;\n  /**\n   * Tag property contains details about the type of the element.\n   */\n  _t: string | VNode | ComponentDescriptor | null;\n  /**\n   * Children syncing algorithm is using key property to match nodes. Key should be unique among its siblings.\n   */\n  _k: any;\n  /**\n   * Properties.\n   */\n  _p: P | undefined;\n  /**\n   * Reference to HTML node or Component instance.\n   *\n   * It will be available after virtual node is created or synced. Each time VNode is synced, reference will be\n   * transferred from the old VNode to the new one.\n   */\n  _i: N | Component<P> | {} | null;\n  /**\n   * Style.\n   */\n  _s: CSSStyleProps | undefined;\n  /**\n   * Class name.\n   */\n  _cs: string | undefined;\n  /**\n   * Events.\n   */\n  _e: Array<EventHandler | null> | EventHandler | null;\n  /**\n   * Factory function that was used to instantiate this node.\n   *\n   * It is used for debugging and testing purposes.\n   */\n  factory!: Function;\n\n  constructor(\n    flags: number,\n    tag: string | VNode | ComponentDescriptor<any> | null,\n    props: P | undefined,\n    className: string | undefined,\n    style: CSSStyleProps | undefined,\n  ) {\n    this._f = flags;\n    this._l = this;\n    this._r = null;\n    this._c = null;\n    this._t = tag;\n    this._k = 0;\n    this._p = props;\n    this._i = null;\n    this._s = style;\n    this._cs = className;\n    this._e = null;\n    /* istanbul ignore else */\n    if (DEBUG) {\n      checkVNodeConstructor(this);\n      this.factory = NOOP;\n    }\n  }\n\n  /**\n   * Assigns a key.\n   *\n   * Children reconciliation algorithm is using keys to match nodes. Key should be unique among its siblings.\n   *\n   * @param key - Unique key\n   * @returns this node\n   */\n  k(key: any): this {\n    this._f |= VNodeFlags.Key;\n    this._k = key;\n    return this;\n  }\n\n  /**\n   * Assign events.\n   *\n   * @param events - Events\n   * @returns this node\n   */\n  e(events: Array<EventHandler | null> | EventHandler | null): this {\n    /* istanbul ignore else */\n    if (DEBUG) {\n      if ((this._f & VNodeFlags.Text)) {\n        throw new Error(\"Failed to set events, events aren't available on text nodes\");\n      }\n    }\n    if (events !== null) {\n      this._f |= VNodeFlags.Events;\n      this._e = events;\n    }\n    return this;\n  }\n\n  /**\n   * Assigns a text content for ane Element node.\n   *\n   * @param text - Text content.\n   * @returns this node\n   */\n  t(text: string | number): this {\n    /* istanbul ignore else */\n    if (DEBUG) {\n      if (this._c !== null) {\n        throw new Error(\"Failed to set text content, VNode element is already having children\");\n      }\n      if (!(this._f & VNodeFlags.Element)) {\n        throw new Error(\"Failed to set text content, text content is available on element nodes only\");\n      }\n      if (isVoidElement(this._t as string)) {\n        throw new Error(\"Failed to set text content, void elements can't have any children\");\n      }\n      if (this._p) {\n        if (objectHasOwnProperty.call(this._p, \"unsafeHTML\")) {\n          throw new Error(\"Failed to set text content, element is using unsafeHTML attribute\");\n        }\n      }\n    }\n    this._f |= VNodeFlags.StopDirtyChecking | VNodeFlags.TextContent;\n    this._c = text;\n    return this;\n  }\n\n  /**\n   * Assigns children for an Element node.\n   *\n   * @param children - Children can be a simple string, single VNode or recursive list of VNodes with strings and null\n   *   values. It will automatically normalize recursive lists by flattening, filtering out null values and replacing\n   *   strings with text nodes.\n   * @returns this node\n   */\n  c(...children: Array<VNode | string | number | null>): this;\n  c(): this {\n    /* istanbul ignore else */\n    if (DEBUG) {\n      if (this._c !== null) {\n        throw new Error(\"Failed to set children, VNode element is already having children\");\n      }\n      if (!(this._f & VNodeFlags.Element)) {\n        throw new Error(\"Failed to set children, children are available on element nodes only\");\n      }\n      if (isVoidElement(this._t as string)) {\n        throw new Error(\"Failed to set children, void elements can't have any children\");\n      }\n      if (this._p) {\n        if (objectHasOwnProperty.call(this._p, \"unsafeHTML\")) {\n          throw new Error(\"Failed to set children, element is using unsafeHTML attribute\");\n        }\n      }\n    }\n\n    const children: Array<VNode | string | number | null> = arguments as any;\n    let first: VNode<any> | null = null;\n    let prev: VNode<any> | null = null;\n\n    for (let i = 0, p = 0; i < children.length; ++i, ++p) {\n      let n = children[i];\n\n      if (n !== null) {\n        if (typeof n !== \"object\") {\n          n = t(n);\n        }\n        const last = n._l;\n        const flags = n._f;\n        if (last === n) {\n          if ((flags & VNodeFlags.Key) === 0) {\n            n._k = p;\n          }\n        } else if ((flags & VNodeFlags.KeyedList) === 0) {\n          let c: VNode | null = n;\n          do {\n            if ((c!._f & VNodeFlags.Key) === 0) {\n              c!._k = p;\n            }\n            ++p;\n            c = c!._r;\n          } while (c !== null);\n          --p;\n        }\n\n        if (prev !== null) {\n          n._l = prev;\n          prev._r = n;\n        } else {\n          first = n;\n        }\n        prev = last;\n      }\n    }\n    if (first !== null) {\n      first._l = prev!;\n      this._f |= VNodeFlags.Children;\n      this._c = first;\n      /* istanbul ignore else */\n      if (DEBUG) {\n        checkUniqueKeys(first);\n      }\n    }\n\n    return this;\n  }\n}\n\n/**\n * Create a VNode representing a Text node.\n *\n * @param content Text content.\n * @returns VNode object.\n */\nexport const t = (content: string | number): VNode<string | number, Text> =>\n  new VNode(VNodeFlags.Text, null, content, \"\", void 0);\n\n/**\n * getDOMNode retrieves a reference to a DOM node from a VNode object.\n *\n * @param vnode - Virtual DOM node which contains reference to a DOM node.\n * @returns null if VNode doesn't have a reference to a DOM node.\n */\nexport function getDOMNode<T extends Node>(vnode: VNode): T | null {\n  if ((vnode._f & (VNodeFlags.Component | VNodeFlags.UpdateContext)) !== 0) {\n    return getDOMNode<T>(vnode._c as VNode);\n  }\n  return vnode._i as T;\n}\n\n/**\n * getComponent retrieves a reference to a Component instance from a VNode object.\n *\n * @param vnode - Virtual DOM node which contains reference to a Component instance.\n * @returns `null` if `vnode` doesn't have a reference to a Component instance\n */\nexport function getComponent<T extends Component<any>>(vnode: VNode): T | null {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if ((vnode._f & (VNodeFlags.Component | VNodeFlags.UpdateContext)) === 0) {\n      throw new Error(\"Failed to get component instance: VNode should represent a Component.\");\n    }\n  }\n  return vnode._i as T | null;\n}\n\n/**\n * stopDirtyChecking stops dirty checking process when it goes through this virtual DOM node.\n *\n * @param vnode - Virtual DOM node\n * @returns `vnode`\n */\nexport function stopDirtyChecking<N extends VNode>(vnode: N): N {\n  vnode._f |= VNodeFlags.StopDirtyChecking;\n  return vnode;\n}\n","/**\n * append pushes item to an array and automatically creates a new array when it doesn't exist.\n *\n * @param array - Array\n * @param item - Item\n * @returns Array\n */\nexport const append = <T>(array: T[] | null, item: T) => array === null ? [item] : (array.push(item), array);\n\n/**\n * unorderedArrayDeleteIndex deletes item from an array with O(1) complexity.\n *\n * It swaps item at `index` position with the last item and removes the last one.\n *\n * @param array - Array\n * @param index - Index of an item to delete\n */\nexport function unorderedArrayDeleteByIndex<T>(array: T[], index: number): void {\n  const length = array.length - 1;\n  const last = array.pop();\n  if (index !== length) {\n    array[index] = last!;\n  }\n}\n\n/**\n * unorderedArrayDelete deletes item from an array with O(1) complexity.\n *\n * It swaps item at `index` position with the last item and deletes the last one.\n *\n * @param array - Array\n * @param item - Item to delete\n */\nexport function unorderedArrayDelete<T>(array: T[], item: T): void {\n  const index = array.indexOf(item);\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (index === -1) {\n      throw new Error(`Failed to delete an item from an array, item doesn't exist in the array`);\n    }\n  }\n  unorderedArrayDeleteByIndex(array, index);\n}\n","export const rAF = requestAnimationFrame;\nexport const sMT = (fn: () => void) => { Promise.resolve().then(fn); };\n","import { unorderedArrayDeleteByIndex } from \"./array\";\n\n/**\n * RepeatableTaskList is a data structure for tasks that will be repeated until they return `true` value.\n */\nexport type RepeatableTaskList = Array<() => boolean | void>;\n\n/**\n * runRepeatableTasks runs repeatable tasks.\n *\n * @param tasks - Repeatable tasks\n */\nexport function runRepeatableTasks(tasks: RepeatableTaskList): void {\n  for (let i = 0; i < tasks.length; ++i) {\n    if (tasks[i]() === true) {\n      unorderedArrayDeleteByIndex(tasks, i--);\n    }\n  }\n}\n","/**\n * NOOP function.\n */\nexport const NOOP = () => { /**/ };\n\n/**\n * NOOP_FALSE function always returns `false` value.\n *\n * @returns `false` value.\n */\nexport const NOOP_FALSE = () => false;\n\n/**\n * NOOP_TRUE function always returns `true` value.\n *\n * @returns `true` value.\n */\nexport const NOOP_TRUE = () => true;\n","const ERROR_HANDLERS: Array<(e: any) => void> = [];\n\n/**\n * addErrorHandler adds an error handler for errors catched by functions decorated with `catchError()`.\n *\n * @param handler error handler.\n */\nexport function addErrorHandler(handler: (e: any) => void): void {\n  ERROR_HANDLERS.push(handler);\n}\n\n/**\n * catchError is a decorator that catches exceptions and invokes error handlers registered with `addErrorHandler()`.\n *\n * @noinline\n * @throws\n * @param fn - Function to decorate\n * @returns function decorated with a catchError\n */\nexport function catchError<T>(fn: (...args: any[]) => T): (...args: any[]) => T;\nexport function catchError<T>(fn: () => T): (...args: any[]) => T {\n  return function () {\n    try {\n      return fn.apply(void 0, arguments);\n    } catch (e) {\n      ERROR_HANDLERS.forEach((h) => { h(e); });\n      throw e;\n    }\n  };\n}\n","/**\n * Feature Detection is used to implement polyfills or just disable some features when browser doesn't support them.\n * For example, when browser doesn't support passive events, we can just ignore it and always use active events.\n */\n\n/* istanbul ignore next */\n/**\n * Passive event listeners are a new feature in the DOM spec that enable developers to opt-in to better scroll\n * performance by eliminating the need for scrolling to block on touch and wheel event listeners. Developers can\n * annotate touch and wheel listeners with {passive: true} to indicate that they will never invoke preventDefault.\n *\n * https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nexport const PASSIVE_EVENTS = /*#__PURE__*/((TARGET === \"electron\") ? true :\n  (() => {\n    let v = false;\n    try {\n      // Test via a getter in the options object to see if the passive property is accessed\n      const opts = Object.defineProperty({}, \"passive\", {\n        get() {\n          v = true;\n        },\n      });\n      window.addEventListener(\"test\", null as any as (ev: Event) => void, opts);\n    } catch (e) {\n      // ignore\n    }\n    return v;\n  })());\n\n/* istanbul ignore next */\n/**\n * `key` property is available on KeyboardEvent instances.\n */\nexport const KEYBOARD_EVENT_KEY = /*#__PURE__*/(\n  (TARGET === \"electron\") ||\n  (TARGET === \"evergreen\") ||\n  KeyboardEvent.prototype.hasOwnProperty(\"key\")\n);\n\n/* istanbul ignore next */\n/**\n * `buttons` property is available on MouseEvent instances.\n */\nexport const MOUSE_EVENT_BUTTONS = /*#__PURE__*/(\n  (TARGET === \"electron\") ||\n  (TARGET === \"evergreen\") ||\n  MouseEvent.prototype.hasOwnProperty(\"buttons\")\n);\n\n/* istanbul ignore next */\n/**\n * Touch Events support.\n */\nexport const TOUCH_EVENTS = (\"ontouchstart\" in window);\n\n/* istanbul ignore next */\n/**\n * Pointer Events support.\n */\nexport const POINTER_EVENTS = ((TARGET === \"electron\") || (\"PointerEvent\" in window));\n\n/* istanbul ignore next */\n/**\n * InputDeviceCapabilities support.\n *\n * http://wicg.github.io/InputDeviceCapabilities/\n */\nexport const INPUT_DEVICE_CAPABILITIES = ((TARGET === \"electron\") || \"InputDeviceCapabilities\" in window);\n\n/* istanbul ignore next */\n/**\n * iOS proprietary GestureEvent.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/GestureEvent}\n */\nexport const IOS_GESTURE_EVENT = (TARGET !== \"electron\") && (\"GestureEvent\" in window);\n","const nodeProto = Node.prototype;\nconst elementProto = Element.prototype;\n\n/**\n * Shortcut for an `Object.prototype.hasOwnProperty`.\n */\nexport const objectHasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Shortcut for a `Node.prototype.insertBefore`.\n */\nexport const nodeInsertBefore = nodeProto.insertBefore;\n\n/**\n * Shortcut for a `Node.prototype.removeChild`.\n */\nexport const nodeRemoveChild = nodeProto.removeChild;\n\n/**\n * Shortcut for a `Node.prototype.replaceChild`.\n */\nexport const nodeReplaceChild = nodeProto.replaceChild;\n\n/**\n * Shortcut for a `Node.prototype.cloneNode`.\n */\nexport const nodeCloneNode = nodeProto.cloneNode;\n\n/**\n * Shortcut for an `Element.prototype.setAttribute`.\n */\nexport const elementSetAttribute = elementProto.setAttribute;\n\n/**\n * Shortcut for an `Element.prototype.setAttributeNS`.\n */\nexport const elementSetAttributeNS = elementProto.setAttributeNS;\n\n/**\n * Shortcut for an `Element.prototype.removeAttribute`.\n */\nexport const elementRemoveAttribute = elementProto.removeAttribute;\n\n/**\n * Shortcut for an `undefined` value.\n */\nexport const _ = void 0;\n","export const SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nexport const XLINK_NAMESPACE = \"http://www.w3.org/1999/xlink\";\nexport const XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n","import { EventHandlerFlags } from \"./flags\";\nimport { EventHandler } from \"./event_handler\";\n\n/**\n * syncEvents syncs event handlers and invokes EventSource callbacks when event handler is attached or detached.\n *\n * @param a Old event handlers.\n * @param b New event handlers.\n */\nexport function syncEvents(\n  a: Array<EventHandler | null> | EventHandler | null,\n  b: Array<EventHandler | null> | EventHandler | null,\n): void {\n  let i: number;\n  let h1: EventHandler | null;\n  let h2: EventHandler | null;\n\n  if (a === null) {\n    attachEvents(b!);\n  } else if (b === null) {\n    detachEvents(a);\n  } else {\n    if (a instanceof Array) {\n      if (b instanceof Array) {\n        i = 0;\n        while (i < a.length && i < b.length) {\n          h1 = a[i];\n          h2 = b[i++];\n          if (h1 !== h2) {\n            if (h2 !== null) {\n              registerEventHandler(h2);\n            }\n            if (h1 !== null) {\n              unregisterEventHandler(h1);\n            }\n          }\n        }\n        while (i < b.length) {\n          h1 = b[i++];\n          if (h1 !== null) {\n            registerEventHandler(h1);\n          }\n        }\n        while (i < a.length) {\n          h1 = a[i++];\n          if (h1 !== null) {\n            unregisterEventHandler(h1);\n          }\n        }\n      } else {\n        registerEventHandler(b as EventHandler);\n\n        for (i = 0; i < a.length; ++i) {\n          h1 = a[i];\n          if (h1 !== null) {\n            unregisterEventHandler(h1);\n          }\n        }\n      }\n    } else {\n      attachEvents(b);\n      unregisterEventHandler(a as EventHandler);\n    }\n  }\n}\n\n/**\n * attachEvents attaches event handlers and invokes EventSource callbacks.\n *\n * @param events Event handlers.\n */\nexport function attachEvents(events: Array<EventHandler | null> | EventHandler): void {\n  if (events instanceof Array) {\n    for (let i = 0; i < events.length; ++i) {\n      const h = events[i];\n      if (h !== null) {\n        registerEventHandler(h);\n      }\n    }\n  } else {\n    registerEventHandler(events as EventHandler);\n  }\n}\n\n/**\n * detachEvents detaches events handles and invokes EventSource callbacks.\n *\n * @param events Event handlers.\n */\nexport function detachEvents(events: Array<EventHandler | null> | EventHandler): void {\n  if (events instanceof Array) {\n    for (let i = 0; i < events.length; ++i) {\n      const h = events[i];\n      if (h !== null) {\n        unregisterEventHandler(h);\n      }\n    }\n  } else {\n    unregisterEventHandler(events as EventHandler);\n  }\n}\n\n/**\n * registerEventHandler is a shortcut for Event Handler registration.\n *\n * @param handler Event Handler.\n */\nfunction registerEventHandler(handler: EventHandler<any>): void {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    handler.flags |= EventHandlerFlags.Active;\n  }\n  handler.src.add(handler);\n}\n\n/**\n * unregisterEventHandler is a shortcut for Event Handler unregistration.\n *\n * @param handler Event Handler.\n */\nfunction unregisterEventHandler(handler: EventHandler<any>): void {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    handler.flags &= ~EventHandlerFlags.Active;\n  }\n  handler.src.remove(handler);\n}\n","/**\n * Current context.\n */\nlet _context = {};\n\n/**\n * setContext assigns current context.\n *\n * Should be executed before going deeper into Context node.\n *\n * @param context - Current context.\n * @returns previous context\n */\nexport function setContext(context: {}): {} {\n  const tmp = _context;\n  _context = context;\n  return tmp;\n}\n\n/**\n * restoreContext restores previous context.\n *\n * Should be executed after processing Context node.\n *\n * @param context - Previous context.\n */\nexport function restoreContext(context: {}): void {\n  _context = context;\n}\n\n/**\n * getContext retrieves current context.\n *\n * @returns current context\n */\nexport function getContext(): {} {\n  return _context;\n}\n","import {\n  nodeRemoveChild, nodeInsertBefore, elementRemoveAttribute, elementSetAttribute, nodeCloneNode, nodeReplaceChild,\n} from \"../core/shortcuts\";\nimport { SVG_NAMESPACE } from \"../dom/namespaces\";\nimport { CSSStyleProps } from \"../dom/style\";\nimport { syncEvents, attachEvents, detachEvents } from \"../events/sync_events\";\nimport { AttributeDirective } from \"./attribute_directive\";\nimport { VNodeFlags, VNode, getDOMNode } from \"./vnode\";\nimport { ComponentDescriptor, Component } from \"./component\";\nimport { setContext, getContext, restoreContext } from \"./context\";\n\n/**\n * Removes VNode.\n *\n * @param parent - Parent DOM node\n * @param vnode - Virtual DOM node to remove\n */\nexport function _remove(parent: Node, vnode: VNode): void {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    parent.removeChild(getDOMNode(vnode)!);\n  } else {\n    nodeRemoveChild.call(parent, getDOMNode(vnode)!);\n  }\n  _detach(vnode);\n}\n\n/**\n * Recursively detach all nodes.\n *\n * @param vnode - Virtual DOM node\n */\nfunction _detach(vnode: VNode): void {\n  const flags = vnode._f;\n\n  if ((flags & (VNodeFlags.Children | VNodeFlags.Component | VNodeFlags.UpdateContext)) !== 0) {\n    let child = vnode._c as VNode | null;\n    while (child !== null) {\n      _detach(child);\n      child = child._r;\n    }\n\n    if ((flags & VNodeFlags.Component) !== 0) {\n      const hookList = (vnode._i as Component).detached;\n      if (hookList !== null) {\n        if (typeof hookList === \"function\") {\n          hookList();\n        } else {\n          for (let i = 0; i < hookList.length; i++) {\n            hookList[i](true);\n          }\n        }\n      }\n    }\n  }\n\n  if ((flags & VNodeFlags.Events) !== 0) {\n    detachEvents(vnode._e!);\n  }\n}\n\n/**\n * Recursively perform dirty checking.\n *\n * @param parent - Parent DOM Node\n * @param vnode - VNode\n * @param context - Current context\n * @param dirtyContext - Context is dirty\n */\nexport function _dirtyCheck(parent: Node, vnode: VNode, dirtyContext: boolean): void {\n  const flags = vnode._f;\n\n  if ((flags & (\n    VNodeFlags.StopDirtyChecking | // StopDirtyChecking will convert this value to -value\n    VNodeFlags.Children | VNodeFlags.Component | VNodeFlags.UpdateContext\n  )) > 0) {\n    const instance = vnode._i as Node | Component;\n    let child = vnode._c as VNode | null;\n    if ((flags & VNodeFlags.Children) !== 0) {\n      while (child !== null) {\n        _dirtyCheck(instance as Node, child, dirtyContext);\n        child = child._r;\n      }\n    } else if ((flags & VNodeFlags.Component) !== 0) {\n      const selector = (instance as Component).select;\n      if (((instance as Component).dirty === true) || (selector !== null && selector(getContext()) === true)) {\n        _sync(\n          parent,\n          child!,\n          vnode._c = DEBUG ?\n            shouldBeSingleVNode((instance as Component).update!(vnode._p)) :\n                /* istanbul ignore next */(instance as Component).update!(vnode._p),\n          dirtyContext,\n        );\n      } else {\n        _dirtyCheck(parent, child!, dirtyContext);\n      }\n    } else { // (flags & VNodeFlags.UpdateContext)\n      if (dirtyContext === true) {\n        vnode._i = { ...getContext(), ...vnode._p };\n      }\n      const prevContext = setContext(vnode._i as {});\n      _dirtyCheck(parent, child!, dirtyContext);\n      restoreContext(prevContext);\n    }\n  }\n}\n\n/**\n * Remove all children.\n *\n * `detach()` lifecycle methods will be invoked for all children and their subtrees.\n *\n * @param parent - Parent DOM element\n * @param vnode - First Virtual DOM node\n */\nfunction _removeAllChildren(parent: Node, vnode: VNode): void;\nfunction _removeAllChildren(parent: Node, vnode: VNode | null): void {\n  parent.textContent = \"\";\n  do {\n    _detach(vnode!);\n    vnode = vnode!._r;\n  } while (vnode !== null);\n}\n\n/**\n * Render virtual DOM node.\n *\n * @param parent - Parent DOM element\n * @param vnode - Virtual DOM node to render\n * @param context - Current context\n * @returns Rendered DOM Node\n */\nfunction _instantiate(parent: Node, vnode: VNode): Node {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (vnode._i !== null) {\n      throw new Error(\"VNode is already have a reference to an instance. VNodes can't be used mutliple times, \" +\n        \"clone VNode with `cloneVNode`.\");\n    }\n  }\n\n  const flags = vnode._f;\n  const props = vnode._p;\n  let instance: Node | Component | null = null;\n  let node: Node;\n\n  if ((flags & VNodeFlags.Text) !== 0) {\n    instance = node = document.createTextNode(props as string);\n  } else {\n    const tag = vnode._t;\n    if ((flags & VNodeFlags.Events) !== 0) {\n      attachEvents(vnode._e!);\n    }\n    if ((flags & VNodeFlags.Element) !== 0) {\n      const svg = (flags & VNodeFlags.SvgElement) !== 0;\n      if ((flags & VNodeFlags.ElementFactory) === 0) {\n        node = svg ?\n          document.createElementNS(SVG_NAMESPACE, tag as string) :\n          document.createElement(tag as string);\n      } else {\n        if ((tag as VNode)._i === null) {\n          _instantiate(parent, (tag as VNode));\n        }\n        /* istanbul ignore else */\n        if (DEBUG) {\n          node = ((tag as VNode)._i as Node).cloneNode(true);\n        } else {\n          node = nodeCloneNode.call((tag as VNode)._i as Node, true);\n        }\n      }\n      instance = node;\n\n      const className = vnode._cs;\n      if (className) {\n        /**\n         * SVGElement.className returns `SVGAnimatedString`\n         */\n        if (svg === true) {\n          /* istanbul ignore else */\n          if (DEBUG) {\n            (node as Element).setAttribute(\"class\", className);\n          } else {\n            elementSetAttribute.call(node as Element, \"class\", className);\n          }\n        } else {\n          (node as Element).className = className;\n        }\n      }\n\n      if (props !== void 0) {\n        syncAttrs(node as Element, void 0, props);\n      }\n      if (vnode._s !== void 0) {\n        syncStyle(node as HTMLElement, void 0, vnode._s);\n      }\n\n      if ((flags & VNodeFlags.Children) !== 0) {\n        let child = vnode._c as VNode | null;\n        while (child !== null) {\n          _render(node, null, child);\n          child = child._r;\n        }\n      } else if ((flags & VNodeFlags.TextContent) !== 0 && vnode._c !== \"\") {\n        node.textContent = vnode._c as string;\n      }\n    } else if ((flags & VNodeFlags.Component) !== 0) {\n      instance = { dirty: false, update: null, select: null, detached: null };\n      const render = (tag as ComponentDescriptor).c(instance);\n      instance.update = render;\n      node = _instantiate(\n        parent,\n        vnode._c = DEBUG ?\n          shouldBeSingleVNode(render(props)) :\n            /* istanbul ignore next */render(props),\n      );\n    } else {\n      const prevContext = setContext(instance = { ...getContext(), ...props });\n      node = _instantiate(parent, vnode._c as VNode);\n      restoreContext(prevContext);\n    }\n  }\n\n  vnode._i = instance;\n  return node;\n}\n\n/**\n * Render virtual DOM node into container and invoke `attached()` lifecycle methods after node is inserted into\n * container.\n *\n * It is important that `attached()` methods are invoked only after DOM nodes have been inserted into container, so it\n * goes twice through the entire vnode tree, first time when everything is rendered and the second time when\n * `attached()` methods are invoked.\n *\n * @param parent - Parent DOM element\n * @param refChild - Reference to the next DOM node, when it is `null` child will be inserted at the end\n * @param vnode - Virtual DOM node\n * @returns Rendered DOM Node\n */\nexport function _render(parent: Node, refChild: Node | null, vnode: VNode): void {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    parent.insertBefore(_instantiate(parent, vnode), refChild);\n  } else {\n    nodeInsertBefore.call(parent, _instantiate(parent, vnode), refChild);\n  }\n}\n\n/**\n * Sync virtual DOM nodes.\n *\n * When node `a` is synced with node `b`, `a` node should be considered as destroyed, and any access to it after sync\n * is an undefined behavior.\n *\n * @param parent - Parent DOM element\n * @param a - Previous virtual DOM node\n * @param b - Next virtual DOM node\n * @param context - Current context\n * @param dirtyContext - Context is dirty\n */\nexport function _sync(parent: Node, a: VNode, b: VNode, dirtyContext: boolean): void {\n  if (a === b) {\n    _dirtyCheck(parent, b, dirtyContext);\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (b._i !== null) {\n      throw new Error(\"VNode is already have a reference to an instance. VNodes can't be used mutliple times\");\n    }\n  }\n\n  let instance;\n  const aFlags = a._f;\n  const bFlags = b._f;\n  if (\n    (((aFlags ^ bFlags) & VNodeFlags.Syncable) === 0) &&\n    ((aFlags & (VNodeFlags.ElementFactory | VNodeFlags.Component)) === 0 || a._t === b._t) &&\n    (a._k === b._k)\n  ) {\n    const aProps = a._p;\n    const bProps = b._p;\n    b._i = instance = a._i;\n\n    if ((bFlags & VNodeFlags.Text) !== 0) {\n      if (aProps !== bProps) {\n        (instance as Text).data = bProps as string;\n      }\n    } else {\n      const aChild = a._c;\n      let bChild = b._c;\n\n      if (a._e !== b._e) {\n        syncEvents(a._e, b._e);\n      }\n\n      if ((bFlags & VNodeFlags.Element) !== 0) {\n        let className = b._cs;\n        if (a._cs !== className) {\n          if (className === void 0) {\n            className = \"\";\n          }\n          if ((bFlags & VNodeFlags.SvgElement) !== 0) {\n            /* istanbul ignore else */\n            if (DEBUG) {\n              (instance as Element).setAttribute(\"class\", className);\n            } else {\n              elementSetAttribute.call(instance, \"class\", className);\n            }\n          } else {\n            (instance as Element).className = className;\n          }\n        }\n\n        if (aProps !== bProps) {\n          syncAttrs(instance as Element, aProps, bProps);\n        }\n        if (a._s !== b._s) {\n          syncStyle(instance as HTMLElement, a._s, b._s);\n        }\n\n        if (aChild !== bChild) {\n          if ((aFlags & VNodeFlags.TextContent) === 0) {\n            if (aChild === null) {\n              do {\n                _render(instance as Element, null, bChild as VNode);\n                bChild = (bChild as VNode)._r;\n              } while (bChild !== null);\n            } else if (bChild === null) {\n              _removeAllChildren(instance as Element, aChild as VNode);\n            } else {\n              _syncChildrenTrackByKeys(instance as Element, aChild as VNode, bChild as VNode, dirtyContext);\n            }\n          } else {\n            const textNode = (instance as Element).firstChild as Text | null;\n            if (textNode !== null) {\n              textNode.nodeValue = bChild as string;\n            } else {\n              (instance as Element).textContent = bChild as string;\n            }\n          }\n        }\n      } else { // (VNodeFlags.Component | VNodeFlags.UpdateContext)\n        if ((bFlags & VNodeFlags.Component) !== 0) {\n          const descriptor = b._t as ComponentDescriptor;\n\n          if (\n            ((instance as Component).dirty === true) ||\n            (\n              (aProps !== bProps) &&\n              (descriptor.shouldUpdate === void 0 || descriptor.shouldUpdate(aProps, bProps) === true)\n            )\n          ) {\n            _sync(\n              parent,\n              aChild as VNode,\n              b._c = DEBUG ?\n                shouldBeSingleVNode((instance as Component).update!(bProps)) :\n                /* istanbul ignore next */(instance as Component).update!(bProps),\n              dirtyContext,\n            );\n            (instance as Component).dirty = false;\n          } else {\n            b._c = aChild as VNode;\n            _dirtyCheck(parent, b, dirtyContext);\n          }\n        } else { // ((bFlags & VNodeFlags.UpdateContext) !== 0)\n          if (aProps !== bProps || dirtyContext === true) {\n            instance = { ...getContext(), ...bProps };\n            dirtyContext = true;\n          }\n          b._i = instance as {};\n          const context = setContext(instance);\n          _sync(parent, aChild as VNode, bChild as VNode, dirtyContext);\n          restoreContext(context);\n        }\n      }\n    }\n  } else {\n    /* istanbul ignore else */\n    if (DEBUG) {\n      parent.replaceChild(_instantiate(parent, b), getDOMNode(a)!);\n    } else {\n      nodeReplaceChild.call(parent, _instantiate(parent, b), getDOMNode(a)!);\n    }\n    _detach(a);\n  }\n}\n\n/**\n * Sync children.\n *\n * High-level overview of the algorithm that is implemented in this function (this overview doesn't include some details\n * how it handles nodes with implicit keys and many small tricks to reduce memory allocations and unnecessary work).\n *\n * This algorithm finds a minimum[1] number of DOM operations. It works in several steps:\n *\n * 1. Find common suffix and prefix.\n *\n * This optimization technique is searching for nodes with identical keys by simultaneously iterating over nodes in the\n * old children list `A` and new children list `B` from both sides:\n *\n *  A: -> [a b c d] <-\n *  B: -> [a b d] <-\n *\n * Here we can skip nodes \"a\" and \"b\" at the begininng, and node \"d\" at the end.\n *\n *  A: -> [c] <-\n *  B: -> [] <-\n *\n * Here it will check if the size of one of the list is equal to zero. When length of the old children list is zero,\n * it will insert all remaining nodes from the new list, and when length of the new children list is zero, it will\n * remove all remaining nodes from the old list.\n *\n * When algorithm can't find a solution with this simple optimization technique, it will go to the next step of the\n * algorithm. For example:\n *\n *  A: -> [a b c d e f g] <-\n *  B: -> [a c b h f e g] <-\n *\n * Nodes \"a\" and \"g\" at the edges are the same, skipping them.\n *\n *  A: -> [b c d e f] <-\n *  B: -> [c b h f e] <-\n *\n * Here we are stuck, so we need to switch to the next step.\n *\n * 2. Look for removed and inserted nodes, and simultaneously check if one of the nodes is moved.\n *\n * First we create an array `P` with the length of the new children list and assign to each position value `-1`, it has\n * a meaning of a new node that should be inserted. Later we will assign node positions in the old children list to this\n * array.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [. . . . .] // . == -1\n *\n * Then we need to build an index `I` that maps keys with node positions of the remaining nodes from the new children\n * list.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [. . . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 0\n *\n * With this index, we start to iterate over the remaining nodes from the old children list and check if we can find a\n * node with the same key in the index. If we can't find any node, it means that it should be removed, otherwise we\n * assign position of the node in the old children list to the positions array.\n *\n *  A: [b c d e f]\n *      ^\n *  B: [c b h f e]\n *  P: [. 0 . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1, <-\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 1\n *\n * When we assigning positions to the positions array, we also keep a position of the last seen node in the new children\n * list, if the last seen position is larger than current position of the node at the new list, then we are switching\n * `moved` flag to `true`.\n *\n *  A: [b c d e f]\n *        ^\n *  B: [c b h f e]\n *  P: [1 0 . . .] // . == -1\n *  I: {\n *    c: 0, <-\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 1 // last > 0; moved = true\n *\n * The last position `1` is larger than current position of the node at the new list `0`, switching `moved` flag to\n * `true`.\n *\n *  A: [b c d e f]\n *          ^\n *  B: [c b h f e]\n *  P: [1 0 . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  moved = true\n *\n * Node with key \"d\" doesn't exist in the index, removing node.\n *\n *  A: [b c d e f]\n *            ^\n *  B: [c b h f e]\n *  P: [1 0 . . 3] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4, <-\n *  }\n *  moved = true\n *\n * Assign position for `e`.\n *\n *  A: [b c d e f]\n *              ^\n *  B: [c b h f e]\n *  P: [1 0 . 4 3] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3, <-\n *    e: 4,\n *  }\n *  moved = true\n *\n * Assign position for 'f'.\n *\n * At this point we are checking if `moved` flag is on, or if the length of the old children list minus the number of\n * removed nodes isn't equal to the length of the new children list. If any of this conditions is true, then we are\n * going to the next step.\n *\n * 3. Find minimum number of moves if `moved` flag is on, or insert new nodes if the length is changed.\n *\n * When `moved` flag is on, we need to find the\n * [longest increasing subsequence](http://en.wikipedia.org/wiki/Longest_increasing_subsequence) in the positions array,\n * and move all nodes that doesn't belong to this subsequence.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *  moved = true\n *\n * Now we just need to simultaneously iterate over the new children list and LIS from the end and check if the current\n * position is equal to a value from LIS.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *              ^  // new_pos == 4\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *              ^  // new_pos == 4\n *  moved = true\n *\n * Node \"e\" stays at the same place.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *            ^    // new_pos == 3\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *            ^    // new_pos != 1\n *  moved = true\n *\n * Node \"f\" is moved, move it before the next node \"e\".\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *          ^      // new_pos == 2\n *  P: [1 0 . 4 3] // . == -1\n *          ^      // old_pos == -1\n *  LIS:     [1 4]\n *            ^\n *  moved = true\n *\n * Node \"h\" has a `-1` value in the positions array, insert new node \"h\".\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *        ^        // new_pos == 1\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *            ^    // new_pos == 1\n *  moved = true\n *\n * Node \"b\" stays at the same place.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *      ^          // new_pos == 0\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *          ^      // new_pos != undefined\n *  moved = true\n *\n * Node \"c\" is moved, move it before the next node \"b\".\n *\n * When moved flag is off, we don't need to find LIS, and we just iterate over the new children list and check its\n * current position in the positions array, if it is `-1`, then we insert new node.\n *\n * [1] Actually it is almost minimum number of dom ops, when node is removed and another one is inserted at the same\n * place, instead of insert and remove dom ops, we can use one replace op. It will make everything even more\n * complicated, and other use cases will be slower, so I don't think that it is worth to use replace here.\n *\n * @param parent - Parent DOM element\n * @param aStartVNode - Previous virtual DOM node\n * @param bStartVNode - Next virtual DOM node\n * @param dirtyContext - Context is dirty\n */\nfunction _syncChildrenTrackByKeys(\n  parent: Node,\n  aStartVNode: VNode,\n  bStartVNode: VNode,\n  dirtyContext: boolean,\n): void;\nfunction _syncChildrenTrackByKeys(\n  parent: Node,\n  aStartVNode: VNode | null, // should not be null, it is a workaroud to slightly reduce code size\n  bStartVNode: VNode | null, // should not be null, it is a workaroud to slightly reduce code size\n  dirtyContext: boolean,\n): void {\n  let aEndVNode = aStartVNode!._l!;\n  let bEndVNode = bStartVNode!._l!;\n  let i: number | undefined = 0;\n  let step1Synced = 0;\n\n  // Step 1\n  outer: while (1) {\n    // Sync nodes with the same key at the beginning.\n    while (\n      (aStartVNode!._k === bStartVNode!._k) &&\n      (((aStartVNode!._f ^ bStartVNode!._f) & VNodeFlags.Key) === 0)\n    ) {\n      _sync(parent, aStartVNode!, bStartVNode!, dirtyContext);\n      step1Synced++;\n      if (aStartVNode === aEndVNode) {\n        i = 1;\n      } else {\n        aStartVNode = aStartVNode!._r;\n      }\n      if (bStartVNode === bEndVNode) {\n        i |= 2;\n        break outer;\n      } else {\n        bStartVNode = bStartVNode!._r;\n      }\n      if (i) {\n        break outer;\n      }\n    }\n\n    // Sync nodes with the same key at the end.\n    while (\n      (aEndVNode!._k === bEndVNode!._k) &&\n      (((aEndVNode!._f ^ bEndVNode!._f) & VNodeFlags.Key) === 0)\n    ) {\n      _sync(parent, aEndVNode, bEndVNode, dirtyContext);\n      step1Synced++;\n      if (aStartVNode === aEndVNode) {\n        i = 1;\n      } else {\n        aEndVNode = aEndVNode._l;\n      }\n      if (bStartVNode === bEndVNode) {\n        i |= 2;\n        break outer;\n      } else {\n        bEndVNode = bEndVNode._l;\n      }\n      if (i) {\n        break outer;\n      }\n    }\n\n    break;\n  }\n\n  if (i) {\n    if (i < 3) {\n      if (i < 2) {\n        // All nodes from a are synced, insert the rest from b.\n        const next = nextNode(bEndVNode);\n        while (1) {\n          _render(parent, next, bStartVNode!);\n          if (bStartVNode === bEndVNode) {\n            break;\n          }\n          bStartVNode = bStartVNode!._r;\n        }\n      } else {\n        // All nodes from b are synced, remove the rest from a.\n        while (1) {\n          _remove(parent, aStartVNode!);\n          if (aStartVNode === aEndVNode) {\n            break;\n          }\n          aStartVNode = aStartVNode!._r;\n        }\n      }\n    }\n  } else { // Step 2\n    // Inner length after prefix/suffix optimization.\n    let aInnerLength = 0;\n    let bInnerLength = 0;\n\n    // When lastPosition === 1000000000, it means that one of the nodes in the wrong position.\n    let lastPosition = 0;\n\n    const bInnerArray: VNode[] = [];\n    // Reverse indexes for keys.\n    let explicitKeyIndex: Map<any, number> | undefined;\n    let implicitKeyIndex: Map<number, number> | undefined;\n    let key;\n\n    // Temporary vnode\n    let vnode = bStartVNode;\n    while (1) {\n      key = vnode!._k;\n      if (vnode!._f & VNodeFlags.Key) {\n        if (explicitKeyIndex === void 0) {\n          explicitKeyIndex = new Map<any, number>();\n        }\n        explicitKeyIndex.set(key, bInnerLength);\n      } else {\n        if (implicitKeyIndex === void 0) {\n          implicitKeyIndex = new Map<number, number>();\n        }\n        implicitKeyIndex.set(key, bInnerLength);\n      }\n      bInnerArray[bInnerLength++] = vnode!;\n      if (vnode === bEndVNode) {\n        break;\n      }\n      vnode = vnode!._r;\n    }\n\n    // Mark all nodes as inserted (-1).\n    const prevPositionsForB = new Array<number>(bInnerLength).fill(-1);\n\n    let step2Synced = 0;\n    vnode = aStartVNode;\n    while (1) {\n      key = vnode!._k;\n      i = (vnode!._f & VNodeFlags.Key) !== 0 ?\n        explicitKeyIndex === void 0 ? void 0 : explicitKeyIndex.get(key) :\n        implicitKeyIndex === void 0 ? void 0 : implicitKeyIndex.get(key);\n\n      if (i === void 0) {\n        vnode!._k = null;\n      } else {\n        lastPosition = (lastPosition > i) ? 1000000000 : i;\n        prevPositionsForB[i] = aInnerLength;\n        _sync(parent, vnode!, bInnerArray[i], dirtyContext);\n        step2Synced++;\n      }\n      aInnerLength++;\n      if (vnode === aEndVNode) {\n        break;\n      }\n      vnode = vnode!._r;\n    }\n\n    if (!step1Synced && !step2Synced) {\n      // Noone is synced, remove all children with one dom op.\n      _removeAllChildren(parent, aStartVNode!);\n      do {\n        _render(parent, null, bStartVNode!);\n        bStartVNode = bStartVNode!._r;\n      } while (bStartVNode !== null);\n    } else {\n      i = aInnerLength - step2Synced;\n      while (i > 0) {\n        if (aStartVNode!._k === null) {\n          _remove(parent, aStartVNode!);\n          i--;\n        }\n        aStartVNode = aStartVNode!._r;\n      }\n\n      // Step 3\n      if (lastPosition === 1000000000) {\n        const seq = lis(prevPositionsForB);\n        i = seq.length - 1;\n        while (bInnerLength > 0) {\n          if (prevPositionsForB[--bInnerLength] < 0) {\n            _render(parent, nextNode(bEndVNode), bEndVNode);\n          } else {\n            if (i < 0 || bInnerLength !== seq[i]) {\n              /* istanbul ignore else */\n              if (DEBUG) {\n                parent.insertBefore(getDOMNode(bEndVNode)!, nextNode(bEndVNode));\n              } else {\n                nodeInsertBefore.call(parent, getDOMNode(bEndVNode)!, nextNode(bEndVNode));\n              }\n            } else {\n              i--;\n            }\n          }\n          bEndVNode = bEndVNode._l;\n        }\n      } else if (step2Synced !== bInnerLength) {\n        while (bInnerLength > 0) {\n          if (prevPositionsForB[--bInnerLength] < 0) {\n            _render(parent, nextNode(bEndVNode), bEndVNode);\n          }\n          bEndVNode = bEndVNode._l;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Retrieves a next DOM node from a virtual DOM node.\n *\n * @param vnode - Virtual DOM node\n * @returns Next DOM node\n */\nfunction nextNode(vnode: VNode): Node | null {\n  const next = vnode._r;\n  return next === null ? null : getDOMNode(next);\n}\n\n/**\n * Slightly modified Longest Increased Subsequence algorithm, it ignores items that have -1 value, they're representing\n * new items.\n *\n * {@link http://en.wikipedia.org/wiki/Longest_increasing_subsequence}\n *\n * @param a - Array of numbers\n * @returns Longest increasing subsequence\n * @noinline\n */\nfunction lis(a: number[]): number[] {\n  const p = a.slice();\n  const result: number[] = [];\n  result[0] = 0;\n  let n = 0;\n  let u: number;\n  let v: number;\n  let j: number;\n\n  for (let i = 0; i < a.length; ++i) {\n    const k = a[i];\n    if (k === -1) {\n      continue;\n    }\n\n    j = result[n];\n    if (a[j] < k) {\n      p[i] = j;\n      result[++n] = i;\n      continue;\n    }\n\n    u = 0;\n    v = n;\n\n    while (u < v) {\n      j = ((u + v) / 2) | 0;\n      if (a[result[j]] < k) {\n        u = j + 1;\n      } else {\n        v = j;\n      }\n    }\n\n    if (k < a[result[u]]) {\n      if (u > 0) {\n        p[i] = result[u - 1];\n      }\n      result[u] = i;\n    }\n  }\n\n  v = result[n];\n\n  while (n >= 0) {\n    result[n--] = v;\n    v = p[v];\n  }\n\n  return result;\n}\n\n/**\n * Sync DOM styles.\n *\n * @param node - HTML or SVG Element\n * @param a - Prev styles\n * @param b - Next styles\n */\nfunction syncStyle(\n  node: HTMLElement | SVGElement,\n  a: CSSStyleProps | undefined,\n  b: CSSStyleProps | undefined,\n): void {\n  const style = node.style;\n  let key: string;\n  let bValue;\n\n  if (a === void 0) {\n    // a is empty, insert all styles from b.\n    for (key in b!) {\n      bValue = (b as { [key: string]: string })[key];\n      if (bValue !== void 0) {\n        style.setProperty(key, bValue);\n      }\n    }\n  } else if (b !== void 0) {\n    for (key in b) {\n      bValue = (b as { [key: string]: string })[key];\n      if ((a as { [key: string]: string })[key] !== bValue) {\n        if (bValue !== void 0) {\n          style.setProperty(key, bValue);\n        } else {\n          style.removeProperty(key);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Set DOM attribute.\n *\n * @param element - DOM Element\n * @param key - Attribute name\n * @param prev - Previous value\n * @param next - Next value\n */\nfunction syncAttr(\n  element: Element,\n  key: string,\n  prev: string | number | boolean | AttributeDirective<any> | undefined,\n  next: string | number | boolean | AttributeDirective<any> | undefined,\n): void {\n  if (prev !== next) {\n    if (typeof next === \"object\") {\n      next.u(\n        element,\n        key,\n        prev === void 0 ? void 0 : (prev as AttributeDirective<any>).v,\n        next.v,\n      );\n    } else {\n      if (typeof next === \"boolean\") {\n        next = next ? \"\" : void 0;\n      }\n      if (next === void 0) {\n        elementRemoveAttribute.call(element, key);\n      } else {\n        elementSetAttribute.call(element, key, next);\n      }\n    }\n  }\n}\n\n/**\n * Sync DOM attributes.\n *\n * @param element - DOM element\n * @param a - Prev DOM properties\n * @param b - Next DOM properties\n */\nfunction syncAttrs(\n  element: Element,\n  a: { [key: string]: string | number | boolean | AttributeDirective<any> | undefined } | undefined,\n  b: { [key: string]: string | number | boolean | AttributeDirective<any> | undefined } | undefined,\n): void {\n  let key: string;\n\n  if (a === void 0) {\n    // a is empty, insert all attributes from b.\n    for (key in b!) {\n      syncAttr(element, key, void 0, b![key]);\n    }\n  } else if (b !== void 0) {\n    for (key in b) {\n      syncAttr(element, key, a[key], b[key]);\n    }\n  }\n}\n\n/**\n * Check virtual DOM node returned from a `render()` function in `DEBUG` mode.\n *\n * @param vnode - Virtual DOM node\n * @return `vnode`\n */\nfunction shouldBeSingleVNode<T extends VNode>(vnode: T): T {\n  if (vnode._l !== vnode) {\n    throw new Error(\"Invalid render function. Render function should return singular VNode.\");\n  }\n  return vnode;\n}\n","import { IOS_GESTURE_EVENT } from \"../core/feature_detection\";\nimport { NOOP } from \"../core/noop\";\nimport { unorderedArrayDelete } from \"../core/array\";\nimport { checkNestingViolations } from \"../debug/html_nesting_rules\";\nimport { VNode } from \"./vnode\";\nimport { _render, _sync, _remove, _dirtyCheck } from \"./sync\";\n\n/**\n * Root.\n */\nexport interface Root {\n  /**\n   * Container element.\n   */\n  container: Element;\n  /**\n   * Next virtual DOM node.\n   */\n  next: VNode | null | undefined;\n  /**\n   * Current virtual DOM node.\n   */\n  current: VNode | null;\n}\n\n/**\n * Root nodes.\n */\nexport const ROOTS = [] as Root[];\n\n/**\n * Find root node of a container.\n *\n * @param container - DOM Node that contains root node\n * @returns root node or undefined when root node doesn't exist\n */\nexport const findRoot = (container: Element) => ROOTS.find((r) => r.container === container);\n\n/**\n * Performs a dirty checking.\n */\nexport function dirtyCheck() {\n  for (let i = 0; i < ROOTS.length; ++i) {\n    const root = ROOTS[i];\n    const { container, current, next } = root;\n    root.next = void 0;\n\n    if (next) {\n      if (current) {\n        _sync(container, current, next, false);\n      } else {\n        _render(container, null, next);\n        /* istanbul ignore if */\n        /**\n         * Fix for the Mouse Event bubbling on iOS devices.\n         *\n         * #quirks\n         *\n         * http://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n         */\n        if (TARGET === \"browser\" && IOS_GESTURE_EVENT) {\n          (container as HTMLElement).onclick = NOOP;\n        }\n      }\n      root.current = next;\n    } else if (current) {\n      if (next === null) {\n        _remove(container, current);\n        unorderedArrayDelete(ROOTS, root);\n        --i;\n      } else {\n        _dirtyCheck(container, current, false);\n      }\n    }\n\n    /* istanbul ignore else */\n    if (DEBUG) {\n      if (root.current) {\n        checkNestingViolations(container, root.current);\n      }\n    }\n  }\n}\n","import { sMT, rAF } from \"ivi-scheduler\";\nimport { runRepeatableTasks, RepeatableTaskList } from \"../core/repeatable_task_list\";\nimport { NOOP } from \"../core/noop\";\nimport { catchError } from \"../core/error\";\nimport { printWarn } from \"../debug/print\";\nimport { VNode } from \"../vdom/vnode\";\nimport { Component } from \"../vdom/component\";\nimport { ROOTS, findRoot, dirtyCheck } from \"../vdom/root\";\n\n/**\n * Update flags.\n */\nexport const enum UpdateFlags {\n  /**\n   * Forces synchronous update.\n   */\n  RequestSyncUpdate = 1,\n}\n\n/**\n * Scheduler flags.\n */\nconst enum SchedulerFlags {\n  /**\n   * Running inside of a scheduler context.\n   */\n  Running = 1,\n  /**\n   * Scheduler tick is pending for an execution.\n   */\n  TickPending = 1 << 1,\n  /**\n   * Frame update is pending for an execution.\n   */\n  NextFramePending = 1 << 2,\n  /**\n   * Sync Frame update is pending for an execution.\n   */\n  NextSyncFramePending = 1 << 3,\n  /**\n   * Running inside of a frame update context.\n   */\n  UpdatingFrame = 1 << 4,\n  /**\n   * Dirty checking is pending for an execution.\n   */\n  DirtyCheckPending = 1 << 5,\n}\n\nconst enum SchedulerDebugFlags {\n  DirtyCheckingFinished = 1,\n  MutationsFinished = 1 << 1,\n  LayoutFinished = 1 << 2,\n}\n\n/**\n * Task list.\n */\ninterface TaskList { v: Array<() => void>; }\n\n/**\n * createTaskList creates a task list.\n *\n * @returns task list\n */\nconst createTaskList = () => ({ v: [] }) as TaskList;\n\n/**\n * Execute tasks from the `TaskList`.\n *\n * @param t - Task list\n */\nfunction run(t: TaskList) {\n  while (t.v.length > 0) {\n    const tasks = t.v;\n    let i = 0;\n    t.v = [];\n    do {\n      tasks[i++]();\n    } while (i < tasks.length);\n  }\n}\n\nlet _flags: SchedulerFlags = 0;\nlet _debugFlags: SchedulerDebugFlags;\n/** istanbul ignore else */\nif (DEBUG) {\n  _debugFlags = 0;\n}\nlet _clock = 1;\nconst _microtasks = createTaskList();\nconst _mutationEffects = createTaskList();\nconst _domLayoutEffects = createTaskList();\nconst _beforeMutations = [] as RepeatableTaskList;\nconst _afterMutations = [] as RepeatableTaskList;\nlet _frameStartTime = 0;\n\n/**\n * withSchedulerTick wraps `inner` function into a scheduler context execution.\n *\n * @param inner - Inner function.\n * @returns function that will be executed in a scheduler context.\n */\nexport const withSchedulerTick = <T extends any[]>(inner: (...args: T) => void) => (\n  catchError(function () {\n    _flags |= SchedulerFlags.Running;\n    inner.apply(void 0, arguments);\n    run(_microtasks);\n    _flags &= ~(SchedulerFlags.Running | SchedulerFlags.TickPending);\n    ++_clock;\n  })\n) as (...args: T) => void;\n\nconst runMicrotasks = withSchedulerTick(NOOP);\n\n/**\n * clock returns monotonically increasing clock value.\n *\n * @returns current clock value.\n */\nexport const clock = () => _clock;\n\n/**\n * scheduleMicrotask adds task to the microtask queue.\n *\n * @param task - Microtask.\n */\nexport function scheduleMicrotask(task: () => void): void {\n  _microtasks.v.push(task);\n  if ((_flags & (SchedulerFlags.Running | SchedulerFlags.TickPending)) === 0) {\n    _flags |= SchedulerFlags.TickPending;\n    sMT(runMicrotasks);\n  }\n}\n\n/**\n * beforeMutations adds a hook that will be executed before DOM mutations.\n *\n * @param fn - hook.\n */\nexport function beforeMutations(fn: () => boolean | void): void {\n  _beforeMutations.push(fn);\n}\n\n/**\n * afterMutations adds a hook that will be executed after DOM mutations.\n *\n * @param fn - hook.\n */\nexport function afterMutations(fn: () => boolean | void): void {\n  _afterMutations.push(fn);\n}\n\n/**\n * frameStartTime returns current frame start time.\n *\n * @returns current frame start time.\n */\nexport const frameStartTime = () => _frameStartTime;\n\n/**\n * withNextFrame wraps `inner` function into a scheduler frame update context.\n *\n * @param inner - Inner function.\n * @returns function that will be executed in a frame update context.\n */\nexport const withNextFrame = (inner: (time?: number) => void) => (\n  withSchedulerTick((time?: number) => {\n    _flags |= SchedulerFlags.UpdatingFrame;\n    inner(time);\n\n    if ((_flags & SchedulerFlags.NextFramePending) !== 0) {\n      _frameStartTime = time === void 0 ? performance.now() : time;\n\n      runRepeatableTasks(_beforeMutations);\n      if ((_flags & SchedulerFlags.DirtyCheckPending) !== 0) {\n        dirtyCheck();\n      }\n      /** istanbul ignore else */\n      if (DEBUG) {\n        _debugFlags |= SchedulerDebugFlags.DirtyCheckingFinished;\n      }\n      run(_mutationEffects);\n      /** istanbul ignore else */\n      if (DEBUG) {\n        _debugFlags |= SchedulerDebugFlags.MutationsFinished;\n      }\n      runRepeatableTasks(_afterMutations);\n      run(_domLayoutEffects);\n      /** istanbul ignore else */\n      if (DEBUG) {\n        _debugFlags |= SchedulerDebugFlags.LayoutFinished;\n      }\n    }\n    _flags &= ~(\n      SchedulerFlags.UpdatingFrame |\n      SchedulerFlags.NextFramePending |\n      SchedulerFlags.NextSyncFramePending |\n      SchedulerFlags.DirtyCheckPending\n    );\n    /** istanbul ignore else */\n    if (DEBUG) {\n      _debugFlags &= ~(\n        SchedulerDebugFlags.DirtyCheckingFinished |\n        SchedulerDebugFlags.MutationsFinished |\n        SchedulerDebugFlags.LayoutFinished\n      );\n    }\n  })\n);\n\n/**\n * Frame tasks scheduler event handler.\n *\n * @param t Current time.\n */\nconst _handleNextFrame = withNextFrame(NOOP);\n\n/**\n * requestNextFrame requests an update for next frame.\n */\nexport function requestNextFrame(flags?: UpdateFlags): void {\n  if (\n    (flags !== void 0) &&\n    ((flags & UpdateFlags.RequestSyncUpdate) !== 0) &&\n    ((_flags & SchedulerFlags.NextSyncFramePending) === 0)\n  ) {\n    _flags |= SchedulerFlags.NextFramePending | SchedulerFlags.NextSyncFramePending;\n    if ((_flags & SchedulerFlags.UpdatingFrame) === 0) {\n      scheduleMicrotask(_handleNextFrame);\n    }\n  } else if ((_flags & SchedulerFlags.NextFramePending) === 0) {\n    _flags |= SchedulerFlags.NextFramePending;\n    if ((_flags & SchedulerFlags.UpdatingFrame) === 0) {\n      rAF(_handleNextFrame);\n    }\n  }\n}\n\n/**\n * Adds a write DOM task to the queue.\n *\n * @param fn - Write DOM task\n */\nexport function scheduleMutationEffect(fn: () => void, flags?: UpdateFlags): void {\n  /** istanbul ignore else */\n  if (DEBUG) {\n    if (_flags & SchedulerFlags.UpdatingFrame) {\n      if (_debugFlags & SchedulerDebugFlags.MutationsFinished) {\n        printWarn(\"Mutation effect is scheduled after mutations were finished\");\n      }\n    }\n  }\n  _mutationEffects.v.push(fn);\n  requestNextFrame(flags);\n}\n\n/**\n * Adds a DOM layout task to the queue.\n *\n * @param fn - Read DOM task\n */\nexport function scheduleLayoutEffect(fn: () => void, flags?: UpdateFlags): void {\n  /** istanbul ignore else */\n  if (DEBUG) {\n    if (_flags & SchedulerFlags.UpdatingFrame) {\n      if (_debugFlags & SchedulerDebugFlags.MutationsFinished) {\n        printWarn(\"Layout effect is scheduled after layout were finished\");\n      }\n    }\n  }\n  _domLayoutEffects.v.push(fn);\n  requestNextFrame(flags);\n}\n\nexport function requestDirtyCheck(flags?: UpdateFlags) {\n  /** istanbul ignore else */\n  if (DEBUG) {\n    if (_flags & SchedulerFlags.UpdatingFrame) {\n      if (_debugFlags & SchedulerDebugFlags.MutationsFinished) {\n        printWarn(\"Dirty checking is scheduled after dirty checking were finished\");\n      }\n    }\n  }\n  _flags |= SchedulerFlags.DirtyCheckPending;\n  requestNextFrame(flags);\n}\n\n/**\n * Invalidate component.\n *\n * @param c - Component instance\n * @param flags - See {@link UpdateFlags} for details.\n */\nexport function invalidate<P>(c: Component<P>, flags?: UpdateFlags): void {\n  c.dirty = true;\n  requestDirtyCheck(flags);\n}\n\n/**\n * dirty requests a dirty checking and returns current monotonic clock value.\n *\n * @param flags - See {@link UpdateFlags} for details.\n * @returns current monotonic clock value.\n */\nexport const dirty = (flags?: UpdateFlags) => (requestDirtyCheck(flags), _clock);\n\n/**\n * Render virtual DOM node into the container.\n *\n * @param next - Virtual DOM node to render\n * @param container - DOM Node that will contain rendered node\n * @param flags - See {@link UpdateFlags} for details\n */\nexport function render(next: VNode | null, container: Element, flags?: UpdateFlags): void {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    /**\n     * Rendering into the <body> element is disabled to make it possible to fix iOS quirk with click events.\n     */\n    if (container === document.body) {\n      throw new Error(\"Rendering into the <body> element aren't allowed\");\n    }\n    if (!document.body.contains(container)) {\n      throw new Error(\"Container element should be attached to the document\");\n    }\n  }\n\n  const root = findRoot(container);\n  if (root) {\n    root.next = next;\n  } else {\n    ROOTS.push({ container, next, current: null });\n  }\n\n  requestDirtyCheck(flags);\n}\n","import { DispatchTarget } from \"./dispatch_target\";\nimport { EventHandler } from \"./event_handler\";\nimport { VNodeFlags, VNode } from \"../vdom/vnode\";\nimport { ROOTS } from \"../vdom/root\";\n\n/**\n * accumulateDispatchTargets traverses the DOM tree from the `target` Element to the document top, then goes down\n * through Virtual DOM tree and accumulates matching Event Handlers in `result` array.\n *\n * @param result Accumulated Dispatch Targets.\n * @param target Target DOM Element.\n * @param match Matching function.\n */\nexport function accumulateDispatchTargets(\n  result: DispatchTarget[],\n  target: Element,\n  match: (h: EventHandler) => boolean,\n): void {\n  for (let i = 0; i < ROOTS.length; i++) {\n    const { container, current } = ROOTS[i];\n    if (container.contains(target)) {\n      visitUp(result, match, target, container, current!);\n      break;\n    }\n  }\n}\n\nfunction visitUp(\n  result: DispatchTarget[],\n  match: (h: EventHandler) => boolean,\n  element: Element,\n  root: Element,\n  vnode: VNode | null,\n): VNode | null {\n  const parent = element.parentNode! as Element;\n  if (parent !== root) {\n    vnode = visitUp(result, match, parent, root, vnode);\n\n    if (vnode !== null &&\n      (vnode._f & (VNodeFlags.Children | VNodeFlags.Component | VNodeFlags.UpdateContext)) !== 0) {\n      let child = vnode._c;\n      while (child !== null) {\n        const r = visitDown(result, match, element, child as VNode);\n        if (r) {\n          return r;\n        }\n        child = (child as VNode)._r;\n      }\n    }\n    return null;\n  }\n\n  return visitDown(result, match, element, vnode!);\n}\n\nfunction visitDown(\n  result: DispatchTarget[],\n  match: (h: EventHandler) => boolean,\n  element: Element,\n  vnode: VNode,\n): VNode | null {\n  const flags = vnode._f;\n  let r;\n  if ((flags & VNodeFlags.Element) !== 0) {\n    if (vnode._i === element) {\n      accumulateDispatchTargetsFromVNode(result, vnode, match);\n      return vnode;\n    }\n  } else if ((flags & (VNodeFlags.Component | VNodeFlags.UpdateContext)) !== 0) {\n    r = visitDown(result, match, element, vnode._c as VNode);\n    if (r) {\n      accumulateDispatchTargetsFromVNode(result, vnode, match);\n      return r;\n    }\n  }\n\n  return null;\n}\n\n/**\n * accumulateDispatchTargetsFromElement accumulates matching Event Handlers in `result` array from the `target`\n * Virtual DOM Element.\n *\n * @param result Accumulated Dispatch Targets.\n * @param target Target Virtual DOM Element.\n * @param match Matching function.\n */\nfunction accumulateDispatchTargetsFromVNode(\n  result: DispatchTarget[],\n  target: VNode,\n  match: (h: EventHandler) => boolean,\n): void {\n  const events = target._e;\n  if (events !== null) {\n    let handlers: EventHandler[] | EventHandler | undefined;\n    if (events instanceof Array) {\n      let count = 0;\n      for (let i = 0; i < events.length; i++) {\n        const h = events[i];\n        if (h !== null && match(h) === true) {\n          if (count === 0) {\n            handlers = h;\n          } else if (count === 1) {\n            handlers = [handlers as EventHandler, h];\n          } else {\n            (handlers as EventHandler[]).push(h);\n          }\n          ++count;\n        }\n      }\n    } else {\n      if (match(events) === true) {\n        handlers = events;\n      }\n    }\n    if (handlers !== void 0) {\n      result.push({ target, handlers });\n    }\n  }\n}\n","import { EventHandlerFlags, EventFlags, SyntheticEventFlags } from \"./flags\";\nimport { DispatchTarget } from \"./dispatch_target\";\nimport { EventHandler } from \"./event_handler\";\nimport { SyntheticEvent } from \"./synthetic_event\";\n\n/**\n * dispatchEvent dispatches event to the list of dispatch targets.\n *\n * Simplified version of w3 Events flow algorithm. This algorithm doesn't include target phase, only capture and\n * bubbling phases. We don't care too much about w3 events compatibility, and there aren't any use cases that require\n * target phase.\n *\n * https://www.w3.org/TR/DOM-Level-3-Events/#event-flow\n *\n * @param targets Dispatch targets.\n * @param event Event to dispatch.\n * @param bubble Use bubbling phase.\n * @param dispatch Dispatch callback.\n */\nexport function dispatchEvent(\n  targets: DispatchTarget[],\n  event: SyntheticEvent,\n  bubble: boolean,\n  dispatch?: (h: EventHandler, ev: SyntheticEvent) => EventFlags | void,\n): void {\n  let i = targets.length;\n\n  // capture phase\n  while (--i >= 0) {\n    dispatchEventToLocalEventHandlers(targets[i], event, EventHandlerFlags.Capture, dispatch);\n    if (event.flags & SyntheticEventFlags.StoppedPropagation) {\n      return;\n    }\n  }\n\n  // bubble phase\n  if (bubble) {\n    while (++i < targets.length) {\n      dispatchEventToLocalEventHandlers(targets[i], event, EventHandlerFlags.Bubble, dispatch);\n      if (event.flags & SyntheticEventFlags.StoppedPropagation) {\n        return;\n      }\n    }\n  }\n}\n\n/**\n * dispatchEventToLocalEventHandlers dispatches event to local(at the same DOM Node) event handlers.\n *\n * @param target Dispatch Target.\n * @param event Synthetic Event.\n * @param matchFlags Flags that should match to deliver event.\n * @param dispatch Dispatch callback.\n */\nfunction dispatchEventToLocalEventHandlers(\n  target: DispatchTarget,\n  event: SyntheticEvent,\n  matchFlags: EventHandlerFlags,\n  dispatch: ((h: EventHandler, ev: SyntheticEvent) => EventFlags | void) | undefined,\n): void {\n  const handlers = target.handlers;\n  let flags: EventFlags = 0;\n\n  if (handlers instanceof Array) {\n    for (const handler of handlers) {\n      if (handler.flags & matchFlags) {\n        flags |= _dispatch(handler, dispatch, event);\n      }\n    }\n  } else if (handlers.flags & matchFlags) {\n    flags = _dispatch(handlers, dispatch, event);\n  }\n\n  event.flags |= flags;\n}\n\nfunction _dispatch(\n  handler: EventHandler,\n  dispatch: ((h: EventHandler, ev: SyntheticEvent) => EventFlags | void) | undefined,\n  event: SyntheticEvent,\n): EventFlags {\n  const flags = (dispatch === void 0) ? handler.handler(event) : dispatch(handler, event);\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (flags !== void 0) {\n      if (flags & ~(EventFlags.PreventDefault | EventFlags.StopPropagation)) {\n        throw new Error(`Invalid event flags: ${flags}`);\n      }\n    }\n  }\n  return (flags === void 0) ? 0 : flags;\n}\n","import { SyntheticEventFlags } from \"./flags\";\n\n/**\n * SyntheticEvent is a base class for all synthetic events.\n */\nexport class SyntheticEvent {\n  /**\n   * See {@link SyntheticEventFlags} for details.\n   */\n  flags: SyntheticEventFlags;\n  /**\n   * Timestamp when event was created.\n   */\n  readonly timestamp: number;\n\n  constructor(\n    flags: SyntheticEventFlags,\n    timestamp: number,\n  ) {\n    this.flags = flags;\n    this.timestamp = timestamp;\n  }\n}\n","import { SyntheticEventFlags } from \"./flags\";\nimport { SyntheticEvent } from \"./synthetic_event\";\n\n/**\n * SyntheticNativeEvent is a wrapper for native events.\n */\nexport class SyntheticNativeEvent<E extends Event> extends SyntheticEvent {\n  /**\n   * Event target.\n   */\n  readonly target: EventTarget;\n  /**\n   * Native event.\n   */\n  readonly native: E;\n\n  constructor(\n    flags: SyntheticEventFlags,\n    target: EventTarget,\n    timestamp: number,\n    native: E,\n  ) {\n    super(flags, timestamp);\n    this.target = target;\n    this.native = native;\n  }\n}\n","import { append, unorderedArrayDelete } from \"../core/array\";\nimport { withSchedulerTick } from \"../scheduler\";\nimport { SyntheticEventFlags, NativeEventSourceFlags } from \"./flags\";\nimport { EventDispatcher } from \"./event_dispatcher\";\nimport { EventHandler } from \"./event_handler\";\nimport { DispatchTarget } from \"./dispatch_target\";\nimport { accumulateDispatchTargets } from \"./accumulate_dispatch_targets\";\nimport { dispatchEvent } from \"./dispatch_event\";\nimport { SyntheticNativeEvent } from \"./synthetic_native_event\";\n\n/**\n * NativeEventSource dispatches native events.\n *\n * It is using two-phase dispatching algorithm similar to native DOM events flow.\n */\nexport interface NativeEventDispatcher<E extends Event> {\n  /**\n   * Public EventSource interface.\n   */\n  readonly src: EventDispatcher;\n  /**\n   * Number of active dependencies.\n   *\n   * When there are active dependencies, event source will be activated by attaching native event listeners to the\n   * document. When it goes to zero it will be deactivated, and all event listeners will be removed.\n   */\n  deps: number;\n  /**\n   * Number of active listeners.\n   */\n  listeners: number;\n  /**\n   * See `NativeEventSourceFlags` for details.\n   */\n  flags: NativeEventSourceFlags;\n  /**\n   * Event handler options.\n   */\n  options: { capture?: boolean, passive?: boolean } | boolean;\n  /**\n   * DOM event name.\n   */\n  readonly name: string;\n  /**\n   * Hooks that will be executed before dispatching an event.\n   */\n  before: Array<(ev: SyntheticNativeEvent<E>) => void> | null;\n  /**\n   * Hooks that will be executed after dispatching an event.\n   */\n  after: Array<(ev: SyntheticNativeEvent<E>) => void> | null;\n  /**\n   * Event dispatcher.\n   */\n  dispatch: ((ev: E) => void) | null;\n}\n\n/**\n * Creates a native event dispatcher.\n *\n * @param flags - See {@link NativeEventSourceFlags} for details.\n * @param name - Event name\n * @param options - Event handler options\n * @returns {@link NativeEventDispatcher} instance\n */\nexport function createNativeEventDispatcher<E extends Event>(\n  flags: NativeEventSourceFlags,\n  name: string,\n  options?: { capture?: boolean, passive?: boolean } | boolean,\n): NativeEventDispatcher<E> {\n  const source: NativeEventDispatcher<E> = {\n    src: {\n      add() { ++source.listeners; incDependencies(source); },\n      remove() { --source.listeners; decDependencies(source); },\n    },\n    deps: 0,\n    listeners: 0,\n    flags,\n    options: options === void 0 ? true : options,\n    name,\n    before: null,\n    after: null,\n    dispatch: null,\n  };\n\n  const matchEventSource = (h: EventHandler) => h.src === source.src;\n\n  source.dispatch = withSchedulerTick((ev: E): void => {\n    const target = ev.target as Element;\n    const targets: DispatchTarget[] = [];\n\n    if (source.listeners) {\n      accumulateDispatchTargets(targets, target, matchEventSource);\n    }\n\n    if (targets.length || source.before || source.after) {\n      const syntheticEvent = new SyntheticNativeEvent<E>(0, target, ev.timeStamp, ev);\n\n      dispatchToListeners(source.before, syntheticEvent);\n      if (targets.length) {\n        dispatchEvent(targets, syntheticEvent, (source.flags & NativeEventSourceFlags.Bubbles) !== 0);\n      }\n      dispatchToListeners(source.after, syntheticEvent);\n\n      if (syntheticEvent.flags & SyntheticEventFlags.PreventedDefault) {\n        ev.preventDefault();\n      }\n    }\n  });\n\n  return source;\n}\n\n/**\n * beforeNativeEvent attaches a hook that will be executed before dispatching an event.\n *\n * @param source - Event dispatcher source.\n * @param cb - Hook\n */\nexport function beforeNativeEvent<E extends Event>(\n  source: NativeEventDispatcher<E>,\n  cb: (e: SyntheticNativeEvent<E>) => void,\n): void {\n  source.before = append(source.before, cb);\n  incDependencies(source);\n}\n\n/**\n * afterNativeEvent attaches a hook that will be executed after dispatching an event.\n *\n * @param source - Event dispatcher source.\n * @param cb - Hook\n */\nexport function afterNativeEvent<E extends Event>(\n  source: NativeEventDispatcher<E>,\n  cb: (e: SyntheticNativeEvent<E>) => void,\n): void {\n  source.after = append(source.after, cb);\n  incDependencies(source);\n}\n\n/**\n * removeBeforeNativeEvent removes a hook that is executed before dispatching an event.\n *\n * @param source - Event dispatcher source.\n * @param cb - Hook\n */\nexport function removeBeforeNativeEvent<E extends Event>(\n  source: NativeEventDispatcher<E>,\n  cb: (e: SyntheticNativeEvent<E>) => void,\n): void {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (source.before === null) {\n      throw new Error(\"removeBeforeNativeEvent() failed, unable to find registered callback\");\n    }\n  }\n  unorderedArrayDelete(source.before!, cb);\n  decDependencies(source);\n}\n\n/**\n * removeAfterNativeEvent removes a hook that is executed after dispatching an event.\n *\n * @param source - Event dispatcher source.\n * @param cb - Hook\n */\nexport function removeAfterNativeEvent<E extends Event>(\n  source: NativeEventDispatcher<E>,\n  cb: (e: SyntheticNativeEvent<E>) => void,\n): void {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (source.after === null) {\n      throw new Error(\"removeAfterNativeEvent() failed, unable to find registered callback\");\n    }\n  }\n  unorderedArrayDelete(source.after!, cb);\n  decDependencies(source);\n}\n\nfunction incDependencies<E extends Event>(source: NativeEventDispatcher<E>): void {\n  if (source.deps++ === 0) {\n    document.addEventListener(\n      source.name,\n      source.dispatch! as EventListenerOrEventListenerObject,\n      source.options,\n    );\n  }\n}\n\nfunction decDependencies<E extends Event>(source: NativeEventDispatcher<E>): void {\n  if (--source.deps === 0) {\n    document.removeEventListener(\n      source.name,\n      source.dispatch! as EventListenerOrEventListenerObject,\n      source.options,\n    );\n  }\n}\n\nfunction dispatchToListeners<E extends Event>(\n  listeners: Array<(ev: SyntheticNativeEvent<E>) => void> | null,\n  ev: SyntheticNativeEvent<E>,\n): void {\n  if (listeners !== null) {\n    const cbs = listeners.slice();\n    for (let i = 0; i < cbs.length; i++) {\n      cbs[i](ev);\n    }\n  }\n}\n","import { PASSIVE_EVENTS } from \"../core/feature_detection\";\n\n/* istanbul ignore next */\n/**\n * getEventTarget retrieves target element from an event.\n *\n * There are still some differences in modern browsers, so we need to use this function to retrieve event targets.\n *\n * #quirks\n *\n * @param ev Event.\n * @returns Target Element.\n */\nexport function getEventTarget(ev: Event): EventTarget {\n  let target = ev.target || window;\n\n  /**\n   * Some browsers are implementing it according to SVG 1.1 specs:\n   *\n   * https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7998724/\n   *\n   * \"If event attributes are assigned to referenced elements, then the actual target for the event will be the\n   * SVGElementInstance object within the 'instance tree' corresponding to the given referenced element.\"\n   *\n   * https://www.w3.org/TR/SVG/struct.html#UseElement\n   *\n   * SVG 2 redefined the use event handling model:\n   *\n   * - Removed the SVGElementInstance and SVGElementInstanceList interfaces, and the corresponding attributes on the\n   *   SVGUseElement interface.\n   * - Changed the use element event flow to follow the Shadow DOM spec.\n   *\n   * https://www.w3.org/TR/SVG2/changes.html#structure\n   */\n  if ((target as any).correspondingUseElement !== undefined) {\n    target = (target as any).correspondingUseElement;\n  }\n\n  return target;\n}\n\n/* istanbul ignore next */\n/**\n * `{ capture: true, passive: true }` object that should be used as a 3rd parameter for `addEventListener` method.\n */\nexport const EVENT_CAPTURE_PASSIVE_OPTIONS = PASSIVE_EVENTS ? { \"capture\": true, \"passive\": true } : true;\n\n/* istanbul ignore next */\n/**\n * `{ capture: true, passive: false }` object that should be used as a 3rd parameter for `addEventListener` method.\n */\nexport const EVENT_CAPTURE_ACTIVE_OPTIONS = PASSIVE_EVENTS ? { \"capture\": true, \"passive\": false } : true;\n\n/* istanbul ignore next */\n/**\n * `{ passive: true }` object that should be used as a 3rd parameter for `addEventListener` method.\n */\nexport const EVENT_PASSIVE_OPTIONS = PASSIVE_EVENTS ? { \"passive\": true } : false;\n\n/* istanbul ignore next */\n/**\n * `{ passive: false }` object that should be used as a 3rd parameter for `addEventListener` method.\n */\nexport const EVENT_ACTIVE_OPTIONS = PASSIVE_EVENTS ? { \"passive\": false } : false;\n","/**\n * Event Handlers.\n *\n * Optimizing compilers should inline all this functions and completely remove unused code.\n */\n\nimport { EventHandlerFlags, EventFlags, NativeEventSourceFlags } from \"./flags\";\nimport { EventHandler } from \"./event_handler\";\nimport { EventDispatcher } from \"./event_dispatcher\";\nimport { NativeEventDispatcher, createNativeEventDispatcher } from \"./native_event_dispatcher\";\nimport { SyntheticNativeEvent } from \"./synthetic_native_event\";\nimport { EVENT_CAPTURE_ACTIVE_OPTIONS } from \"./utils\";\n\n/* tslint:disable:max-line-length */\nexport const EVENT_DISPATCHER_ABORT = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture, \"abort\") as NativeEventDispatcher<UIEvent>;\nexport const EVENT_DISPATCHER_ACTIVATE = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"activate\");\nexport const EVENT_DISPATCHER_ARIA_REQUEST = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"ariarequest\");\nexport const EVENT_DISPATCHER_BEFORE_ACTIVATE = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"beforeactivate\");\nexport const EVENT_DISPATCHER_BEFORE_COPY = /*#__PURE__*/createNativeEventDispatcher<ClipboardEvent>(NativeEventSourceFlags.Capture, \"beforecopy\");\nexport const EVENT_DISPATCHER_BEFORE_CUT = /*#__PURE__*/createNativeEventDispatcher<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"beforecut\");\nexport const EVENT_DISPATCHER_BEFORE_DEACTIVATE = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"beforedeactivate\");\nexport const EVENT_DISPATCHER_BEFORE_PASTE = /*#__PURE__*/createNativeEventDispatcher<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"beforepaste\");\nexport const EVENT_DISPATCHER_BLUR = /*#__PURE__*/createNativeEventDispatcher<FocusEvent>(NativeEventSourceFlags.Capture, \"blur\");\nexport const EVENT_DISPATCHER_CAN_PLAY = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"canplay\");\nexport const EVENT_DISPATCHER_CAN_PLAYTHROUGH = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"canplaythrough\");\nexport const EVENT_DISPATCHER_CHANGE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"change\");\nexport const EVENT_DISPATCHER_CLICK = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"click\");\nexport const EVENT_DISPATCHER_CONTEXT_MENU = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"contextmenu\");\nexport const EVENT_DISPATCHER_COPY = /*#__PURE__*/createNativeEventDispatcher<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"copy\");\nexport const EVENT_DISPATCHER_CUE_CHANGE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"cuechange\");\nexport const EVENT_DISPATCHER_CUT = /*#__PURE__*/createNativeEventDispatcher<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"cut\");\nexport const EVENT_DISPATCHER_DOUBLE_CLICK = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dblclick\");\nexport const EVENT_DISPATCHER_DEACTIVATE = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"deactivate\");\nexport const EVENT_DISPATCHER_DRAG = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"drag\");\nexport const EVENT_DISPATCHER_DRAG_END = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragend\");\nexport const EVENT_DISPATCHER_DRAG_ENTER = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragenter\");\nexport const EVENT_DISPATCHER_DRAG_LEAVE = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragleave\");\nexport const EVENT_DISPATCHER_DRAG_OVER = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragover\");\nexport const EVENT_DISPATCHER_DRAG_START = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragstart\");\nexport const EVENT_DISPATCHER_DROP = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"drop\");\nexport const EVENT_DISPATCHER_DURATION_CHANGE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"durationchange\");\nexport const EVENT_DISPATCHER_EMPTIED = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"emptied\");\nexport const EVENT_DISPATCHER_ENCRYPTED = /*#__PURE__*/createNativeEventDispatcher<MediaEncryptedEvent>(NativeEventSourceFlags.Capture, \"encrypted\");\nexport const EVENT_DISPATCHER_ENDED = /*#__PURE__*/createNativeEventDispatcher<MediaStreamErrorEvent>(NativeEventSourceFlags.Capture, \"ended\");\nexport const EVENT_DISPATCHER_ERROR = /*#__PURE__*/createNativeEventDispatcher<ErrorEvent>(NativeEventSourceFlags.Capture, \"error\");\nexport const EVENT_DISPATCHER_FOCUS = /*#__PURE__*/createNativeEventDispatcher<FocusEvent>(NativeEventSourceFlags.Capture, \"focus\");\nexport const EVENT_DISPATCHER_GOT_POINTER_CAPTURE = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture, \"gotpointercapture\");\nexport const EVENT_DISPATCHER_INPUT = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"input\");\nexport const EVENT_DISPATCHER_INVALID = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"invalid\");\nexport const EVENT_DISPATCHER_KEY_DOWN = /*#__PURE__*/createNativeEventDispatcher<KeyboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"keydown\");\nexport const EVENT_DISPATCHER_KEY_PRESS = /*#__PURE__*/createNativeEventDispatcher<KeyboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"keypress\");\nexport const EVENT_DISPATCHER_KEY_UP = /*#__PURE__*/createNativeEventDispatcher<KeyboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"keyup\");\nexport const EVENT_DISPATCHER_LOAD = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"load\");\nexport const EVENT_DISPATCHER_LOADED_DATA = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"loadeddata\");\nexport const EVENT_DISPATCHER_LOADED_METADATA = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"loadedmetadata\");\nexport const EVENT_DISPATCHER_LOAD_START = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"loadstart\");\nexport const EVENT_DISPATCHER_LOST_POINTER_CAPTURE = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture, \"lostpointercapture\");\nexport const EVENT_DISPATCHER_MOUSE_DOWN = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mousedown\");\nexport const EVENT_DISPATCHER_MOUSE_ENTER = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture, \"mouseenter\");\nexport const EVENT_DISPATCHER_MOUSE_LEAVE = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture, \"mouseleave\");\nexport const EVENT_DISPATCHER_MOUSE_MOVE = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mousemove\");\nexport const EVENT_DISPATCHER_MOUSE_OUT = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mouseout\");\nexport const EVENT_DISPATCHER_MOUSE_OVER = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mouseover\");\nexport const EVENT_DISPATCHER_MOUSE_UP = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mouseup\");\nexport const EVENT_DISPATCHER_PASTE = /*#__PURE__*/createNativeEventDispatcher<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"paste\");\nexport const EVENT_DISPATCHER_PAUSE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"pause\");\nexport const EVENT_DISPATCHER_PLAY = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"play\");\nexport const EVENT_DISPATCHER_PLAYING = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"playing\");\nexport const EVENT_DISPATCHER_POINTER_CANCEL = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointercancel\");\nexport const EVENT_DISPATCHER_POINTER_DOWN = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointerdown\");\nexport const EVENT_DISPATCHER_POINTER_ENTER = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture, \"pointerenter\");\nexport const EVENT_DISPATCHER_POINTER_LEAVE = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture, \"pointerleave\");\nexport const EVENT_DISPATCHER_POINTER_MOVE = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointermove\");\nexport const EVENT_DISPATCHER_POINTER_OUT = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointerout\");\nexport const EVENT_DISPATCHER_POINTER_OVER = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointerover\");\nexport const EVENT_DISPATCHER_POINTER_UP = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointerup\");\nexport const EVENT_DISPATCHER_PROGRESS = /*#__PURE__*/createNativeEventDispatcher<ProgressEvent>(NativeEventSourceFlags.Capture, \"progress\");\nexport const EVENT_DISPATCHER_RATE_CHANGE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"ratechange\");\nexport const EVENT_DISPATCHER_RESET = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"reset\");\nexport const EVENT_DISPATCHER_SCROLL = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture, \"scroll\");\nexport const EVENT_DISPATCHER_SEEKED = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"seeked\");\nexport const EVENT_DISPATCHER_SEEKING = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"seeking\");\nexport const EVENT_DISPATCHER_SELECT = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"select\");\nexport const EVENT_DISPATCHER_SELECT_START = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"selectstart\");\nexport const EVENT_DISPATCHER_STALLED = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"stalled\");\nexport const EVENT_DISPATCHER_SUBMIT = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"submit\");\nexport const EVENT_DISPATCHER_SUSPEND = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"suspend\");\nexport const EVENT_DISPATCHER_TIME_UPDATE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"timeupdate\");\nexport const EVENT_DISPATCHER_TOUCH_CANCEL = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"touchcancel\");\nexport const EVENT_DISPATCHER_TOUCH_END = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles | NativeEventSourceFlags.Passive, \"touchend\");\nexport const EVENT_DISPATCHER_TOUCH_MOVE = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles | NativeEventSourceFlags.Passive, \"touchmove\");\nexport const EVENT_DISPATCHER_TOUCH_START = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles | NativeEventSourceFlags.Passive, \"touchstart\");\nexport const EVENT_DISPATCHER_UNLOAD = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"unload\");\nexport const EVENT_DISPATCHER_VOLUME_CHANGE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"volumechange\");\nexport const EVENT_DISPATCHER_WAITING = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"waiting\");\nexport const EVENT_DISPATCHER_WHEEL = /*#__PURE__*/createNativeEventDispatcher<WheelEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles | NativeEventSourceFlags.Passive, \"wheel\");\n\nexport const EVENT_DISPATCHER_ACTIVE_TOUCH_END = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"touchend\", EVENT_CAPTURE_ACTIVE_OPTIONS);\nexport const EVENT_DISPATCHER_ACTIVE_TOUCH_MOVE = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"touchmove\", EVENT_CAPTURE_ACTIVE_OPTIONS);\nexport const EVENT_DISPATCHER_ACTIVE_TOUCH_START = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"touchstart\", EVENT_CAPTURE_ACTIVE_OPTIONS);\nexport const EVENT_DISPATCHER_ACTIVE_WHEEL = /*#__PURE__*/createNativeEventDispatcher<WheelEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"wheel\", EVENT_CAPTURE_ACTIVE_OPTIONS);\n\n/**\n * Helper function that creates event handlers.\n *\n * @param src - Event source\n * @param handler - Event Handler function\n * @param capture - Capture mode\n * @returns EventHandler instance\n */\nexport function createNativeEventHandler<E extends SyntheticNativeEvent<any>>(\n  src: EventDispatcher,\n  handler: (ev: E) => EventFlags | void,\n  capture?: boolean,\n): EventHandler<E> {\n  return {\n    src,\n    flags: capture === true ? EventHandlerFlags.Capture : EventHandlerFlags.Bubble,\n    handler,\n    listeners: 0,\n    props: null,\n    state: null,\n  };\n}\n\nexport function onAbort(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<UIEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<UIEvent>>(EVENT_DISPATCHER_ABORT.src, handler, capture);\n}\nexport function onActivate(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<UIEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<UIEvent>>(EVENT_DISPATCHER_ACTIVATE.src, handler, capture);\n}\nexport function onAriaRequest(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<UIEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<UIEvent>>(EVENT_DISPATCHER_ARIA_REQUEST.src, handler, capture);\n}\nexport function onBeforeActivate(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<UIEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<UIEvent>>(EVENT_DISPATCHER_BEFORE_ACTIVATE.src, handler, capture);\n}\nexport function onBeforeCopy(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<ClipboardEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<ClipboardEvent>>(EVENT_DISPATCHER_BEFORE_COPY.src, handler, capture);\n}\nexport function onBeforeCut(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<ClipboardEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<ClipboardEvent>>(EVENT_DISPATCHER_BEFORE_CUT.src, handler, capture);\n}\nexport function onBeforeDeactivate(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<UIEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<UIEvent>>(EVENT_DISPATCHER_BEFORE_DEACTIVATE.src, handler, capture);\n}\nexport function onBeforePaste(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<ClipboardEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<ClipboardEvent>>(EVENT_DISPATCHER_BEFORE_PASTE.src, handler, capture);\n}\nexport function onBlur(\n  handler: (ev: SyntheticNativeEvent<FocusEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<FocusEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<FocusEvent>>(EVENT_DISPATCHER_BLUR.src, handler, capture);\n}\nexport function onCanPlay(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_CAN_PLAY.src, handler, capture);\n}\nexport function onCanPlaythrough(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_CAN_PLAYTHROUGH.src, handler, capture);\n}\nexport function onChange(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_CHANGE.src, handler, capture);\n}\nexport function onClick(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MouseEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<MouseEvent>>(EVENT_DISPATCHER_CLICK.src, handler, capture);\n}\nexport function onContextMenu(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<PointerEvent>>(EVENT_DISPATCHER_CONTEXT_MENU.src, handler, capture);\n}\nexport function onCopy(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<ClipboardEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<ClipboardEvent>>(EVENT_DISPATCHER_COPY.src, handler, capture);\n}\nexport function onCueChange(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_CUE_CHANGE.src, handler, capture);\n}\nexport function onCut(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<ClipboardEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<ClipboardEvent>>(EVENT_DISPATCHER_CUT.src, handler, capture);\n}\nexport function onDoubleClick(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MouseEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<MouseEvent>>(EVENT_DISPATCHER_DOUBLE_CLICK.src, handler, capture);\n}\nexport function onDeactivate(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<UIEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<UIEvent>>(EVENT_DISPATCHER_DEACTIVATE.src, handler, capture);\n}\nexport function onDrag(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<DragEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<DragEvent>>(EVENT_DISPATCHER_DRAG.src, handler, capture);\n}\nexport function onDragEnd(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<DragEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<DragEvent>>(EVENT_DISPATCHER_DRAG_END.src, handler, capture);\n}\nexport function onDragEnter(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<DragEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<DragEvent>>(EVENT_DISPATCHER_DRAG_ENTER.src, handler, capture);\n}\nexport function onDragLeave(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<DragEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<DragEvent>>(EVENT_DISPATCHER_DRAG_LEAVE.src, handler, capture);\n}\nexport function onDragOver(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<DragEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<DragEvent>>(EVENT_DISPATCHER_DRAG_OVER.src, handler, capture);\n}\nexport function onDragStart(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<DragEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<DragEvent>>(EVENT_DISPATCHER_DRAG_START.src, handler, capture);\n}\nexport function onDrop(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<DragEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<DragEvent>>(EVENT_DISPATCHER_DROP.src, handler, capture);\n}\nexport function onDurationChange(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_DURATION_CHANGE.src, handler, capture);\n}\nexport function onEmptied(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_EMPTIED.src, handler, capture);\n}\nexport function onEncrypted(\n  handler: (ev: SyntheticNativeEvent<MediaEncryptedEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MediaEncryptedEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<MediaEncryptedEvent>>(EVENT_DISPATCHER_ENCRYPTED.src, handler, capture);\n}\nexport function onEnded(\n  handler: (ev: SyntheticNativeEvent<MediaStreamErrorEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MediaStreamErrorEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<MediaStreamErrorEvent>>(EVENT_DISPATCHER_ENDED.src, handler, capture);\n}\nexport function onError(\n  handler: (ev: SyntheticNativeEvent<ErrorEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<ErrorEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<ErrorEvent>>(EVENT_DISPATCHER_ERROR.src, handler, capture);\n}\nexport function onFocus(\n  handler: (ev: SyntheticNativeEvent<FocusEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<FocusEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<FocusEvent>>(EVENT_DISPATCHER_FOCUS.src, handler, capture);\n}\nexport function onGotPointerCapture(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<PointerEvent>>(EVENT_DISPATCHER_GOT_POINTER_CAPTURE.src, handler, capture);\n}\nexport function onInput(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_INPUT.src, handler, capture);\n}\nexport function onInvalid(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_INVALID.src, handler, capture);\n}\nexport function onKeyDown(\n  handler: (ev: SyntheticNativeEvent<KeyboardEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<KeyboardEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<KeyboardEvent>>(EVENT_DISPATCHER_KEY_DOWN.src, handler, capture);\n}\nexport function onKeyPress(\n  handler: (ev: SyntheticNativeEvent<KeyboardEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<KeyboardEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<KeyboardEvent>>(EVENT_DISPATCHER_KEY_PRESS.src, handler, capture);\n}\nexport function onKeyUp(\n  handler: (ev: SyntheticNativeEvent<KeyboardEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<KeyboardEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<KeyboardEvent>>(EVENT_DISPATCHER_KEY_UP.src, handler, capture);\n}\nexport function onLoad(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_LOAD.src, handler, capture);\n}\nexport function onLoadedData(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_LOADED_DATA.src, handler, capture);\n}\nexport function onLoadedMetadata(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_LOADED_METADATA.src, handler, capture);\n}\nexport function onLoadStart(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_LOAD_START.src, handler, capture);\n}\nexport function onLostPointerCapture(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<PointerEvent>>(EVENT_DISPATCHER_LOST_POINTER_CAPTURE.src, handler, capture);\n}\nexport function onMouseDown(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MouseEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<MouseEvent>>(EVENT_DISPATCHER_MOUSE_DOWN.src, handler, capture);\n}\nexport function onMouseEnter(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MouseEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<MouseEvent>>(EVENT_DISPATCHER_MOUSE_ENTER.src, handler, capture);\n}\nexport function onMouseLeave(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MouseEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<MouseEvent>>(EVENT_DISPATCHER_MOUSE_LEAVE.src, handler, capture);\n}\nexport function onMouseMove(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MouseEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<MouseEvent>>(EVENT_DISPATCHER_MOUSE_MOVE.src, handler, capture);\n}\nexport function onMouseOut(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MouseEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<MouseEvent>>(EVENT_DISPATCHER_MOUSE_OUT.src, handler, capture);\n}\nexport function onMouseOver(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MouseEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<MouseEvent>>(EVENT_DISPATCHER_MOUSE_OVER.src, handler, capture);\n}\nexport function onMouseUp(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<MouseEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<MouseEvent>>(EVENT_DISPATCHER_MOUSE_UP.src, handler, capture);\n}\nexport function onPaste(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<ClipboardEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<ClipboardEvent>>(EVENT_DISPATCHER_PASTE.src, handler, capture);\n}\nexport function onPause(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_PAUSE.src, handler, capture);\n}\nexport function onPlay(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_PLAY.src, handler, capture);\n}\nexport function onPlaying(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_PLAYING.src, handler, capture);\n}\nexport function onPointerCancel(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<PointerEvent>>(EVENT_DISPATCHER_POINTER_CANCEL.src, handler, capture);\n}\nexport function onPointerDown(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<PointerEvent>>(EVENT_DISPATCHER_POINTER_DOWN.src, handler, capture);\n}\nexport function onPointerEnter(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<PointerEvent>>(EVENT_DISPATCHER_POINTER_ENTER.src, handler, capture);\n}\nexport function onPointerLeave(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<PointerEvent>>(EVENT_DISPATCHER_POINTER_LEAVE.src, handler, capture);\n}\nexport function onPointerMove(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<PointerEvent>>(EVENT_DISPATCHER_POINTER_MOVE.src, handler, capture);\n}\nexport function onPointerOut(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<PointerEvent>>(EVENT_DISPATCHER_POINTER_OUT.src, handler, capture);\n}\nexport function onPointerOver(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<PointerEvent>>(EVENT_DISPATCHER_POINTER_OVER.src, handler, capture);\n}\nexport function onPointerUp(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<PointerEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<PointerEvent>>(EVENT_DISPATCHER_POINTER_UP.src, handler, capture);\n}\nexport function onProgress(\n  handler: (ev: SyntheticNativeEvent<ProgressEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<ProgressEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<ProgressEvent>>(EVENT_DISPATCHER_PROGRESS.src, handler, capture);\n}\nexport function onRateChange(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_RATE_CHANGE.src, handler, capture);\n}\nexport function onReset(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_RESET.src, handler, capture);\n}\nexport function onScroll(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<UIEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<UIEvent>>(EVENT_DISPATCHER_SCROLL.src, handler, capture);\n}\nexport function onSeeked(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_SEEKED.src, handler, capture);\n}\nexport function onSeeking(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_SEEKING.src, handler, capture);\n}\nexport function onSelect(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<UIEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<UIEvent>>(EVENT_DISPATCHER_SELECT.src, handler, capture);\n}\nexport function onSelectStart(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_SELECT_START.src, handler, capture);\n}\nexport function onStalled(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_STALLED.src, handler, capture);\n}\nexport function onSubmit(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_SUBMIT.src, handler, capture);\n}\nexport function onSuspend(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_SUSPEND.src, handler, capture);\n}\nexport function onTimeUpdate(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_TIME_UPDATE.src, handler, capture);\n}\nexport function onTouchCancel(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<TouchEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<TouchEvent>>(EVENT_DISPATCHER_TOUCH_CANCEL.src, handler, capture);\n}\nexport function onTouchEnd(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<TouchEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<TouchEvent>>(EVENT_DISPATCHER_TOUCH_END.src, handler, capture);\n}\nexport function onTouchMove(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<TouchEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<TouchEvent>>(EVENT_DISPATCHER_TOUCH_MOVE.src, handler, capture);\n}\nexport function onTouchStart(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<TouchEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<TouchEvent>>(EVENT_DISPATCHER_TOUCH_START.src, handler, capture);\n}\nexport function onUnload(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_UNLOAD.src, handler, capture);\n}\nexport function onVolumeChange(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_VOLUME_CHANGE.src, handler, capture);\n}\nexport function onWaiting(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<Event>> {\n  return createNativeEventHandler<SyntheticNativeEvent<Event>>(EVENT_DISPATCHER_WAITING.src, handler, capture);\n}\nexport function onWheel(\n  handler: (ev: SyntheticNativeEvent<WheelEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<WheelEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<WheelEvent>>(EVENT_DISPATCHER_WHEEL.src, handler, capture);\n}\n\nexport function onActiveTouchEnd(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<TouchEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<TouchEvent>>(EVENT_DISPATCHER_ACTIVE_TOUCH_END.src, handler, capture);\n}\nexport function onActiveTouchMove(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<TouchEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<TouchEvent>>(EVENT_DISPATCHER_ACTIVE_TOUCH_MOVE.src, handler, capture);\n}\nexport function onActiveTouchStart(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<TouchEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<TouchEvent>>(EVENT_DISPATCHER_ACTIVE_TOUCH_START.src, handler, capture);\n}\nexport function onActiveWheel(\n  handler: (ev: SyntheticNativeEvent<WheelEvent>) => EventFlags | void,\n  capture = false,\n): EventHandler<SyntheticNativeEvent<WheelEvent>> {\n  return createNativeEventHandler<SyntheticNativeEvent<WheelEvent>>(EVENT_DISPATCHER_ACTIVE_WHEEL.src, handler, capture);\n}\n\n/* tslint:enable:max-line-length */\n","import { NOOP } from \"../core/noop\";\nimport { elementRemoveAttribute } from \"../core/shortcuts\";\nimport { scheduleMutationEffect } from \"../scheduler\";\n\n/**\n * Attribute directives are used to extend reconciliation algorithm.\n *\n * When DOM element attributes are updated, all value types are checked if it is a string, number, boolean or an\n * `AttributeDirective`. When it is an attribute directive, custom update function will be invoked with the DOM\n * element, attribute key, previous and next values.\n */\nexport interface AttributeDirective<P> {\n  /**\n   * Value.\n   */\n  v: P | undefined;\n  /**\n   * Update function.\n   *\n   * @param element - Target element\n   * @param key - Attribute key\n   * @param prev - Previous value\n   * @param next - Next value\n   */\n  u(element: Element, key: string, prev: P | undefined, next: P | undefined): void;\n}\n\n/**\n * {@link AttributeDirective} with `undefined` value and `NOOP` update function.\n */\nexport const ATTRIBUTE_DIRECTIVE_SKIP_UNDEFINED: AttributeDirective<any> = {\n  v: void 0,\n  u: NOOP as (element: Element, key: string, prev: any, next: any) => void,\n};\n\n/**\n * {@link AttributeDirective} with `undefined` value and update functions that removes `key` attribute.\n */\nexport const ATTRIBUTE_DIRECTIVE_REMOVE_ATTR_UNDEFINED = {\n  v: void 0,\n  u: (element: Element, key: string, prev: any) => {\n    if (prev !== void 0) {\n      elementRemoveAttribute.call(element, key);\n    }\n  },\n};\n\n/**\n * {@link AttributeDirective} with `undefined` value and update functions that removes `key` event.\n */\nexport const ATTRIBUTE_DIRECTIVE_REMOVE_EVENT_UNDEFINED = {\n  v: void 0,\n  u: (\n    element: Element,\n    key: string,\n    prev: ((ev: Event) => void) | undefined,\n  ) => {\n    if (prev !== void 0) {\n      element.removeEventListener(key, prev);\n    }\n  },\n};\n\n/**\n * PROPERTY function creates an {@link AttributeDirective} that assigns a property to a property name derived from the\n * `key` of the attribute.\n *\n * `undefined` values are ignored.\n *\n * @example\n *\n *   const e = div(\"\", { _customProperty: PROPERTY(\"value\") });\n *\n * @param v - Property value\n * @returns {@link AttributeDirective}\n */\nexport const PROPERTY = <T>(v: T | undefined): AttributeDirective<T> => (v === void 0) ?\n  ATTRIBUTE_DIRECTIVE_SKIP_UNDEFINED : { v, u: updateProperty };\n\n/**\n * Update function for an {@link AttributeDirective} created with a {@link PROPERTY} function.\n *\n * @param element - Target element\n * @param key - Attribute key\n * @param prev - Previous value\n * @param next - Next value\n */\nfunction updateProperty(element: Element, key: string, prev: any, next: any) {\n  if (prev !== next) {\n    (element as any)[key] = next!;\n  }\n}\n\n/**\n * UNSAFE_HTML function creates a {@link AttributeDirective} that assigns an `innerHTML` property to an Element.\n *\n * `undefined` values are ignored.\n *\n * @example\n *\n *   const e = div(\"\", { unsafeHTML: UNSAFE_HTML(\"<span></span>\") });\n *\n * @param v - innerHTML value\n * @returns {@link AttributeDirective}\n */\nexport const UNSAFE_HTML = (v: string | undefined): AttributeDirective<string> => (v === void 0) ?\n  ATTRIBUTE_DIRECTIVE_SKIP_UNDEFINED : { v, u: updateUnsafeHTML };\n\n/**\n * Update function for an {@link AttributeDirective} created with {@link UNSAFE_HTML} function.\n *\n * @param element - Target element\n * @param key - Attribute key\n * @param prev - Previous value\n * @param next - Next value\n */\nfunction updateUnsafeHTML(element: Element, key: string, prev: string | undefined, next: string) {\n  if (prev !== next) {\n    if (prev !== void 0 || next !== \"\") {\n      element.innerHTML = next!;\n    }\n  }\n}\n\n/**\n * EVENT function creates an {@link AttributeDirective} that assigns a native event handler derived from the `key`\n * attribute to an Element.\n *\n * `undefined` values remove event listener.\n *\n * @example\n *\n *   const e = div(\"\", { click: EVENT((ev) => { console.log(ev) }); });\n *\n * @param v - Event handler\n * @returns {@link AttributeDirective}\n */\nexport const EVENT = (v: ((ev: Event) => void) | undefined): AttributeDirective<(ev: Event) => void> => (v === void 0) ?\n  ATTRIBUTE_DIRECTIVE_REMOVE_EVENT_UNDEFINED : { v, u: updateEvent };\n\n/**\n * Update function for an {@link AttributeDirective} created with {@link EVENT} function.\n *\n * @param element - Target element\n * @param key - Attribute key\n * @param prev - Previous value\n * @param next - Next value\n */\nfunction updateEvent(\n  element: Element,\n  key: string,\n  prev: ((ev: Event) => void) | undefined,\n  next: ((ev: Event) => void),\n) {\n  if (prev !== next) {\n    if (prev !== void 0) {\n      element.removeEventListener(key, prev);\n    }\n    element.addEventListener(key, next);\n  }\n}\n\n/**\n * Synchronization function for {@link AttributeDirective} created with {@link AUTOFOCUS} function.\n *\n * @param element - Target element\n * @param key - Attribute key\n * @param prev - Previous value\n * @param next - Next value\n */\nfunction updateAutofocus(\n  element: Element,\n  key: string,\n  prev: boolean | undefined,\n  next: boolean | undefined,\n) {\n  if (prev === void 0 && next) {\n    scheduleMutationEffect(() => { (element as HTMLElement).focus(); });\n  }\n}\n\n/**\n * {@link AttributeDirective} with `false` value and {@link updateAutofocus} sync function.\n */\nconst AUTOFOCUS_FALSE: AttributeDirective<boolean> = { v: false, u: updateAutofocus };\n\n/**\n * {@link AttributeDirective} with `true` value and {@link updateAutofocus} sync function.\n */\nconst AUTOFOCUS_TRUE: AttributeDirective<boolean> = { v: true, u: updateAutofocus };\n\n/**\n * AUTOFOCUS function creates a {@link AttributeDirective} that sets autofocus on an element.\n *\n * `undefined` values are ignored.\n *\n * @example\n *\n *   const e = input(\"\", { autofocus: AUTOFOCUS(true) });\n *\n * @param v - Autofocus state\n * @returns {@link AttributeDirective}\n */\nexport const AUTOFOCUS = (v: boolean | undefined): AttributeDirective<boolean> => (v === void 0) ?\n  ATTRIBUTE_DIRECTIVE_SKIP_UNDEFINED as any as AttributeDirective<boolean> :\n  v ? AUTOFOCUS_TRUE : AUTOFOCUS_FALSE;\n","import { VNodeFlags, VNode } from \"./vnode\";\n\n/**\n * map creates a children collection with the results of calling a provided function on every element in the calling\n * array.\n *\n * @example\n *\n *     render(\n *       div().c(\n *         map([1, 2, 3], (item) => div().k(item)),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param items - Array\n * @param fn - Function that produces an element for the children collection\n * @returns Virtual DOM collection\n */\nexport function map<T, U>(array: Array<T>, fn: (item: T, index: number) => VNode<U> | null): VNode<U> | null {\n  let first: VNode<any> | null = null;\n  let prev: VNode<any> | null = null;\n  for (let i = 0; i < array.length; ++i) {\n    const n = fn(array[i], i);\n    if (n !== null) {\n      /* istanbul ignore else */\n      if (DEBUG) {\n        if ((n._f & VNodeFlags.Key) === 0) {\n          throw new Error(`VNodes created with a map() function should have an explicit key`);\n        }\n        if (n._l !== n) {\n          throw new Error(`VNodes created with a map() function should be a singular nodes`);\n        }\n      }\n      if (prev !== null) {\n        n._l = prev;\n        prev._r = n;\n      } else {\n        first = n;\n      }\n      prev = n;\n    }\n  }\n  if (first !== null) {\n    first._l = prev!;\n    first._f |= VNodeFlags.KeyedList;\n    return first;\n  }\n  return null;\n}\n\n/**\n * mapRange creates a children collection with the results of calling a provided function on every number in the\n * provided range.\n *\n * @example\n *\n *     const items = [1, 2, 3];\n *\n *     render(\n *       div().c(\n *         mapRange(0, items.length, (i) => div().k(items[i])),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param start - Range start\n * @param end - Range end\n * @param fn - Function that produces an element for the children collection\n * @returns Virtual DOM collection\n */\nexport function mapRange<T>(start: number, end: number, fn: (idx: number) => VNode<T> | null): VNode<T> | null {\n  const length = end - start;\n  let first: VNode<any> | null = null;\n  let prev: VNode<any> | null = null;\n  while (start < length) {\n    const n = fn(start++);\n    if (n !== null) {\n      /* istanbul ignore else */\n      if (DEBUG) {\n        if ((n._f & VNodeFlags.Key) === 0) {\n          throw new Error(`VNodes created with a mapRange() function should have an explicit key`);\n        }\n        if (n._l !== n) {\n          throw new Error(`VNodes created with a mapRange() function should be a singular nodes`);\n        }\n      }\n      if (prev !== null) {\n        n._l = prev;\n        prev._r = n;\n      } else {\n        first = n;\n      }\n      prev = n;\n    }\n  }\n  if (first !== null) {\n    first._l = prev!;\n    first._f |= VNodeFlags.KeyedList;\n    return first;\n  }\n  return null;\n}\n\n/**\n * mapIterable creates a children collection from an `IterableIterator` object.\n *\n * @example\n *\n *     const items = [1, 2, 3];\n *\n *     render(\n *       div().c(mapIterable(function* () {\n *         for (const item of items) {\n *           yield div().k(item);\n *         }\n *       }())),\n *       DOMContainer,\n *     );\n *\n * @param iterable - Iterable iterator\n * @returns Virtual DOM collection\n */\nexport function mapIterable<T>(iterable: IterableIterator<VNode<T>>): VNode<T> | null {\n  let first: VNode<any> | null = null;\n  let prev: VNode<any> | null = null;\n\n  for (const n of iterable) {\n    /* istanbul ignore else */\n    if (DEBUG) {\n      if ((n._f & VNodeFlags.Key) === 0) {\n        throw new Error(`VNodes created with a mapIterable() function should have an explicit key`);\n      }\n      if (n._l !== n) {\n        throw new Error(`VNodes created with a mapIterable() function should be a singular nodes`);\n      }\n    }\n    if (prev !== null) {\n      n._l = prev;\n      prev._r = n;\n    } else {\n      first = n;\n    }\n    prev = n;\n  }\n\n  if (first !== null) {\n    first._l = prev!;\n    first._f |= VNodeFlags.KeyedList;\n    return first;\n  }\n  return null;\n}\n","import {\n  HTMLAnchorElementAttrs, HTMLElementAttrs, HTMLAreaElementAttrs, HTMLAudioElementAttrs,\n  HTMLBaseElementAttrs, HTMLBodyElementAttrs, HTMLBRElementAttrs, HTMLButtonElementAttrs,\n  HTMLCanvasElementAttrs, HTMLQuoteElementAttrs, HTMLTableCaptionElementAttrs, HTMLTableColElementAttrs,\n  HTMLModElementAttrs, HTMLDivElementAttrs, HTMLDListElementAttrs, HTMLFieldSetElementAttrs, HTMLFormElementAttrs,\n  HTMLHeadElementAttrs, HTMLHeadingElementAttrs, HTMLHRElementAttrs, HTMLHtmlElementAttrs, HTMLIFrameElementAttrs,\n  HTMLImageElementAttrs, HTMLInputElementAttrs, HTMLLabelElementAttrs, HTMLLegendElementAttrs, HTMLLIElementAttrs,\n  HTMLLinkElementAttrs, HTMLMapElementAttrs, HTMLMenuElementAttrs, HTMLMetaElementAttrs, HTMLMeterElementAttrs,\n  HTMLOListElementAttrs, HTMLOptGroupElementAttrs, HTMLOptionElementAttrs, HTMLParagraphElementAttrs,\n  HTMLPictureElementAttrs, HTMLPreElementAttrs, HTMLProgressElementAttrs, HTMLScriptElementAttrs,\n  HTMLSelectElementAttrs, HTMLSourceElementAttrs, HTMLSpanElementAttrs, HTMLStyleElementAttrs,\n  HTMLTableDataCellElementAttrs, HTMLTableElementAttrs, HTMLTableHeaderCellElementAttrs, HTMLTableRowElementAttrs,\n  HTMLTableSectionElementAttrs, HTMLTemplateElementAttrs, HTMLTextAreaElementAttrs, HTMLTitleElementAttrs,\n  HTMLTrackElementAttrs, HTMLUListElementAttrs, HTMLVideoElementAttrs,\n  CSSStyleProps,\n\n  ATTRIBUTE_DIRECTIVE_SKIP_UNDEFINED,\n\n  VNode, VNodeFlags, AttributeDirective,\n} from \"ivi\";\n\nconst enum TagId {\n  A = 1,\n  Abbr = 2,\n  Address = 3,\n  Area = 4,\n  Article = 5,\n  Aside = 6,\n  B = 7,\n  Base = 8,\n  Bdo = 9,\n  Blockquote = 10,\n  Body = 11,\n  Br = 12,\n  Button = 13,\n  Canvas = 14,\n  Caption = 15,\n  Cite = 16,\n  Code = 17,\n  Col = 18,\n  Colgroup = 19,\n  Dd = 20,\n  Del = 21,\n  Dfn = 22,\n  Div = 23,\n  Dl = 24,\n  Dt = 25,\n  Em = 26,\n  Fieldset = 27,\n  Figcaption = 28,\n  Figure = 29,\n  Footer = 30,\n  Form = 31,\n  H1 = 32,\n  H2 = 33,\n  H3 = 34,\n  H4 = 35,\n  H5 = 36,\n  H6 = 37,\n  Head = 38,\n  Header = 39,\n  Hgroup = 40,\n  Hr = 41,\n  Html = 42,\n  I = 43,\n  Iframe = 44,\n  Img = 45,\n  Input = 46,\n  Ins = 47,\n  Kbd = 48,\n  Label = 49,\n  Legend = 50,\n  Li = 51,\n  Link = 52,\n  Main = 53,\n  Map = 54,\n  Mark = 55,\n  Menu = 56,\n  Meta = 57,\n  Meter = 58,\n  Nav = 59,\n  Noscript = 60,\n  Ol = 61,\n  Optgroup = 62,\n  Option = 63,\n  P = 64,\n  Picture = 65,\n  Pre = 66,\n  Progress = 67,\n  Q = 68,\n  Rt = 69,\n  Ruby = 70,\n  S = 71,\n  Samp = 72,\n  Script = 73,\n  Section = 74,\n  Select = 75,\n  Source = 76,\n  Span = 77,\n  Strong = 78,\n  Style = 79,\n  Sub = 80,\n  Sup = 81,\n  Table = 82,\n  Tbody = 83,\n  Td = 84,\n  Template = 85,\n  Textarea = 86,\n  Tfoot = 87,\n  Th = 88,\n  Thead = 89,\n  Time = 90,\n  Title = 91,\n  Tr = 92,\n  Track = 93,\n  U = 94,\n  Ul = 95,\n  Wbr = 96,\n  Audio = 97,\n  Video = 98,\n}\n\n/**\n * {@link AttributeDirective} with `\"\"` value and {@link updateValue} sync function.\n */\nconst VALUE_EMPTY_STRING: AttributeDirective<string | number> = { v: \"\", u: updateValue };\n\n/**\n * {@link AttributeDirective} with `false` value and {@link updateChecked} sync function.\n */\nconst CHECKED_FALSE: AttributeDirective<boolean> = { v: false, u: updateChecked };\n\n/**\n * {@link AttributeDirective} with `true` value and {@link updateChecked} sync function.\n */\nconst CHECKED_TRUE: AttributeDirective<boolean> = { v: true, u: updateChecked };\n\n/**\n * Synchronization function for {@link AttributeDirective} created with {@link VALUE} function.\n *\n * @param element - Target element\n * @param key - Attribute key\n * @param prev - Previous value\n * @param next - Next value\n */\nfunction updateValue(\n  element: Element,\n  key: string,\n  prev: string | number | undefined,\n  next: string | number | undefined,\n) {\n  if (prev === void 0) {\n    if (next !== \"\") {\n      (element as HTMLInputElement | HTMLTextAreaElement).value = next as string;\n    }\n  } else {\n    if ((element as HTMLInputElement | HTMLTextAreaElement).value !== next) {\n      (element as HTMLInputElement | HTMLTextAreaElement).value = next as string;\n    }\n  }\n}\n\n/**\n * Synchronization function for {@link AttributeDirective} created with {@link CHECKED} function.\n *\n * @param element - Target element\n * @param key - Attribute key\n * @param prev - Previous value\n * @param next - Next value\n */\nfunction updateChecked(\n  element: Element,\n  key: string,\n  prev: boolean | undefined,\n  next: boolean | undefined,\n) {\n  if (prev === void 0) {\n    if (next) {\n      (element as HTMLInputElement).checked = next;\n    }\n  } else {\n    if ((element as HTMLInputElement).checked !== next) {\n      (element as HTMLInputElement).checked = next!;\n    }\n  }\n}\n\n/**\n * VALUE function creates a {@link AttributeDirective} that assigns a `value` property to an HTMLInputElement or\n * HTMLTextAreaElement.\n *\n * `undefined` values are ignored.\n *\n * @example\n *\n *   const e = input(\"\", { value: VALUE(\"value\") });\n *\n * @param v - Value\n * @returns {@link AttributeDirective}\n */\nexport function VALUE(v: string | number | undefined): AttributeDirective<string | number> {\n  return (v === void 0) ?\n    ATTRIBUTE_DIRECTIVE_SKIP_UNDEFINED :\n    v === \"\" ?\n      VALUE_EMPTY_STRING :\n      { v, u: updateValue };\n}\n\n/**\n * CHECKED function creates a {@link AttributeDirective} that assigns a `checked` property to an HTMLInputElement.\n *\n * `undefined` values are ignored.\n *\n * @example\n *\n *   const e = input(\"\", { checked: CHECKED(true) });\n *\n * @param v - Checked value\n * @returns {@link AttributeDirective}\n */\nexport function CHECKED(v: boolean | undefined): AttributeDirective<boolean> {\n  return (v === void 0) ?\n    ATTRIBUTE_DIRECTIVE_SKIP_UNDEFINED as any as AttributeDirective<boolean> :\n    v ? CHECKED_TRUE : CHECKED_FALSE;\n}\n\n/* tslint:disable:max-line-length */\n/**\n * Creates Virtual DOM HTML element <a>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <a>\n */\nexport const a = (className?: string, attrs?: HTMLAnchorElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLAnchorElementAttrs | undefined, HTMLAnchorElement>(\n    VNodeFlags.Element | (TagId.A << VNodeFlags.ElementIdOffset),\n    \"a\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <abbr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/abbr}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <abbr>\n */\nexport const abbr = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Abbr << VNodeFlags.ElementIdOffset),\n    \"abbr\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <address>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/address}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <address>\n */\nexport const address = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Address << VNodeFlags.ElementIdOffset),\n    \"address\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <article>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <article>\n */\nexport const article = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Article << VNodeFlags.ElementIdOffset),\n    \"article\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <aside>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <aside>\n */\nexport const aside = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Aside << VNodeFlags.ElementIdOffset),\n    \"aside\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <b>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/b}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <b>\n */\nexport const b = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.B << VNodeFlags.ElementIdOffset),\n    \"b\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <base>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <base>\n */\nexport const base = (className?: string, attrs?: HTMLBaseElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLBaseElementAttrs | undefined, HTMLBaseElement>(\n    VNodeFlags.Element | (TagId.Base << VNodeFlags.ElementIdOffset),\n    \"base\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <bdo>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/bdo}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <bdo>\n */\nexport const bdo = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Bdo << VNodeFlags.ElementIdOffset),\n    \"bdo\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <blockquote>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <blockquote>\n */\nexport const blockquote = (className?: string, attrs?: HTMLQuoteElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLQuoteElementAttrs | undefined, HTMLQuoteElement>(\n    VNodeFlags.Element | (TagId.Blockquote << VNodeFlags.ElementIdOffset),\n    \"blockquote\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <body>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <body>\n */\nexport const body = (className?: string, attrs?: HTMLBodyElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLBodyElementAttrs | undefined, HTMLBodyElement>(\n    VNodeFlags.Element | (TagId.Body << VNodeFlags.ElementIdOffset),\n    \"body\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <br>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/br}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <br>\n */\nexport const br = (className?: string, attrs?: HTMLBRElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLBRElementAttrs | undefined, HTMLBRElement>(\n    VNodeFlags.Element | (TagId.Br << VNodeFlags.ElementIdOffset),\n    \"br\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <button>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <button>\n */\nexport const button = (className?: string, attrs?: HTMLButtonElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLButtonElementAttrs | undefined, HTMLButtonElement>(\n    VNodeFlags.Element | (TagId.Button << VNodeFlags.ElementIdOffset),\n    \"button\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <canvas>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <canvas>\n */\nexport const canvas = (className?: string, attrs?: HTMLCanvasElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLCanvasElementAttrs | undefined, HTMLCanvasElement>(\n    VNodeFlags.Element | (TagId.Canvas << VNodeFlags.ElementIdOffset),\n    \"canvas\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <caption>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <caption>\n */\nexport const caption = (className?: string, attrs?: HTMLTableCaptionElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLTableCaptionElementAttrs | undefined, HTMLTableCaptionElement>(\n    VNodeFlags.Element | (TagId.Caption << VNodeFlags.ElementIdOffset),\n    \"caption\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <cite>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/cite}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <cite>\n */\nexport const cite = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Cite << VNodeFlags.ElementIdOffset),\n    \"cite\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <code>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/code}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <code>\n */\nexport const code = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Code << VNodeFlags.ElementIdOffset),\n    \"code\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <col>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <col>\n */\nexport const col = (className?: string, attrs?: HTMLTableColElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLTableColElementAttrs | undefined, HTMLTableColElement>(\n    VNodeFlags.Element | (TagId.Col << VNodeFlags.ElementIdOffset),\n    \"col\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <colgroup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/colgroup}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <colgroup>\n */\nexport const colgroup = (className?: string, attrs?: HTMLTableColElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLTableColElementAttrs | undefined, HTMLTableColElement>(\n    VNodeFlags.Element | (TagId.Colgroup << VNodeFlags.ElementIdOffset),\n    \"colgroup\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <del>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/del}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <del>\n */\nexport const del = (className?: string, attrs?: HTMLModElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLModElementAttrs | undefined, HTMLModElement>(\n    VNodeFlags.Element | (TagId.Del << VNodeFlags.ElementIdOffset),\n    \"del\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <dfn>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dfn}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <dfn>\n */\nexport const dfn = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Dfn << VNodeFlags.ElementIdOffset),\n    \"dfn\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <div>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <div>\n */\nexport const div = (className?: string, attrs?: HTMLDivElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLDivElementAttrs | undefined, HTMLDivElement>(\n    VNodeFlags.Element | (TagId.Div << VNodeFlags.ElementIdOffset),\n    \"div\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <dd>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dd}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <dd>\n */\nexport const dd = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Dd << VNodeFlags.ElementIdOffset),\n    \"dd\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <dl>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dl}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <dl>\n */\nexport const dl = (className?: string, attrs?: HTMLDListElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLDListElementAttrs | undefined, HTMLDListElement>(\n    VNodeFlags.Element | (TagId.Dl << VNodeFlags.ElementIdOffset),\n    \"dl\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <dt>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <dt>\n */\nexport const dt = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Dt << VNodeFlags.ElementIdOffset),\n    \"dt\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <em>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/em}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <em>\n */\nexport const em = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Em << VNodeFlags.ElementIdOffset),\n    \"em\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <fieldset>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/fieldset}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <fieldset>\n */\nexport const fieldset = (className?: string, attrs?: HTMLFieldSetElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLFieldSetElementAttrs | undefined, HTMLFieldSetElement>(\n    VNodeFlags.Element | (TagId.Fieldset << VNodeFlags.ElementIdOffset),\n    \"fieldset\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <figcaption>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figcaption}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <figcaption>\n */\nexport const figcaption = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Figcaption << VNodeFlags.ElementIdOffset),\n    \"figcaption\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <figure>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figure}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <figure>\n */\nexport const figure = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Figure << VNodeFlags.ElementIdOffset),\n    \"figure\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <footer>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/footer}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <footer>\n */\nexport const footer = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Footer << VNodeFlags.ElementIdOffset),\n    \"footer\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <form>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <form>\n */\nexport const form = (className?: string, attrs?: HTMLFormElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLFormElementAttrs | undefined, HTMLFormElement>(\n    VNodeFlags.Element | (TagId.Form << VNodeFlags.ElementIdOffset),\n    \"form\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <h1>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h1}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <h1>\n */\nexport const h1 = (className?: string, attrs?: HTMLHeadingElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLHeadingElementAttrs | undefined, HTMLHeadingElement>(\n    VNodeFlags.Element | (TagId.H1 << VNodeFlags.ElementIdOffset),\n    \"h1\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <h2>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h2}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <h2>\n */\nexport const h2 = (className?: string, attrs?: HTMLHeadingElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLHeadingElementAttrs | undefined, HTMLHeadingElement>(\n    VNodeFlags.Element | (TagId.H2 << VNodeFlags.ElementIdOffset),\n    \"h2\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <h3>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h3}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <h3>\n */\nexport const h3 = (className?: string, attrs?: HTMLHeadingElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLHeadingElementAttrs | undefined, HTMLHeadingElement>(\n    VNodeFlags.Element | (TagId.H3 << VNodeFlags.ElementIdOffset),\n    \"h3\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <h4>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h4}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <h4>\n */\nexport const h4 = (className?: string, attrs?: HTMLHeadingElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLHeadingElementAttrs | undefined, HTMLHeadingElement>(\n    VNodeFlags.Element | (TagId.H4 << VNodeFlags.ElementIdOffset),\n    \"h4\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <h5>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h5}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <h5>\n */\nexport const h5 = (className?: string, attrs?: HTMLHeadingElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLHeadingElementAttrs | undefined, HTMLHeadingElement>(\n    VNodeFlags.Element | (TagId.H5 << VNodeFlags.ElementIdOffset),\n    \"h5\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <h6>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h6}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <h6>\n */\nexport const h6 = (className?: string, attrs?: HTMLHeadingElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLHeadingElementAttrs | undefined, HTMLHeadingElement>(\n    VNodeFlags.Element | (TagId.H6 << VNodeFlags.ElementIdOffset),\n    \"h6\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <head>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <head>\n */\nexport const head = (className?: string, attrs?: HTMLHeadElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLHeadElementAttrs | undefined, HTMLHeadElement>(\n    VNodeFlags.Element | (TagId.Head << VNodeFlags.ElementIdOffset),\n    \"head\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <header>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/header}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <header>\n */\nexport const header = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Header << VNodeFlags.ElementIdOffset),\n    \"header\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <hgroup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hgroup}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <hgroup>\n */\nexport const hgroup = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Hgroup << VNodeFlags.ElementIdOffset),\n    \"hgroup\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <hr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hr}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <hr>\n */\nexport const hr = (className?: string, attrs?: HTMLHRElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLHRElementAttrs | undefined, HTMLHRElement>(\n    VNodeFlags.Element | (TagId.Hr << VNodeFlags.ElementIdOffset),\n    \"hr\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <html>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <html>\n */\nexport const html = (className?: string, attrs?: HTMLHtmlElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLHtmlElementAttrs | undefined, HTMLHtmlElement>(\n    VNodeFlags.Element | (TagId.Html << VNodeFlags.ElementIdOffset),\n    \"html\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <i>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/i}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <i>\n */\nexport const i = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.I << VNodeFlags.ElementIdOffset),\n    \"i\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <iframe>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <iframe>\n */\nexport const iframe = (className?: string, attrs?: HTMLIFrameElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLIFrameElementAttrs | undefined, HTMLIFrameElement>(\n    VNodeFlags.Element | (TagId.Iframe << VNodeFlags.ElementIdOffset),\n    \"iframe\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <img>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <img>\n */\nexport const img = (className?: string, attrs?: HTMLImageElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLImageElementAttrs | undefined, HTMLImageElement>(\n    VNodeFlags.Element | (TagId.Img << VNodeFlags.ElementIdOffset),\n    \"img\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <area>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <area>\n */\nexport const imgArea = (className?: string, attrs?: HTMLAreaElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLAreaElementAttrs | undefined, HTMLAreaElement>(\n    VNodeFlags.Element | (TagId.Area << VNodeFlags.ElementIdOffset),\n    \"area\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <map>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <map>\n */\nexport const imgMap = (className?: string, attrs?: HTMLMapElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLMapElementAttrs | undefined, HTMLMapElement>(\n    VNodeFlags.Element | (TagId.Map << VNodeFlags.ElementIdOffset),\n    \"map\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <ins>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ins}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <ins>\n */\nexport const ins = (className?: string, attrs?: HTMLModElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLModElementAttrs | undefined, HTMLModElement>(\n    VNodeFlags.Element | (TagId.Ins << VNodeFlags.ElementIdOffset),\n    \"ins\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <kbd>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/kbd}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <kbd>\n */\nexport const kbd = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Kbd << VNodeFlags.ElementIdOffset),\n    \"kbd\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <label>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <label>\n */\nexport const label = (className?: string, attrs?: HTMLLabelElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLLabelElementAttrs | undefined, HTMLLabelElement>(\n    VNodeFlags.Element | (TagId.Label << VNodeFlags.ElementIdOffset),\n    \"label\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <legend>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/legend}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <legend>\n */\nexport const legend = (className?: string, attrs?: HTMLLegendElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLLegendElementAttrs | undefined, HTMLLegendElement>(\n    VNodeFlags.Element | (TagId.Legend << VNodeFlags.ElementIdOffset),\n    \"legend\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <li>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <li>\n */\nexport const li = (className?: string, attrs?: HTMLLIElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLLIElementAttrs | undefined, HTMLLIElement>(\n    VNodeFlags.Element | (TagId.Li << VNodeFlags.ElementIdOffset),\n    \"li\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <link>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <link>\n */\nexport const link = (className?: string, attrs?: HTMLLinkElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLLinkElementAttrs | undefined, HTMLLinkElement>(\n    VNodeFlags.Element | (TagId.Link << VNodeFlags.ElementIdOffset),\n    \"link\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <main>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/main}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <main>\n */\nexport const main = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Main << VNodeFlags.ElementIdOffset),\n    \"main\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <mark>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/mark}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <mark>\n */\nexport const mark = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Mark << VNodeFlags.ElementIdOffset),\n    \"mark\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <menu>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/menu}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <menu>\n */\nexport const menu = (className?: string, attrs?: HTMLMenuElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLMenuElementAttrs | undefined, HTMLMenuElement>(\n    VNodeFlags.Element | (TagId.Menu << VNodeFlags.ElementIdOffset),\n    \"menu\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <meta>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <meta>\n */\nexport const meta = (className?: string, attrs?: HTMLMetaElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLMetaElementAttrs | undefined, HTMLMetaElement>(\n    VNodeFlags.Element | (TagId.Meta << VNodeFlags.ElementIdOffset),\n    \"meta\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <meter>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meter}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <meter>\n */\nexport const meter = (className?: string, attrs?: HTMLMeterElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLMeterElementAttrs | undefined, HTMLMeterElement>(\n    VNodeFlags.Element | (TagId.Meter << VNodeFlags.ElementIdOffset),\n    \"meter\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <nav>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <nav>\n */\nexport const nav = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Nav << VNodeFlags.ElementIdOffset),\n    \"nav\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <noscript>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/noscript}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <noscript>\n */\nexport const noscript = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Noscript << VNodeFlags.ElementIdOffset),\n    \"noscript\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <ol>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ol}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <ol>\n */\nexport const ol = (className?: string, attrs?: HTMLOListElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLOListElementAttrs | undefined, HTMLOListElement>(\n    VNodeFlags.Element | (TagId.Ol << VNodeFlags.ElementIdOffset),\n    \"ol\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <optgroup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/optgroup}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <optgroup>\n */\nexport const optgroup = (className?: string, attrs?: HTMLOptGroupElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLOptGroupElementAttrs | undefined, HTMLOptGroupElement>(\n    VNodeFlags.Element | (TagId.Optgroup << VNodeFlags.ElementIdOffset),\n    \"optgroup\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <option>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <option>\n */\nexport const option = (className?: string, attrs?: HTMLOptionElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLOptionElementAttrs | undefined, HTMLOptionElement>(\n    VNodeFlags.Element | (TagId.Option << VNodeFlags.ElementIdOffset),\n    \"option\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <p>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <p>\n */\nexport const p = (className?: string, attrs?: HTMLParagraphElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLParagraphElementAttrs | undefined, HTMLParagraphElement>(\n    VNodeFlags.Element | (TagId.P << VNodeFlags.ElementIdOffset),\n    \"p\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <picture>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <picture>\n */\nexport const picture = (className?: string, attrs?: HTMLPictureElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLPictureElementAttrs | undefined, HTMLPictureElement>(\n    VNodeFlags.Element | (TagId.Picture << VNodeFlags.ElementIdOffset),\n    \"picture\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <pre>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/pre}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <pre>\n */\nexport const pre = (className?: string, attrs?: HTMLPreElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLPreElementAttrs | undefined, HTMLPreElement>(\n    VNodeFlags.Element | (TagId.Pre << VNodeFlags.ElementIdOffset),\n    \"pre\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <progress>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/progress}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <progress>\n */\nexport const progress = (className?: string, attrs?: HTMLProgressElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLProgressElementAttrs | undefined, HTMLProgressElement>(\n    VNodeFlags.Element | (TagId.Progress << VNodeFlags.ElementIdOffset),\n    \"progress\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <q>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <q>\n */\nexport const q = (className?: string, attrs?: HTMLQuoteElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLQuoteElementAttrs | undefined, HTMLQuoteElement>(\n    VNodeFlags.Element | (TagId.Q << VNodeFlags.ElementIdOffset),\n    \"q\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <rt>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/rt}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <rt>\n */\nexport const rt = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Rt << VNodeFlags.ElementIdOffset),\n    \"rt\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <ruby>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ruby}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <ruby>\n */\nexport const ruby = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Ruby << VNodeFlags.ElementIdOffset),\n    \"ruby\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <s>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/s}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <s>\n */\nexport const s = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.S << VNodeFlags.ElementIdOffset),\n    \"s\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <samp>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/samp}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <samp>\n */\nexport const samp = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Samp << VNodeFlags.ElementIdOffset),\n    \"samp\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <script>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <script>\n */\nexport const script = (className?: string, attrs?: HTMLScriptElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLScriptElementAttrs | undefined, HTMLScriptElement>(\n    VNodeFlags.Element | (TagId.Script << VNodeFlags.ElementIdOffset),\n    \"script\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <section>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/section}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <section>\n */\nexport const section = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Section << VNodeFlags.ElementIdOffset),\n    \"section\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <select>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <select>\n */\nexport const select = (className?: string, attrs?: HTMLSelectElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLSelectElementAttrs | undefined, HTMLSelectElement>(\n    VNodeFlags.Element | (TagId.Select << VNodeFlags.ElementIdOffset),\n    \"select\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <source>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <source>\n */\nexport const source = (className?: string, attrs?: HTMLSourceElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLSourceElementAttrs | undefined, HTMLSourceElement>(\n    VNodeFlags.Element | (TagId.Source << VNodeFlags.ElementIdOffset),\n    \"source\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <span>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <span>\n */\nexport const span = (className?: string, attrs?: HTMLSpanElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLSpanElementAttrs | undefined, HTMLSpanElement>(\n    VNodeFlags.Element | (TagId.Span << VNodeFlags.ElementIdOffset),\n    \"span\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <strong>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/strong}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <strong>\n */\nexport const strong = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Strong << VNodeFlags.ElementIdOffset),\n    \"strong\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <style>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <style>\n */\nexport const style = (className?: string, attrs?: HTMLStyleElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLStyleElementAttrs | undefined, HTMLStyleElement>(\n    VNodeFlags.Element | (TagId.Style << VNodeFlags.ElementIdOffset),\n    \"style\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <sub>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sub}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <sub>\n */\nexport const sub = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Sub << VNodeFlags.ElementIdOffset),\n    \"sub\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <sup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sup}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <sup>\n */\nexport const sup = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Sup << VNodeFlags.ElementIdOffset),\n    \"sup\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <table>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <table>\n */\nexport const table = (className?: string, attrs?: HTMLTableElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLTableElementAttrs | undefined, HTMLTableElement>(\n    VNodeFlags.Element | (TagId.Table << VNodeFlags.ElementIdOffset),\n    \"table\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <tbody>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tbody}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <tbody>\n */\nexport const tbody = (className?: string, attrs?: HTMLTableSectionElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLTableSectionElementAttrs | undefined, HTMLTableSectionElement>(\n    VNodeFlags.Element | (TagId.Tbody << VNodeFlags.ElementIdOffset),\n    \"tbody\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <td>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <td>\n */\nexport const td = (className?: string, attrs?: HTMLTableDataCellElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLTableDataCellElementAttrs | undefined, HTMLTableDataCellElement>(\n    VNodeFlags.Element | (TagId.Td << VNodeFlags.ElementIdOffset),\n    \"td\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <template>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <template>\n */\nexport const template = (className?: string, attrs?: HTMLTemplateElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLTemplateElementAttrs | undefined, HTMLTemplateElement>(\n    VNodeFlags.Element | (TagId.Template << VNodeFlags.ElementIdOffset),\n    \"template\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <tfoot>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tfoot}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <tfoot>\n */\nexport const tfoot = (className?: string, attrs?: HTMLTableSectionElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLTableSectionElementAttrs | undefined, HTMLTableSectionElement>(\n    VNodeFlags.Element | (TagId.Tfoot << VNodeFlags.ElementIdOffset),\n    \"tfoot\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <th>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <th>\n */\nexport const th = (className?: string, attrs?: HTMLTableHeaderCellElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLTableHeaderCellElementAttrs | undefined, HTMLTableHeaderCellElement>(\n    VNodeFlags.Element | (TagId.Th << VNodeFlags.ElementIdOffset),\n    \"th\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <thead>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/thead}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <thead>\n */\nexport const thead = (className?: string, attrs?: HTMLTableSectionElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLTableSectionElementAttrs | undefined, HTMLTableSectionElement>(\n    VNodeFlags.Element | (TagId.Thead << VNodeFlags.ElementIdOffset),\n    \"thead\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <time>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/time}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <time>\n */\nexport const time = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Time << VNodeFlags.ElementIdOffset),\n    \"time\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <title>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <title>\n */\nexport const title = (className?: string, attrs?: HTMLTitleElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLTitleElementAttrs | undefined, HTMLTitleElement>(\n    VNodeFlags.Element | (TagId.Title << VNodeFlags.ElementIdOffset),\n    \"title\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <tr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tr}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <tr>\n */\nexport const tr = (className?: string, attrs?: HTMLTableRowElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLTableRowElementAttrs | undefined, HTMLTableRowElement>(\n    VNodeFlags.Element | (TagId.Tr << VNodeFlags.ElementIdOffset),\n    \"tr\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <track>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <track>\n */\nexport const track = (className?: string, attrs?: HTMLTrackElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLTrackElementAttrs | undefined, HTMLTrackElement>(\n    VNodeFlags.Element | (TagId.Track << VNodeFlags.ElementIdOffset),\n    \"track\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <u>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/u}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <u>\n */\nexport const u = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.U << VNodeFlags.ElementIdOffset),\n    \"u\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <ul>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <ul>\n */\nexport const ul = (className?: string, attrs?: HTMLUListElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLUListElementAttrs | undefined, HTMLUListElement>(\n    VNodeFlags.Element | (TagId.Ul << VNodeFlags.ElementIdOffset),\n    \"ul\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <wbr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/wbr}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <wbr>\n */\nexport const wbr = (className?: string, attrs?: HTMLElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLElementAttrs | undefined, HTMLElement>(\n    VNodeFlags.Element | (TagId.Wbr << VNodeFlags.ElementIdOffset),\n    \"wbr\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <textarea>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <textarea>\n */\nexport const textarea = (className?: string, attrs?: HTMLTextAreaElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLTextAreaElementAttrs | undefined, HTMLTextAreaElement>(\n    VNodeFlags.Element | (TagId.Textarea << VNodeFlags.ElementIdOffset),\n    \"textarea\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <input>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <input>\n */\nexport const input = (className?: string, attrs?: HTMLInputElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLInputElementAttrs | undefined, HTMLInputElement>(\n    VNodeFlags.Element | (TagId.Input << VNodeFlags.ElementIdOffset),\n    \"input\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <audio>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <audio>\n */\nexport const audio = (className?: string, attrs?: HTMLAudioElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLAudioElementAttrs | undefined, HTMLAudioElement>(\n    VNodeFlags.Element | (TagId.Audio << VNodeFlags.ElementIdOffset),\n    \"audio\",\n    attrs,\n    className,\n    css,\n  )\n);\n\n/**\n * Creates Virtual DOM HTML element <video>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video}\n *\n * @param className - Class name\n * @param attrs - Attributes\n * @param css - Styles\n * @returns Virtual DOM HTML element <video>\n */\nexport const video = (className?: string, attrs?: HTMLVideoElementAttrs, css?: CSSStyleProps) => (\n  new VNode<HTMLVideoElementAttrs | undefined, HTMLVideoElement>(\n    VNodeFlags.Element | (TagId.Video << VNodeFlags.ElementIdOffset),\n    \"video\",\n    attrs,\n    className,\n    css,\n  )\n);\n","export const LEFT = { x: -1, y: 0 };\nexport const RIGHT = { x: 1, y: 0 };\nexport const UP = { x: 0, y: -1 };\nexport const DOWN = { x: 0, y: 1 };\nexport class Snake {\n    constructor(startPosition = { x: 0, y: 0 }) {\n        this.body = [];\n        this.grow = 4;\n        this.body.push(startPosition);\n    }\n    get head() {\n        return this.body[this.body.length - 1];\n    }\n    move(p) {\n        this.body.push(p);\n        if (this.grow) {\n            this.grow--;\n            return null;\n        }\n        else {\n            const r = this.body[0];\n            this.body = this.body.splice(1);\n            return r;\n        }\n    }\n}\nexport class Grid {\n    constructor(rows = 20, cols = 20) {\n        this.rows = rows;\n        this.cols = cols;\n        this.cells = new Array(rows * cols).fill(0);\n    }\n    pointToIndex(p) {\n        return this.cols * p.y + p.x;\n    }\n    mark(p, flag) {\n        this.cells[this.pointToIndex(p)] |= flag;\n    }\n    unmark(p, flag) {\n        this.cells[this.pointToIndex(p)] &= ~flag;\n    }\n    createRandomFood() {\n        let i = 0;\n        do {\n            i = (Math.random() * this.cells.length) | 0;\n        } while (this.cells[i] !== 0);\n        this.cells[i] |= 4 /* Food */;\n    }\n    isBodyAt(p) {\n        return !!(this.cells[this.pointToIndex(p)] & 1 /* Body */);\n    }\n    isHeadAt(p) {\n        return !!(this.cells[this.pointToIndex(p)] & 2 /* Head */);\n    }\n    isFoodAt(p) {\n        return !!(this.cells[this.pointToIndex(p)] & 4 /* Food */);\n    }\n}\nfunction addPoints(a, b) {\n    return {\n        x: a.x + b.x,\n        y: a.y + b.y,\n    };\n}\nfunction eqPoints(a, b) {\n    return a.x === b.x && a.y === b.y;\n}\nfunction mod(a, b) {\n    return ((a % b) + b) % b;\n}\nexport class Game {\n    constructor() {\n        this.gameOver = false;\n        this.startTime = 0;\n        this.currentTime = 0;\n        this.direction = { x: 1, y: 0 };\n        this.grid = new Grid();\n        this.snake = new Snake();\n        this.newDirection = null;\n        this.snake.body.forEach((p) => {\n            this.grid.mark(p, 1 /* Body */);\n        });\n        this.grid.mark(this.snake.head, 2 /* Head */);\n        this.grid.createRandomFood();\n    }\n    setNewDirection(dir) {\n        this.newDirection = dir;\n    }\n    updateState() {\n        if (!this.gameOver) {\n            if (this.newDirection) {\n                if (!eqPoints(addPoints(this.direction, this.newDirection), { x: 0, y: 0 })) {\n                    this.direction = this.newDirection;\n                }\n                this.newDirection = null;\n            }\n            let nextPosition = addPoints(this.snake.head, this.direction);\n            nextPosition = {\n                x: mod(nextPosition.x, this.grid.cols),\n                y: mod(nextPosition.y, this.grid.rows),\n            };\n            this.grid.unmark(this.snake.head, 2 /* Head */);\n            const tail = this.snake.move(nextPosition);\n            if (tail) {\n                this.grid.unmark(tail, 1 /* Body */);\n            }\n            this.grid.mark(nextPosition, 2 /* Head */);\n            if (this.grid.isBodyAt(nextPosition)) {\n                this.gameOver = true;\n            }\n            else if (this.grid.isFoodAt(nextPosition)) {\n                this.snake.grow = 3;\n                this.grid.unmark(nextPosition, 4 /* Food */);\n                this.grid.createRandomFood();\n            }\n            this.grid.mark(nextPosition, 1 /* Body */);\n        }\n    }\n}\n","import { render, component, map, onKeyDown, AUTOFOCUS } from \"ivi\";\nimport { createBox } from \"ivi-state\";\nimport { div } from \"ivi-html\";\nimport { Game, LEFT, RIGHT, UP, DOWN } from \"./state\";\nfunction cellClasses(flags) {\n    if (flags & 1 /* Body */) {\n        if (flags & 2 /* Head */) {\n            return \"Cell body head\";\n        }\n        return \"Cell body\";\n    }\n    else if (flags & 4 /* Food */) {\n        return \"Cell food\";\n    }\n    return \"Cell\";\n}\nconst CELL_SIZE = 30;\nconst GameView = component(() => {\n    let game;\n    const keyDown = onKeyDown((ev) => {\n        switch (ev.native.keyCode) {\n            case 37 /* ArrowLeft */:\n                game.setNewDirection(LEFT);\n                return 1 /* PreventDefault */;\n            case 38 /* ArrowUp */:\n                game.setNewDirection(UP);\n                return 1 /* PreventDefault */;\n            case 39 /* ArrowRight */:\n                game.setNewDirection(RIGHT);\n                return 1 /* PreventDefault */;\n            case 40 /* ArrowDown */:\n                game.setNewDirection(DOWN);\n                return 1 /* PreventDefault */;\n        }\n        return;\n    });\n    return (props) => (game = props.value,\n        div(game.gameOver ? \"SnakeGame gameOver\" : \"SnakeGame\").c(div(\"Grid\", {\n            \"tabIndex\": 0,\n            \"autofocus\": AUTOFOCUS(true),\n        }, {\n            \"width\": `${CELL_SIZE * game.grid.cols}px`,\n            \"height\": `${CELL_SIZE * game.grid.rows}px`,\n        }).e(keyDown).c(map(game.grid.cells, (c, i) => div(cellClasses(c)).k(i)))));\n});\nconst CONTAINER = document.getElementById(\"app\");\nconst GAME = new Game();\nfunction tick() {\n    GAME.updateState();\n    render(GameView(createBox(GAME)), CONTAINER);\n    setTimeout(tick, 100);\n}\ntick();\n","import { CSSStyleProps } from \"../dom/style\";\nimport { ComponentDescriptor, Component } from \"./component\";\nimport { VNodeFlags, VNode } from \"./vnode\";\n\n/**\n * `element()` creates a virtual DOM node factory that produces elements with predefined attributes and styles.\n *\n * @example\n *\n *     const DivWithIdAttribute = element(div(\"\", { id: \"predefined-id\" }));\n *\n *     render(\n *       DivWithIdAttribute(),\n *       document.getElementById(\"app\")!,\n *     );\n *\n * @param proto - Virtual DOM prototype\n * @returns factory that produces elements with predefined attributes\n */\nexport function element<P, N>(proto: VNode<P, N>): (className?: string, attrs?: P, css?: CSSStyleProps) => VNode<P, N> {\n  const flags = proto._f | VNodeFlags.ElementFactory;\n  return (className?: string, attrs?: P, css?: CSSStyleProps) => (\n    new VNode<P, N>(flags, proto, attrs, className, css)\n  );\n}\n\n/**\n * component creates a virtual DOM node factory that produces nodes for components.\n *\n * @example\n *\n *     const A = component<string>(() => {\n *       let _text;\n *       const click = onClick((ev) => console.log(_text));\n *\n *       return (text) => (\n *         _text = text,\n *         button()\n *           .e(click(text))\n *           .t(\"Click Me\")\n *       );\n *     });\n *\n * @param c - Component function.\n * @param shouldUpdate - `shouldUpdate` function.\n * @returns factory that produces component nodes\n */\nexport function component(\n  c: (c: Component<undefined>) => () => VNode,\n): () => VNode<undefined>;\n\n/**\n * component creates a virtual DOM node factory that produces nodes for components.\n *\n * @example\n *\n *     const A = component<string>(() => {\n *       let _text;\n *       const click = onClick((ev) => console.log(_text));\n *\n *       return (text) => (\n *         _text = text,\n *         button()\n *           .e(click(text))\n *           .t(\"Click Me\")\n *       );\n *     });\n *\n * @param c - Component function.\n * @param shouldUpdate - `shouldUpdate` function.\n * @returns factory that produces component nodes\n */\nexport function component<P>(\n  c: (c: Component<P>) => (props: P) => VNode,\n  shouldUpdate?: undefined extends P ? undefined : (prev: P, next: P) => boolean,\n): undefined extends P ? (props?: P) => VNode<P> : (props: P) => VNode<P>;\n\n/**\n * component creates a virtual DOM node factory that produces nodes for components.\n *\n * @example\n *\n *     const A = component<string>(() => {\n *       let _text;\n *       const click = onClick((ev) => console.log(_text));\n *\n *       return (text) => (\n *         _text = text,\n *         button()\n *           .e(click(text))\n *           .t(\"Click Me\")\n *       );\n *     });\n *\n * @param c - Component function.\n * @param shouldUpdate - `shouldUpdate` function.\n * @returns factory that produces component nodes\n */\nexport function component<P>(\n  c: (c: Component<P>) => (props: P) => VNode,\n  shouldUpdate?: (prev: P, next: P) => boolean,\n): (props: P) => VNode<P> {\n  const d: ComponentDescriptor<P> = { c, shouldUpdate };\n  const f = (props: P) => {\n    const n = new VNode<P>(VNodeFlags.Component, d, props, \"\", void 0);\n    /* istanbul ignore else */\n    if (DEBUG) {\n      n.factory = f;\n    }\n    return n;\n  };\n  return f;\n}\n\n/**\n * statelessComponent creates a virtual DOM node factory that produces nodes for stateless components.\n *\n * @example\n *\n *     const A = statelessComponent<string>(() => {\n *       return (text) => div().t(text);\n *     });\n *\n * @param update - Update function.\n * @param shouldUpdate - `shouldUpdate` function.\n * @returns factory that produces stateless component nodes\n */\nexport function statelessComponent(\n  update: () => VNode,\n): () => VNode<undefined>;\n\n/**\n * statelessComponent creates a virtual DOM node factory that produces nodes for stateless components.\n *\n * @example\n *\n *     const A = statelessComponent<string>(() => {\n *       return (text) => div().t(text);\n *     });\n *\n * @param update - Update function.\n * @param shouldUpdate - `shouldUpdate` function.\n * @returns factory that produces stateless component nodes\n */\nexport function statelessComponent<P>(\n  update: (props: P) => VNode,\n  shouldUpdate?: undefined extends P ? undefined : (prev: P, next: P) => boolean,\n): undefined extends P ? (props?: P) => VNode<P> : (props: P) => VNode<P>;\n\n/**\n * statelessComponent creates a virtual DOM node factory that produces nodes for stateless components.\n *\n * @example\n *\n *     const A = statelessComponent<string>(() => {\n *       return (text) => div().t(text);\n *     });\n *\n * @param update - Update function.\n * @param shouldUpdate - `shouldUpdate` function.\n * @returns factory that produces stateless component nodes\n */\nexport function statelessComponent<P>(\n  update: (props: P) => VNode,\n  shouldUpdate?: undefined extends P ? undefined : (prev: P, next: P) => boolean,\n): (props: P) => VNode<P> {\n  return component(() => update, shouldUpdate);\n}\n\n/**\n * context creates a virtual DOM node that will modify current context.\n *\n * @example\n *\n *     render(\n *       context({ key: 123 },\n *         ChildComponent(),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param ctx - Context object\n * @param child - child Virtual DOM node\n * @returns context node\n */\nexport function context<T = {}>(ctx: T, child: VNode): VNode<T> {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (child._l !== child) {\n      throw new Error(\"Context node contains an invalid child. Child should be a singular VNode.\");\n    }\n  }\n  const n = new VNode<T>(\n    VNodeFlags.UpdateContext,\n    null,\n    ctx,\n    \"\",\n    void 0,\n  );\n  n._c = child;\n  return n;\n}\n","\n/**\n * Box is a mutable container for immutable objects.\n */\nexport interface Box<T> {\n  /**\n   * Value.\n   */\n  value: T;\n}\n\n/**\n * BoxSnapshot contains a boxed value snapshot.\n */\nexport interface BoxSnapshot<T> extends Box<T> {\n  /**\n   * Box that was used to create a snapshot.\n   */\n  readonly box: Box<T>;\n}\n\n/**\n * createBox creates a new Box for a `value`.\n *\n * @param value value.\n * @returns a new boxed value.\n */\nexport function createBox<T>(value: T): Box<T> {\n  return { value };\n}\n\n/**\n * createBoxSnapshot creates a boxed value snapshot.\n *\n * @param box box.\n * @returns a boxed value snapshot.\n */\nexport function createBoxSnapshot<T>(box: Box<T>): BoxSnapshot<T> {\n  return { box, value: box.value };\n}\n"],"sourceRoot":""}